{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DaSCH Service Platform Documentation Since 2017, the Data and Service Center for the Humanities (DaSCH) has been a member of the Swiss Academy of Humanities and Social Sciences. The main task of the institution is to operate a platform for humanities research data that ensures access to this data. In addition, the networking of data with other databases is to be promoted (linked open data), thus creating added value for research and the interested public. Services The task of the DaSCH is to promote and support the generation, use and long-term availability of research data in the humanities in Switzerland. The focus is on making research data in the humanities available online over the long term in the most direct and easy-to-use way possible and supporting researchers in using them for further research projects (\"re-use of research data\"). The DaSCH operates the necessary infrastructures (a so called \"keep-alive\" archive) and supports researchers in using this infrastructure. In order to reach this goal, the DaSCH offers the following services: Long term hosting of research data The infrastructure of the DaSCH is designed to host and keep accessible complex qualitative research data (e.g. any kind of databases and associated digital objects such as digital texts, images, movies, audio). The data has to be migrated to the infrastructure (both hardware and software) maintained by the DaSCH. All data will be held with a minimal redundancy of 6 identical copies at two geographically different locations in Switzerland (based on switchEngines) for an undefinite amount of time. Access to the data is provided by an API based on widely adopted standards (e.g. RESTful based on JSON-LD, IIIF, RDF, TEI/XML etc.) and through a generic web interface. In order to fulfill these requirements, DaSCH develops and maintains various software tools which are described and documented here. Documentation For researchers If you are a researcher you're probably most interested in the usage of the generic web application. In this case please have a look at our user guide . For developers The documentation for developers is splited into different groups depending on the software repository. Overview Knora is the main software framework in the back-end. ... Knora API JS Lib DSP-UI library Knora web app Sipi For the community In case of further questions, bug reports or if you want to get in contact with us have a look at our community page .","title":"DaSCH Service Platform Documentation"},{"location":"#dasch-service-platform-documentation","text":"Since 2017, the Data and Service Center for the Humanities (DaSCH) has been a member of the Swiss Academy of Humanities and Social Sciences. The main task of the institution is to operate a platform for humanities research data that ensures access to this data. In addition, the networking of data with other databases is to be promoted (linked open data), thus creating added value for research and the interested public.","title":"DaSCH Service Platform Documentation"},{"location":"#services","text":"The task of the DaSCH is to promote and support the generation, use and long-term availability of research data in the humanities in Switzerland. The focus is on making research data in the humanities available online over the long term in the most direct and easy-to-use way possible and supporting researchers in using them for further research projects (\"re-use of research data\"). The DaSCH operates the necessary infrastructures (a so called \"keep-alive\" archive) and supports researchers in using this infrastructure. In order to reach this goal, the DaSCH offers the following services:","title":"Services"},{"location":"#long-term-hosting-of-research-data","text":"The infrastructure of the DaSCH is designed to host and keep accessible complex qualitative research data (e.g. any kind of databases and associated digital objects such as digital texts, images, movies, audio). The data has to be migrated to the infrastructure (both hardware and software) maintained by the DaSCH. All data will be held with a minimal redundancy of 6 identical copies at two geographically different locations in Switzerland (based on switchEngines) for an undefinite amount of time. Access to the data is provided by an API based on widely adopted standards (e.g. RESTful based on JSON-LD, IIIF, RDF, TEI/XML etc.) and through a generic web interface. In order to fulfill these requirements, DaSCH develops and maintains various software tools which are described and documented here.","title":"Long term hosting of research data"},{"location":"#documentation","text":"","title":"Documentation"},{"location":"#for-researchers","text":"If you are a researcher you're probably most interested in the usage of the generic web application. In this case please have a look at our user guide .","title":"For researchers"},{"location":"#for-developers","text":"The documentation for developers is splited into different groups depending on the software repository. Overview Knora is the main software framework in the back-end. ... Knora API JS Lib DSP-UI library Knora web app Sipi","title":"For developers"},{"location":"#for-the-community","text":"In case of further questions, bug reports or if you want to get in contact with us have a look at our community page .","title":"For the community"},{"location":"community/about-us/","text":"About us Since 2017, the Data and Service Center for the Humanities (DaSCH) has been a member of the Swiss Academy of Humanities and Social Sciences. The main task of the institution is to operate a platform for humanities research data that ensures access to this data. In addition, the networking of data with other databases is to be promoted (linked open data), thus creating added value for research and the interested public. Get more information on our website: https://dasch.swiss Follow us on Github Twitter Facebook","title":"About us"},{"location":"community/about-us/#about-us","text":"Since 2017, the Data and Service Center for the Humanities (DaSCH) has been a member of the Swiss Academy of Humanities and Social Sciences. The main task of the institution is to operate a platform for humanities research data that ensures access to this data. In addition, the networking of data with other databases is to be promoted (linked open data), thus creating added value for research and the interested public. Get more information on our website: https://dasch.swiss Follow us on Github Twitter Facebook","title":"About us"},{"location":"community/faq/","text":"FAQ Do you have further questions or did you had issues by using our software. Let us know and get in contact with developers and users on discuss.dasch.swiss","title":"FAQ"},{"location":"community/faq/#faq","text":"Do you have further questions or did you had issues by using our software. Let us know and get in contact with developers and users on discuss.dasch.swiss","title":"FAQ"},{"location":"community/product-updates/","text":"Product Updates DSP-API (previously knora-api) https://github.com/dasch-swiss/knora-api/releases DSP-JS-LIB (previously knora-api-js-lib) https://github.com/dasch-swiss/knora-api-js-lib/releases DSP-UI-LIB (previously knora-ui-ng-lib) https://github.com/dasch-swiss/knora-ui-ng-lib/releases DSP-APP (previously knora-app) https://github.com/dasch-swiss/knora-app/releases Simple Image Presentation Interface (Sipi) https://github.com/dasch-swiss/sipi/releases","title":"Product Updates"},{"location":"community/product-updates/#product-updates","text":"","title":"Product Updates"},{"location":"community/product-updates/#dsp-api-previously-knora-api","text":"https://github.com/dasch-swiss/knora-api/releases","title":"DSP-API (previously knora-api)"},{"location":"community/product-updates/#dsp-js-lib-previously-knora-api-js-lib","text":"https://github.com/dasch-swiss/knora-api-js-lib/releases","title":"DSP-JS-LIB (previously knora-api-js-lib)"},{"location":"community/product-updates/#dsp-ui-lib-previously-knora-ui-ng-lib","text":"https://github.com/dasch-swiss/knora-ui-ng-lib/releases","title":"DSP-UI-LIB (previously knora-ui-ng-lib)"},{"location":"community/product-updates/#dsp-app-previously-knora-app","text":"https://github.com/dasch-swiss/knora-app/releases","title":"DSP-APP (previously knora-app)"},{"location":"community/product-updates/#simple-image-presentation-interface-sipi","text":"https://github.com/dasch-swiss/sipi/releases","title":"Simple Image Presentation Interface (Sipi)"},{"location":"developers/","text":"Developer Overview Local Development Environment At the DaSCH, the principal development envionment is Apple macOS . Each developer machine should have the following prerequisites installed: Docker Desktop: https://www.docker.com/products/docker-desktop Homebrew: https://brew.sh Java Adoptopenjdk 11 To install, follow these steps: $ brew tap AdoptOpenJDK/openjdk $ brew cask install AdoptOpenJDK/openjdk/adoptopenjdk11 To pin the version of Java, please add this environment variable to you startup script (bashrc, etc.): export JAVA_HOME=`/usr/libexec/java_home -v 11` Bazel build tools To install, follow these steps: $ brew install bazel $ brew upgrade bazel Vizualize your Build Add the following line to your ~/.bazelrc: query --package_path %workspace%:[PATH TO BAZEL]/base_workspace # set the path to the bazel binary Run bazel query inside your project directory, asking it to search for all dependencies of //:main (or however the label is to your target of interest): $ bazel query 'deps(//:main)' --output graph > graph.in This creates a file called graph.in , which is a text representation of the build graph. You can use dot (install with brew install graphviz ) to create a png: $ dot -Tpng < graph.in > graph.png Python3 To install, follow these steps: $ brew install python","title":"Overview"},{"location":"developers/#developer-overview","text":"","title":"Developer Overview"},{"location":"developers/#local-development-environment","text":"At the DaSCH, the principal development envionment is Apple macOS . Each developer machine should have the following prerequisites installed: Docker Desktop: https://www.docker.com/products/docker-desktop Homebrew: https://brew.sh","title":"Local Development Environment"},{"location":"developers/#java-adoptopenjdk-11","text":"To install, follow these steps: $ brew tap AdoptOpenJDK/openjdk $ brew cask install AdoptOpenJDK/openjdk/adoptopenjdk11 To pin the version of Java, please add this environment variable to you startup script (bashrc, etc.): export JAVA_HOME=`/usr/libexec/java_home -v 11`","title":"Java Adoptopenjdk 11"},{"location":"developers/#bazel-build-tools","text":"To install, follow these steps: $ brew install bazel $ brew upgrade bazel","title":"Bazel build tools"},{"location":"developers/#vizualize-your-build","text":"Add the following line to your ~/.bazelrc: query --package_path %workspace%:[PATH TO BAZEL]/base_workspace # set the path to the bazel binary Run bazel query inside your project directory, asking it to search for all dependencies of //:main (or however the label is to your target of interest): $ bazel query 'deps(//:main)' --output graph > graph.in This creates a file called graph.in , which is a text representation of the build graph. You can use dot (install with brew install graphviz ) to create a png: $ dot -Tpng < graph.in > graph.png","title":"Vizualize your Build"},{"location":"developers/#python3","text":"To install, follow these steps: $ brew install python","title":"Python3"},{"location":"developers/dsp/contribution/","text":"How to contribute to the development of the DSP The DSP software is developed under git version control using GitHub . It includes the following main repositories: In all these repositories, we follow the GitHub flow recommondations: Create a branch from main Add commits Open a pull request Discuss and review your code Merge into main branch Create Branch Guidelines You will work on an own branch to resolve one issue or user story defined on Youtrack . Each of those issues has a DSP-number which has to be used in the branch name: wip/<DSP-nr>-<subject> The prefix wip stands for \"work in progress\" followed by a \"/\" (slash). The second part starts with the DSP-number followed by a short subject which contains succinct description of the issue/user story. DSP-number and subject have to be written in kebab-case with \"-\" (hyphens). Git Commit Guidelines We follow strict rules how a commit message has to look like. This leads to more readable messages that are easy to follow when looking through the project history. Commit Message Format <type>(<scope>): <subject> Type Must be one of the following: feat New feature fix A bug fix docs Changes to the documentation style Update style; no production code change refactor Refactoring production code test All about tests: adding, refactoring tests; no production code change chore Maintenance tasks; no production code change Scope (optional) The scope could be anything specifying place of the commit change. Subject The subject contains succinct description of the change: use the imperative, present tense: \"change\" not \"changed\" nor \"changes\" don't capitalize first letter no dot (.) at the end Pull request guidelines Set title and add description A pull request resolves one issue or user story defined on Youtrack . Please reuse the DSP-number and the same title as on Youtrack: <DSP-nr> <title> When using the DSP-number in the PR, the PR will be linked on Youtrack. To link the user story to a GitHub's PR, we strongly recommend to add it also to the description in the following form: Resolves <DSP-nr> Replace the <DSP-nr> with the real number e.g. DSP-42 . With Github's Autolink Setting it will automatically generate a link to Youtrack's issue. Add a label Add at least one of the corresponding labels to your PR: breaking Breaking Changes enhancement New feature bug A bug fix styling Update style; no production code change documentation Changes to the documentation testing All about tests: adding, refactoring tests; no production code change refactor Refactoring production code chore Maintenance tasks; no production code change dependencies Update a dependency package version Make a draft Please convert the pull request to draft as long it is not ready for reviewing. As soon as the PR is ready for review, click on the corresponding button \"Ready for review\". Branch protection rules The main branch of each repo (it's usually the main branch) is protected by the following rules: Require pull request reviews before merging At least from one reviewer Require status checks to pass before merging Require branches to be up-to-date before merging Status checks e.g. tests defined in each repository's CI When the PR is merged, the branch will be deleted automatically. General GitHub actions workflows (CI) We use GitHub actions to automate some processes. Run tests With each push to GitHub, the tests of the repository are executed. Successfull tests are needed to merge code into repository's main branch (s. Branch protection rules ). Release notes After each push into the main branch \u2014 after each merge from a pull request \u2014 the release notes for the next release are updated. This release called \"Next release\" is a draft and can be used to publish the real release later. The GitHub action we use for this step is release-drafter . Release To make a real release, we have to publish the release draft , mentioned above, manually. Be sure it's up to date; you have to wait until the release-drafter were run in Github actions and wait until the tests pass on repository's main branch. Update the tag and the release title with the release version number, including the prefix v : e.g. v1.0.0 or v1.0.0-rc.0 Do not forget to check the box \"This is a pre-release\" in case of a release candidate (-rc.). With each published (pre-)release, the action workflow builds the npm package or the docker image and publishes on the corresponding platform.","title":"How to contribute"},{"location":"developers/dsp/contribution/#how-to-contribute-to-the-development-of-the-dsp","text":"The DSP software is developed under git version control using GitHub . It includes the following main repositories: In all these repositories, we follow the GitHub flow recommondations: Create a branch from main Add commits Open a pull request Discuss and review your code Merge into main branch","title":"How to contribute to the development of the DSP"},{"location":"developers/dsp/contribution/#create-branch-guidelines","text":"You will work on an own branch to resolve one issue or user story defined on Youtrack . Each of those issues has a DSP-number which has to be used in the branch name: wip/<DSP-nr>-<subject> The prefix wip stands for \"work in progress\" followed by a \"/\" (slash). The second part starts with the DSP-number followed by a short subject which contains succinct description of the issue/user story. DSP-number and subject have to be written in kebab-case with \"-\" (hyphens).","title":"Create Branch Guidelines"},{"location":"developers/dsp/contribution/#git-commit-guidelines","text":"We follow strict rules how a commit message has to look like. This leads to more readable messages that are easy to follow when looking through the project history.","title":"Git Commit Guidelines"},{"location":"developers/dsp/contribution/#commit-message-format","text":"<type>(<scope>): <subject>","title":"Commit Message Format"},{"location":"developers/dsp/contribution/#type","text":"Must be one of the following: feat New feature fix A bug fix docs Changes to the documentation style Update style; no production code change refactor Refactoring production code test All about tests: adding, refactoring tests; no production code change chore Maintenance tasks; no production code change","title":"Type"},{"location":"developers/dsp/contribution/#scope-optional","text":"The scope could be anything specifying place of the commit change.","title":"Scope (optional)"},{"location":"developers/dsp/contribution/#subject","text":"The subject contains succinct description of the change: use the imperative, present tense: \"change\" not \"changed\" nor \"changes\" don't capitalize first letter no dot (.) at the end","title":"Subject"},{"location":"developers/dsp/contribution/#pull-request-guidelines","text":"","title":"Pull request guidelines"},{"location":"developers/dsp/contribution/#set-title-and-add-description","text":"A pull request resolves one issue or user story defined on Youtrack . Please reuse the DSP-number and the same title as on Youtrack: <DSP-nr> <title> When using the DSP-number in the PR, the PR will be linked on Youtrack. To link the user story to a GitHub's PR, we strongly recommend to add it also to the description in the following form: Resolves <DSP-nr> Replace the <DSP-nr> with the real number e.g. DSP-42 . With Github's Autolink Setting it will automatically generate a link to Youtrack's issue.","title":"Set title and add description"},{"location":"developers/dsp/contribution/#add-a-label","text":"Add at least one of the corresponding labels to your PR: breaking Breaking Changes enhancement New feature bug A bug fix styling Update style; no production code change documentation Changes to the documentation testing All about tests: adding, refactoring tests; no production code change refactor Refactoring production code chore Maintenance tasks; no production code change dependencies Update a dependency package version","title":"Add a label"},{"location":"developers/dsp/contribution/#make-a-draft","text":"Please convert the pull request to draft as long it is not ready for reviewing. As soon as the PR is ready for review, click on the corresponding button \"Ready for review\".","title":"Make a draft"},{"location":"developers/dsp/contribution/#branch-protection-rules","text":"The main branch of each repo (it's usually the main branch) is protected by the following rules: Require pull request reviews before merging At least from one reviewer Require status checks to pass before merging Require branches to be up-to-date before merging Status checks e.g. tests defined in each repository's CI When the PR is merged, the branch will be deleted automatically.","title":"Branch protection rules"},{"location":"developers/dsp/contribution/#general-github-actions-workflows-ci","text":"We use GitHub actions to automate some processes.","title":"General GitHub actions workflows (CI)"},{"location":"developers/dsp/contribution/#run-tests","text":"With each push to GitHub, the tests of the repository are executed. Successfull tests are needed to merge code into repository's main branch (s. Branch protection rules ).","title":"Run tests"},{"location":"developers/dsp/contribution/#release-notes","text":"After each push into the main branch \u2014 after each merge from a pull request \u2014 the release notes for the next release are updated. This release called \"Next release\" is a draft and can be used to publish the real release later. The GitHub action we use for this step is release-drafter .","title":"Release notes"},{"location":"developers/dsp/contribution/#release","text":"To make a real release, we have to publish the release draft , mentioned above, manually. Be sure it's up to date; you have to wait until the release-drafter were run in Github actions and wait until the tests pass on repository's main branch. Update the tag and the release title with the release version number, including the prefix v : e.g. v1.0.0 or v1.0.0-rc.0 Do not forget to check the box \"This is a pre-release\" in case of a release candidate (-rc.). With each published (pre-)release, the action workflow builds the npm package or the docker image and publishes on the corresponding platform.","title":"Release"},{"location":"developers/dsp-ui/contribution/","text":"Contribute to develop DSP-UI modules Developers note Prerequisites We develop DSP-UI-LIB modules using Angular 9, with heavy reliance on Angular-cli, which requires the following tools: Node.js Angular requires a current, active LTS, or maintenance LTS version of Node.js. We recommend installing Node version 12.x . On MacOs, install node with Homebrew . For other platforms, please visit the Node.js download page . brew install node@12 Developer hint: To switch between various node versions, we recommand to use n \u2014 Node.js versions manager . To install it, run: npm install -g n and switch to the desired node version, e.g. 12.16.2 with n v12.16.2 NPM package manager We use npm instead of yarn, which is installed with Node.js by default. To check that you have the npm client installed, run npm -v . First steps Install the node packages with: npm install and build the library with: npm run build-lib Develop If you want to add more components, services and so on to a module of the library, you can do it with: ng generate component [path/in/the/module/][name-of-component] --project @dasch-swiss/dsp-ui For example: ng generate component core/test --project @dasch-swiss/dsp-ui will create a component-folder called test inside of projects/dsp-ui/src/lib/core/ with four files: test.component.scss test.component.html test.component.spec.ts test.component.ts The main component file should look as follows: import { Component, OnInit } from '@angular/core'; @Component({ selector: 'dsp-test', templateUrl: './test.component.html', styleUrls: ['./test.component.scss'] }) export class TestComponent implements OnInit { constructor() { } ngOnInit(): void { } } Before testing the new component inside of the demo app, you have to rebuild after each change: npm run build-lib Run the demo app Run the app with the command line: npm run start . The demo app runs on http://0.0.0.0:4200 . Documentation can be found on DSP-UI-LIB Github page . Run the application in productive mode To simulate a production environment, the application should be built with optimization and served locally (not in dev mode, but from a local web server). Install nginx on your system, e.g. brew install nginx for mac OS. Check the documentation for more information. Create a configuration file for the test application. The example defines a configuration file /usr/local/etc/nginx/servers/dspuiapp.conf for macOS. Substitute $abs_path_to_lib with the actual absolute path on your system pointing to the project root. Substitute $dsp-ui_folder_name with the folder name of the app build in dist . server { listen 8090; server_name dspuiapp.local; root /$abs_path_to_lib/dist/$dsp-ui_folder_name; location / { try_files $uri $uri/ /index.html; } access_log /usr/local/etc/nginx/logs/dspuiapp.local.access.log; } Add an entry to your /etc/hosts : 127.0.0.1 dspuiapp.local Create an empty file dspuiapp.local.access.log in /usr/local/etc/nginx/logs (you might have to create the folder logs first) Start nginx (if nginx is already running, stop it first: nginx : nginx -s stop ) Build the library: npm run build-lib Build the test app with optimization: npm run build-app Access it via http://dspuiapp.local:8090 DSP-UI coding rules In general, please follow the style guide of Angular \u2192 https://angular.io/guide/styleguide . Naming Component selector: Use the prefix kui for any classes (e.g. kui-sort-button) Pipe: (Shortname)Pipe Directive: (Shortname)Directive Component: (Shortname)Component Service: (Shortname)Service Shortname = explicit name with short length Annotate each methods in the file component.ts JSdoc annotation block Component Private variable must start with \u201c_\u201d + lowercase first letter (e.g. private _myVariable) Injection in the constructor must start with \u201c_\u201d + lowercase first letter (e.g. _resourceService) A method name must start with a lowercase letter, no specific character (e.g. getOneResource()) @Input(), @Output(), @ViewChild must be declared at the top of the class, before the declaration of any other variables Specific methods must be declared after lifecycle hook methods (ngOnInit, etc. > getOneResource()) Style guide The general design and the style of GUI elements are defined in the Knora-App style guide . This guideline should be followed for any new features.","title":"DSP-UI modules"},{"location":"developers/dsp-ui/contribution/#contribute-to-develop-dsp-ui-modules","text":"","title":"Contribute to develop DSP-UI modules"},{"location":"developers/dsp-ui/contribution/#developers-note","text":"","title":"Developers note"},{"location":"developers/dsp-ui/contribution/#prerequisites","text":"We develop DSP-UI-LIB modules using Angular 9, with heavy reliance on Angular-cli, which requires the following tools:","title":"Prerequisites"},{"location":"developers/dsp-ui/contribution/#nodejs","text":"Angular requires a current, active LTS, or maintenance LTS version of Node.js. We recommend installing Node version 12.x . On MacOs, install node with Homebrew . For other platforms, please visit the Node.js download page . brew install node@12 Developer hint: To switch between various node versions, we recommand to use n \u2014 Node.js versions manager . To install it, run: npm install -g n and switch to the desired node version, e.g. 12.16.2 with n v12.16.2","title":"Node.js"},{"location":"developers/dsp-ui/contribution/#npm-package-manager","text":"We use npm instead of yarn, which is installed with Node.js by default. To check that you have the npm client installed, run npm -v .","title":"NPM package manager"},{"location":"developers/dsp-ui/contribution/#first-steps","text":"Install the node packages with: npm install and build the library with: npm run build-lib","title":"First steps"},{"location":"developers/dsp-ui/contribution/#develop","text":"If you want to add more components, services and so on to a module of the library, you can do it with: ng generate component [path/in/the/module/][name-of-component] --project @dasch-swiss/dsp-ui For example: ng generate component core/test --project @dasch-swiss/dsp-ui will create a component-folder called test inside of projects/dsp-ui/src/lib/core/ with four files: test.component.scss test.component.html test.component.spec.ts test.component.ts The main component file should look as follows: import { Component, OnInit } from '@angular/core'; @Component({ selector: 'dsp-test', templateUrl: './test.component.html', styleUrls: ['./test.component.scss'] }) export class TestComponent implements OnInit { constructor() { } ngOnInit(): void { } } Before testing the new component inside of the demo app, you have to rebuild after each change: npm run build-lib","title":"Develop"},{"location":"developers/dsp-ui/contribution/#run-the-demo-app","text":"Run the app with the command line: npm run start . The demo app runs on http://0.0.0.0:4200 . Documentation can be found on DSP-UI-LIB Github page .","title":"Run the demo app"},{"location":"developers/dsp-ui/contribution/#run-the-application-in-productive-mode","text":"To simulate a production environment, the application should be built with optimization and served locally (not in dev mode, but from a local web server). Install nginx on your system, e.g. brew install nginx for mac OS. Check the documentation for more information. Create a configuration file for the test application. The example defines a configuration file /usr/local/etc/nginx/servers/dspuiapp.conf for macOS. Substitute $abs_path_to_lib with the actual absolute path on your system pointing to the project root. Substitute $dsp-ui_folder_name with the folder name of the app build in dist . server { listen 8090; server_name dspuiapp.local; root /$abs_path_to_lib/dist/$dsp-ui_folder_name; location / { try_files $uri $uri/ /index.html; } access_log /usr/local/etc/nginx/logs/dspuiapp.local.access.log; } Add an entry to your /etc/hosts : 127.0.0.1 dspuiapp.local Create an empty file dspuiapp.local.access.log in /usr/local/etc/nginx/logs (you might have to create the folder logs first) Start nginx (if nginx is already running, stop it first: nginx : nginx -s stop ) Build the library: npm run build-lib Build the test app with optimization: npm run build-app Access it via http://dspuiapp.local:8090","title":"Run the application in productive mode"},{"location":"developers/dsp-ui/contribution/#dsp-ui-coding-rules","text":"In general, please follow the style guide of Angular \u2192 https://angular.io/guide/styleguide .","title":"DSP-UI coding rules"},{"location":"developers/dsp-ui/contribution/#naming","text":"Component selector: Use the prefix kui for any classes (e.g. kui-sort-button) Pipe: (Shortname)Pipe Directive: (Shortname)Directive Component: (Shortname)Component Service: (Shortname)Service Shortname = explicit name with short length","title":"Naming"},{"location":"developers/dsp-ui/contribution/#annotate-each-methods-in-the-file-componentts","text":"JSdoc annotation block","title":"Annotate each methods in the file component.ts"},{"location":"developers/dsp-ui/contribution/#component","text":"Private variable must start with \u201c_\u201d + lowercase first letter (e.g. private _myVariable) Injection in the constructor must start with \u201c_\u201d + lowercase first letter (e.g. _resourceService) A method name must start with a lowercase letter, no specific character (e.g. getOneResource()) @Input(), @Output(), @ViewChild must be declared at the top of the class, before the declaration of any other variables Specific methods must be declared after lifecycle hook methods (ngOnInit, etc. > getOneResource())","title":"Component"},{"location":"developers/dsp-ui/contribution/#style-guide","text":"The general design and the style of GUI elements are defined in the Knora-App style guide . This guideline should be followed for any new features.","title":"Style guide"},{"location":"developers/dsp-ui/documentation/","text":"DSP-UI library User Interface library for DSP-API DSP-UI library is published on npmJS . DSP-UI contains 4 modules: core, viewer, search and action. The modules help create a GUI to allow the user to use DSP-API in a quick and simple way from within a web application. The modules are written in Typescript for use with Angular (version 9). We decided to style components and directives with Angular Material design . DSP-UI-LIB implements DSP-JS-LIB to connect with DSP-API . DSP-API is a software framework for storing, sharing, and working with primary sources and data in the humanities. DSP-UI requires DSP-API version ^12.0.0 Library modules DspActionModule Special pipes and buttons DspActionModule contains special pipes to sort lists or to get the index key in arrays, but also directives and components for images, sort buttons and s.o. DspCoreModule Services for API requests DspCoreModule is a configuration handler for @knora/api which offers all the services to make DSP-API requests . DspSearchModule Full search panel DspSearchModule allows to make full text or extended searches in DSP-API. Filter by resource class and its properties related to an ontology. DspViewerModule Resources, Properties, Lists, Value components DspViewerModule contains object components to show a resource class representation, the property gui-elements and various view frameworks. Installation npm install @dasch-swiss/dsp-ui Dependencies The module has the following package dependencies, which you also have to install. @knora/api jdnconvertiblecalendar@0.0.5 jdnconvertiblecalendardateadapter@0.0.13 ngx-color-picker@9.1.0 Setup The module supports runtime config to load the API configuration on load as opposed to on build. This helps run an App as a docker image in various environments. However, this requires some modifications in your app. We suggest building the app with @angular/cli . First, let's make a config.dev.json file in an additional folder src/config/ : { \"apiProtocol\": \"http\", \"apiHost\": \"0.0.0.0\", \"apiPort\": 3333, \"apiPath\": \"\", \"jsonWebToken\": \"\", \"logErrors\": true } It's possible to create several config files e.g. one for productive use. In this case, logErrors should be set to false and the filename would be config.prod.json . In the environment files, we have to add the corresponding name: export const environment = { name: 'dev', // <-- add the name 'dev', 'prod', etc. here. production: false }; The config files have to be integrated in angular.json in all \"assets\"-sections: \"assets\": [ \"src/favicon.ico\", \"src/assets\", \"src/config\" <-- add this line and do not forget the comma on the previous line ] Then we can make a service that will fetch the configs: ng generate service app-init import { Injectable } from '@angular/core'; import { KnoraApiConfig, KnoraApiConnection } from '@knora/api'; @Injectable({ providedIn: 'root' }) export class AppInitService { static dspApiConnection: KnoraApiConnection; static dspApiConfig: KnoraApiConfig; constructor() { } Init() { return new Promise<void>((resolve) => { // get api config information from temp storage const dspApiConfig: KnoraApiConfig = window['tempConfigStorage'] as KnoraApiConfig; // init dsp-api configuration AppInitService.dspApiConfig = new KnoraApiConfig( dspApiConfig.apiProtocol, dspApiConfig.apiHost, dspApiConfig.apiPort, dspApiConfig.apiPath, dspApiConfig.jsonWebToken, dspApiConfig.logErrors ); // set knora-api connection configuration AppInitService.dspApiConnection = new KnoraApiConnection(AppInitService.dspApiConfig); resolve(); }); } } Once we have this service, we have to edit the app.module.ts with a function to load the config: export function initializeApp(appInitService: AppInitService) { return (): Promise<any> => { return appInitService.Init(); }; } Provide it in the main module and include the desired DSP-UI modules in the imports: import { DspApiConfigToken, DspApiConnectionToken, DspCoreModule, DspViewerModule } from '@dasch-swiss/dsp-ui'; ... @NgModule({ declarations: [ AppComponent, ProjectsComponent ], imports: [ BrowserModule, AppRoutingModule, DspCoreModule, // <-- add the dsp-ui modules here DspViewerModule ], providers: [ // add the following code block AppInitService, { provide: APP_INITIALIZER, useFactory: initializeApp, deps: [AppInitService], multi: true }, { provide: DspApiConfigToken, useFactory: () => AppInitService.dspApiConfig }, { provide: DspApiConnectionToken, useFactory: () => AppInitService.dspApiConnection } ], bootstrap: [AppComponent] }) export class AppModule { } Do not forget to import APP_INITIALIZER from @angular/core and the desired DSP-UI modules from @dasch-swiss/dsp-ui . Finally, the main.ts file must be modified to load the environment specific config file and test that the config is correct: import { enableProdMode } from '@angular/core'; import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; import { AppModule } from './app/app.module'; import { environment } from './environments/environment'; if (environment.production) { enableProdMode(); } function bootstrapFailed(result) { console.error('bootstrap-fail! Config is missing or api parameters are not defined', result); } fetch(`config/config.${environment.name}.json`) .then(response => response.json()) .then(config => { if (!config) { bootstrapFailed(config); return; } // store the response somewhere that the AppInitService can read it. window['tempConfigStorage'] = config; platformBrowserDynamic() .bootstrapModule(AppModule) .catch(err => bootstrapFailed(err)); }) .catch(bootstrapFailed); Usage Add the desired modules from DSP-UI to the app.module.ts . DspCoreModule must be imported at the very minimum! @NgModule({ declarations: [ AppComponent, ProjectsComponent ], imports: [ BrowserModule, AppRoutingModule, DspCoreModule // <-- add the dsp-ui core module here ], providers: [ ... ] // <-- add providers as mentioned in section above bootstrap: [AppComponent] }) export class AppModule { } For more usage examples, check the corresponding DSP-UI module documentation. Contribute to develop DSP-UI modules If you want to contribute to develop DSP-UI modules with us, please consult the contribution guideline . DSP-API and DSP-UI-LIB are free software , released under GNU Affero General Public license. It is developed by the design team of the Data and Service Center for the Humanities DaSCH at the University of Basel .","title":"Introduction"},{"location":"developers/dsp-ui/documentation/#dsp-ui-library","text":"","title":"DSP-UI library"},{"location":"developers/dsp-ui/documentation/#user-interface-library-for-dsp-api","text":"DSP-UI library is published on npmJS . DSP-UI contains 4 modules: core, viewer, search and action. The modules help create a GUI to allow the user to use DSP-API in a quick and simple way from within a web application. The modules are written in Typescript for use with Angular (version 9). We decided to style components and directives with Angular Material design . DSP-UI-LIB implements DSP-JS-LIB to connect with DSP-API . DSP-API is a software framework for storing, sharing, and working with primary sources and data in the humanities. DSP-UI requires DSP-API version ^12.0.0","title":"User Interface library for DSP-API"},{"location":"developers/dsp-ui/documentation/#library-modules","text":"","title":"Library modules"},{"location":"developers/dsp-ui/documentation/#dspactionmodule","text":"Special pipes and buttons DspActionModule contains special pipes to sort lists or to get the index key in arrays, but also directives and components for images, sort buttons and s.o.","title":"DspActionModule"},{"location":"developers/dsp-ui/documentation/#dspcoremodule","text":"Services for API requests DspCoreModule is a configuration handler for @knora/api which offers all the services to make DSP-API requests .","title":"DspCoreModule"},{"location":"developers/dsp-ui/documentation/#dspsearchmodule","text":"Full search panel DspSearchModule allows to make full text or extended searches in DSP-API. Filter by resource class and its properties related to an ontology.","title":"DspSearchModule"},{"location":"developers/dsp-ui/documentation/#dspviewermodule","text":"Resources, Properties, Lists, Value components DspViewerModule contains object components to show a resource class representation, the property gui-elements and various view frameworks.","title":"DspViewerModule"},{"location":"developers/dsp-ui/documentation/#installation","text":"npm install @dasch-swiss/dsp-ui","title":"Installation"},{"location":"developers/dsp-ui/documentation/#dependencies","text":"The module has the following package dependencies, which you also have to install. @knora/api jdnconvertiblecalendar@0.0.5 jdnconvertiblecalendardateadapter@0.0.13 ngx-color-picker@9.1.0","title":"Dependencies"},{"location":"developers/dsp-ui/documentation/#setup","text":"The module supports runtime config to load the API configuration on load as opposed to on build. This helps run an App as a docker image in various environments. However, this requires some modifications in your app. We suggest building the app with @angular/cli . First, let's make a config.dev.json file in an additional folder src/config/ : { \"apiProtocol\": \"http\", \"apiHost\": \"0.0.0.0\", \"apiPort\": 3333, \"apiPath\": \"\", \"jsonWebToken\": \"\", \"logErrors\": true } It's possible to create several config files e.g. one for productive use. In this case, logErrors should be set to false and the filename would be config.prod.json . In the environment files, we have to add the corresponding name: export const environment = { name: 'dev', // <-- add the name 'dev', 'prod', etc. here. production: false }; The config files have to be integrated in angular.json in all \"assets\"-sections: \"assets\": [ \"src/favicon.ico\", \"src/assets\", \"src/config\" <-- add this line and do not forget the comma on the previous line ] Then we can make a service that will fetch the configs: ng generate service app-init import { Injectable } from '@angular/core'; import { KnoraApiConfig, KnoraApiConnection } from '@knora/api'; @Injectable({ providedIn: 'root' }) export class AppInitService { static dspApiConnection: KnoraApiConnection; static dspApiConfig: KnoraApiConfig; constructor() { } Init() { return new Promise<void>((resolve) => { // get api config information from temp storage const dspApiConfig: KnoraApiConfig = window['tempConfigStorage'] as KnoraApiConfig; // init dsp-api configuration AppInitService.dspApiConfig = new KnoraApiConfig( dspApiConfig.apiProtocol, dspApiConfig.apiHost, dspApiConfig.apiPort, dspApiConfig.apiPath, dspApiConfig.jsonWebToken, dspApiConfig.logErrors ); // set knora-api connection configuration AppInitService.dspApiConnection = new KnoraApiConnection(AppInitService.dspApiConfig); resolve(); }); } } Once we have this service, we have to edit the app.module.ts with a function to load the config: export function initializeApp(appInitService: AppInitService) { return (): Promise<any> => { return appInitService.Init(); }; } Provide it in the main module and include the desired DSP-UI modules in the imports: import { DspApiConfigToken, DspApiConnectionToken, DspCoreModule, DspViewerModule } from '@dasch-swiss/dsp-ui'; ... @NgModule({ declarations: [ AppComponent, ProjectsComponent ], imports: [ BrowserModule, AppRoutingModule, DspCoreModule, // <-- add the dsp-ui modules here DspViewerModule ], providers: [ // add the following code block AppInitService, { provide: APP_INITIALIZER, useFactory: initializeApp, deps: [AppInitService], multi: true }, { provide: DspApiConfigToken, useFactory: () => AppInitService.dspApiConfig }, { provide: DspApiConnectionToken, useFactory: () => AppInitService.dspApiConnection } ], bootstrap: [AppComponent] }) export class AppModule { } Do not forget to import APP_INITIALIZER from @angular/core and the desired DSP-UI modules from @dasch-swiss/dsp-ui . Finally, the main.ts file must be modified to load the environment specific config file and test that the config is correct: import { enableProdMode } from '@angular/core'; import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; import { AppModule } from './app/app.module'; import { environment } from './environments/environment'; if (environment.production) { enableProdMode(); } function bootstrapFailed(result) { console.error('bootstrap-fail! Config is missing or api parameters are not defined', result); } fetch(`config/config.${environment.name}.json`) .then(response => response.json()) .then(config => { if (!config) { bootstrapFailed(config); return; } // store the response somewhere that the AppInitService can read it. window['tempConfigStorage'] = config; platformBrowserDynamic() .bootstrapModule(AppModule) .catch(err => bootstrapFailed(err)); }) .catch(bootstrapFailed);","title":"Setup"},{"location":"developers/dsp-ui/documentation/#usage","text":"Add the desired modules from DSP-UI to the app.module.ts . DspCoreModule must be imported at the very minimum! @NgModule({ declarations: [ AppComponent, ProjectsComponent ], imports: [ BrowserModule, AppRoutingModule, DspCoreModule // <-- add the dsp-ui core module here ], providers: [ ... ] // <-- add providers as mentioned in section above bootstrap: [AppComponent] }) export class AppModule { } For more usage examples, check the corresponding DSP-UI module documentation.","title":"Usage"},{"location":"developers/dsp-ui/documentation/#contribute-to-develop-dsp-ui-modules","text":"If you want to contribute to develop DSP-UI modules with us, please consult the contribution guideline . DSP-API and DSP-UI-LIB are free software , released under GNU Affero General Public license. It is developed by the design team of the Data and Service Center for the Humanities DaSCH at the University of Basel .","title":"Contribute to develop DSP-UI modules"},{"location":"developers/dsp-ui/documentation/action/admin-image/","text":"AdminImage (Directive) You can use the admin image module for user avatar together with gravatar.com and for project logos. The feature of this module ist the error handling: In case of a 404 error of the image source (img src) the module shows a default image-not-found image. Or a default user profile icon (type=user), or a default project icon (type=project). Parameters Name Type Description image string source of the image: - in case of user (gr)avatar it's the e-mail address, - in case of project logo it's the image url type string type of image; you can use it with: - project - user Examples User Avatar HTML file // Default user profile image <img kuiAdminImage [image]=\"imgDefaultUser\" [type]=\"'user'\" /> // Avatar example: 'salsah' user <img kuiAdminImage [image]=\"imgSalsahUser\" [type]=\"'user'\" /> // User image on error <img kuiAdminImage [image]=\"null\" [type]=\"'user'\" /> // Default error image <img kuiAdminImage [image]=\"'null'\" /> Typescript file imgDefaultUser: string = 'root@example.com'; imgSalsahUser: string = 'salsah@dasch.ch'; ### Project Logo **HTML file** // Default project image <img kuiAdminImage [image]=\"imgDefaultProject\" [type]=\"'project'\" /> // Logo example: 'dasch' project <img kuiAdminImage [image]=\"imgDaschProject\" [type]=\"'project'\" /> **Typescript file** imgDefaultProject: string = undefined; imgDaschProject: string = 'http://dasch.swiss/content/images/2017/11/DaSCH_Logo_RGB.png'; ![Default project logos](../../../../assets/images/dsp-ui/admin-image2.png)","title":"AdminImage"},{"location":"developers/dsp-ui/documentation/action/admin-image/#adminimage-directive","text":"You can use the admin image module for user avatar together with gravatar.com and for project logos. The feature of this module ist the error handling: In case of a 404 error of the image source (img src) the module shows a default image-not-found image. Or a default user profile icon (type=user), or a default project icon (type=project).","title":"AdminImage (Directive)"},{"location":"developers/dsp-ui/documentation/action/admin-image/#parameters","text":"Name Type Description image string source of the image: - in case of user (gr)avatar it's the e-mail address, - in case of project logo it's the image url type string type of image; you can use it with: - project - user","title":"Parameters"},{"location":"developers/dsp-ui/documentation/action/admin-image/#examples","text":"","title":"Examples"},{"location":"developers/dsp-ui/documentation/action/admin-image/#user-avatar","text":"HTML file // Default user profile image <img kuiAdminImage [image]=\"imgDefaultUser\" [type]=\"'user'\" /> // Avatar example: 'salsah' user <img kuiAdminImage [image]=\"imgSalsahUser\" [type]=\"'user'\" /> // User image on error <img kuiAdminImage [image]=\"null\" [type]=\"'user'\" /> // Default error image <img kuiAdminImage [image]=\"'null'\" /> Typescript file imgDefaultUser: string = 'root@example.com'; imgSalsahUser: string = 'salsah@dasch.ch'; ### Project Logo **HTML file** // Default project image <img kuiAdminImage [image]=\"imgDefaultProject\" [type]=\"'project'\" /> // Logo example: 'dasch' project <img kuiAdminImage [image]=\"imgDaschProject\" [type]=\"'project'\" /> **Typescript file** imgDefaultProject: string = undefined; imgDaschProject: string = 'http://dasch.swiss/content/images/2017/11/DaSCH_Logo_RGB.png'; ![Default project logos](../../../../assets/images/dsp-ui/admin-image2.png)","title":"User Avatar"},{"location":"developers/dsp-ui/documentation/action/existing-name/","text":"ExistingName (Directive) With the ExistingNameDirective, we could prevent to use a name which has to be unique but already exists e.g. get a list of all project shortnames, then we can use this list as existing names; you can also use it for a list of blacklisted (not allowed) words. Methods existingNameValidator() Validation of existing name value. String method (only one value); Use it in a \"formbuilder\" group as a validator property. Parameters Name Type Description valRegexp RegExp Only one regular expression value Returns ValidatorFn existingNamesValidator() Validation of existing name values. Array method (list of values) Use it in a \"formbuilder\" group as a validator property. Parameters Name Type Description valArrayRegexp RegExp List of regular expression values Returns ValidatorFn Examples Existing Name Validator The following names already exists Try to use one of them in the form above and see what happens Max Peter Paul John HTML file <form [formGroup]=\"form\" class=\"center card\"> <mat-form-field> <input matInput [formControl]=\"form.controls['name']\" [placeholder]=\"'Name (should be unique)'\"> <mat-hint *ngIf=\"formErrors.name\"> {{formErrors.name}} </mat-hint> </mat-form-field> <button mat-button color=\"primary\" [disabled]=\"!form.valid\"> Submit </button> </form> Typescript file dataMock: string[] = [ 'Max', 'Peter', 'Paul', 'John' ]; // list of existing names existingNames: [RegExp] = [ new RegExp('user') ]; // define your form group form: FormGroup; // error handling on the defined fields e.g. name formErrors = { 'name': '' }; // error message on the defined fields in formErrors validationMessages = { 'name': { 'required': 'A name is required', 'existingName': 'This name exists already.' } }; constructor(private _formBuilder: FormBuilder) { } ngOnInit() { // create a list of names, which already exists for (const user of this.dataMock) { this.existingNames.push( new RegExp('(?:^|\\W)' + user.toLowerCase() + '(?:$|\\W)') ); } // build form this.form = this._formBuilder.group({ 'name': new FormControl({ value: '', disabled: false }, [ Validators.required, existingNamesValidator(this.existingNames) ]) }); // detect changes in the form this.form.valueChanges.subscribe( data => this.onValueChanged(data) ); this.onValueChanged(); } onValueChanged(data?: any) { if (!this.form) { return; } // check if the form is valid Object.keys(this.formErrors).map(field => { this.formErrors[field] = ''; const control = this.form.get(field); if (control && control.dirty && !control.valid) { const messages = this.validationMessages[field]; Object.keys(control.errors).map(key => { this.formErrors[field] += messages[key] + ' '; }); } }); }","title":"ExistingName"},{"location":"developers/dsp-ui/documentation/action/existing-name/#existingname-directive","text":"With the ExistingNameDirective, we could prevent to use a name which has to be unique but already exists e.g. get a list of all project shortnames, then we can use this list as existing names; you can also use it for a list of blacklisted (not allowed) words.","title":"ExistingName (Directive)"},{"location":"developers/dsp-ui/documentation/action/existing-name/#methods","text":"","title":"Methods"},{"location":"developers/dsp-ui/documentation/action/existing-name/#existingnamevalidator","text":"Validation of existing name value. String method (only one value); Use it in a \"formbuilder\" group as a validator property. Parameters Name Type Description valRegexp RegExp Only one regular expression value Returns ValidatorFn","title":"existingNameValidator()"},{"location":"developers/dsp-ui/documentation/action/existing-name/#existingnamesvalidator","text":"Validation of existing name values. Array method (list of values) Use it in a \"formbuilder\" group as a validator property. Parameters Name Type Description valArrayRegexp RegExp List of regular expression values Returns ValidatorFn","title":"existingNamesValidator()"},{"location":"developers/dsp-ui/documentation/action/existing-name/#examples","text":"","title":"Examples"},{"location":"developers/dsp-ui/documentation/action/existing-name/#existing-name-validator","text":"The following names already exists Try to use one of them in the form above and see what happens Max Peter Paul John HTML file <form [formGroup]=\"form\" class=\"center card\"> <mat-form-field> <input matInput [formControl]=\"form.controls['name']\" [placeholder]=\"'Name (should be unique)'\"> <mat-hint *ngIf=\"formErrors.name\"> {{formErrors.name}} </mat-hint> </mat-form-field> <button mat-button color=\"primary\" [disabled]=\"!form.valid\"> Submit </button> </form> Typescript file dataMock: string[] = [ 'Max', 'Peter', 'Paul', 'John' ]; // list of existing names existingNames: [RegExp] = [ new RegExp('user') ]; // define your form group form: FormGroup; // error handling on the defined fields e.g. name formErrors = { 'name': '' }; // error message on the defined fields in formErrors validationMessages = { 'name': { 'required': 'A name is required', 'existingName': 'This name exists already.' } }; constructor(private _formBuilder: FormBuilder) { } ngOnInit() { // create a list of names, which already exists for (const user of this.dataMock) { this.existingNames.push( new RegExp('(?:^|\\W)' + user.toLowerCase() + '(?:$|\\W)') ); } // build form this.form = this._formBuilder.group({ 'name': new FormControl({ value: '', disabled: false }, [ Validators.required, existingNamesValidator(this.existingNames) ]) }); // detect changes in the form this.form.valueChanges.subscribe( data => this.onValueChanged(data) ); this.onValueChanged(); } onValueChanged(data?: any) { if (!this.form) { return; } // check if the form is valid Object.keys(this.formErrors).map(field => { this.formErrors[field] = ''; const control = this.form.get(field); if (control && control.dirty && !control.valid) { const messages = this.validationMessages[field]; Object.keys(control.errors).map(key => { this.formErrors[field] += messages[key] + ' '; }); } }); }","title":"Existing Name Validator"},{"location":"developers/dsp-ui/documentation/action/index-action/","text":"DSP-UI ACTION module DspActionModule is like a tool box containing special pipes to sort lists or to get the index key in arrays, directives for images and sorting names, but also components to display progress indicator bars or customized dialog boxes for resources, etc... Prerequisites For help getting started with a new Angular app, check the Angular CLI documentation. For existing apps, follow these steps to begin using DSP-UI ACTION. Installation DspActionModule is part of @dasch-swiss/dsp-ui, follow the installation guide . Setup Import the action module in your app.module.ts and add it to the NgModules's imports: import { AppComponent } from './app.component'; import { DspCoreModule, DspActionModule } from '@dasch-swiss/dsp-ui'; @NgModule({ declarations: [ AppComponent ], imports: [ DspCoreModule, // <- core module is required for some components and directives DspActionModule // <- add action module in the imports ], providers: [ ... ] // <-- add providers if you use the core module as mentioned in the installation guide bootstrap: [AppComponent] }) export class AppModule { } Some components need a global styling in the app to override some material styling rules. Please update your angular.json file as follow: ... \"styles\": [ \"src/styles.scss\", \"node_modules/@dasch-swiss/dsp-ui/action/assets/style/action.scss\" // <- add this line ], ... Components, Directives and Pipes This module contains various components like a progress indicator, sort button and sort-by pipe, but also helper for images (in the admin interface) and existing names.","title":"Readme"},{"location":"developers/dsp-ui/documentation/action/index-action/#dsp-ui-action-module","text":"DspActionModule is like a tool box containing special pipes to sort lists or to get the index key in arrays, directives for images and sorting names, but also components to display progress indicator bars or customized dialog boxes for resources, etc...","title":"DSP-UI ACTION module"},{"location":"developers/dsp-ui/documentation/action/index-action/#prerequisites","text":"For help getting started with a new Angular app, check the Angular CLI documentation. For existing apps, follow these steps to begin using DSP-UI ACTION.","title":"Prerequisites"},{"location":"developers/dsp-ui/documentation/action/index-action/#installation","text":"DspActionModule is part of @dasch-swiss/dsp-ui, follow the installation guide .","title":"Installation"},{"location":"developers/dsp-ui/documentation/action/index-action/#setup","text":"Import the action module in your app.module.ts and add it to the NgModules's imports: import { AppComponent } from './app.component'; import { DspCoreModule, DspActionModule } from '@dasch-swiss/dsp-ui'; @NgModule({ declarations: [ AppComponent ], imports: [ DspCoreModule, // <- core module is required for some components and directives DspActionModule // <- add action module in the imports ], providers: [ ... ] // <-- add providers if you use the core module as mentioned in the installation guide bootstrap: [AppComponent] }) export class AppModule { } Some components need a global styling in the app to override some material styling rules. Please update your angular.json file as follow: ... \"styles\": [ \"src/styles.scss\", \"node_modules/@dasch-swiss/dsp-ui/action/assets/style/action.scss\" // <- add this line ], ...","title":"Setup"},{"location":"developers/dsp-ui/documentation/action/index-action/#components-directives-and-pipes","text":"This module contains various components like a progress indicator, sort button and sort-by pipe, but also helper for images (in the admin interface) and existing names.","title":"Components, Directives and Pipes"},{"location":"developers/dsp-ui/documentation/action/key/","text":"Key (Pipe) This pipe can be used for \"for loops\", in the case of an array with non-numeric indexes. It returns the key and the value(s). In the example below the {{item.key}} contains the index value and the {{item.value}} contains the value(s). When the value is an object with name and label, you get them with {{item.value.name}} and {{item.value.label}} . Examples HTML file <ul> <li *ngFor=\"let item of array | kuiKey\"> {{item.key}}: {{item.value}} </li> </ul> Typescript file array = []; this.array['index-1'] = 'Value in index 1'; this.array['index-2'] = 'Value in index 2'; this.array['index-3'] = 'Value in index 3';","title":"Key"},{"location":"developers/dsp-ui/documentation/action/key/#key-pipe","text":"This pipe can be used for \"for loops\", in the case of an array with non-numeric indexes. It returns the key and the value(s). In the example below the {{item.key}} contains the index value and the {{item.value}} contains the value(s). When the value is an object with name and label, you get them with {{item.value.name}} and {{item.value.label}} .","title":"Key (Pipe)"},{"location":"developers/dsp-ui/documentation/action/key/#examples","text":"","title":"Examples"},{"location":"developers/dsp-ui/documentation/action/key/#html-file","text":"<ul> <li *ngFor=\"let item of array | kuiKey\"> {{item.key}}: {{item.value}} </li> </ul>","title":"HTML file"},{"location":"developers/dsp-ui/documentation/action/key/#typescript-file","text":"array = []; this.array['index-1'] = 'Value in index 1'; this.array['index-2'] = 'Value in index 2'; this.array['index-3'] = 'Value in index 3';","title":"Typescript file"},{"location":"developers/dsp-ui/documentation/action/message/","text":"Message (Component) Message component to handle notes, warning and error messages. If you set the paramater [short]=\"true\" , it shows a smaller message. It can be used to give feedbacks in a form e.g. update process: show success or error message. Parameters Message type: KuiMessageData or ApiServiceError Name Type Description message KuiMessageData, ApiServiceError This type needs at least a status number (0-511). In this case, or if type is ApiServiceError, it takes the default status messages from the list of HTTP status codes (https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) **Show short message only: it can be used in form to show if a post was successfull or not.** Name | Type | Description --- | --- | --- short (optional) | boolean | **Show medium message: a message box without footnote and withou links.** Name | Type | Description --- | --- | --- medium (optional) | boolean | ## Examples ### Success and error message, short version (= small size) #### HTML file <kui-message [message]=\"shortMessage\" [short]=\"true\"></kui-message> <kui-message [message]=\"errorMessage\" [short]=\"true\"></kui-message> #### Typescript file // short message example shortMessage: KuiMessageData = { status: 200, statusMsg: 'Success', statusText: 'You just update the user profile.', type: 'Note', footnote: 'Close it' }; // error message example errorMessage: ApiServiceError = { status: 403, errorInfo: 'Http failure response for http://0.0.0.0:3333/admin/projects/shortcode/001/members: 400 Bad Request', statusText: 'Bad Request', url: 'http://0.0.0.0:3333/admin/projects/shortcode/001/members' }; ![Message in short version](../../../../assets/images/dsp-ui/message-short.png) ### Error message, default size #### HTML file <kui-message [message]=\"errorMessage\"></kui-message> #### Typescript file // error message example errorMessage: ApiServiceError = { status: 403, errorInfo: 'Http failure response for http://0.0.0.0:3333/admin/projects/shortcode/001/members: 400 Bad Request', statusText: 'Bad Request', url: 'http://0.0.0.0:3333/admin/projects/shortcode/001/members' }; ![Error message in default size version](../../../../assets/images/dsp-ui/message-error.png)","title":"Message"},{"location":"developers/dsp-ui/documentation/action/message/#message-component","text":"Message component to handle notes, warning and error messages. If you set the paramater [short]=\"true\" , it shows a smaller message. It can be used to give feedbacks in a form e.g. update process: show success or error message.","title":"Message (Component)"},{"location":"developers/dsp-ui/documentation/action/message/#parameters","text":"","title":"Parameters"},{"location":"developers/dsp-ui/documentation/action/message/#message-type-kuimessagedata-or-apiserviceerror","text":"Name Type Description message KuiMessageData, ApiServiceError This type needs at least a status number (0-511). In this case, or if type is ApiServiceError, it takes the default status messages from the list of HTTP status codes (https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) **Show short message only: it can be used in form to show if a post was successfull or not.** Name | Type | Description --- | --- | --- short (optional) | boolean | **Show medium message: a message box without footnote and withou links.** Name | Type | Description --- | --- | --- medium (optional) | boolean | ## Examples ### Success and error message, short version (= small size) #### HTML file <kui-message [message]=\"shortMessage\" [short]=\"true\"></kui-message> <kui-message [message]=\"errorMessage\" [short]=\"true\"></kui-message> #### Typescript file // short message example shortMessage: KuiMessageData = { status: 200, statusMsg: 'Success', statusText: 'You just update the user profile.', type: 'Note', footnote: 'Close it' }; // error message example errorMessage: ApiServiceError = { status: 403, errorInfo: 'Http failure response for http://0.0.0.0:3333/admin/projects/shortcode/001/members: 400 Bad Request', statusText: 'Bad Request', url: 'http://0.0.0.0:3333/admin/projects/shortcode/001/members' }; ![Message in short version](../../../../assets/images/dsp-ui/message-short.png) ### Error message, default size #### HTML file <kui-message [message]=\"errorMessage\"></kui-message> #### Typescript file // error message example errorMessage: ApiServiceError = { status: 403, errorInfo: 'Http failure response for http://0.0.0.0:3333/admin/projects/shortcode/001/members: 400 Bad Request', statusText: 'Bad Request', url: 'http://0.0.0.0:3333/admin/projects/shortcode/001/members' }; ![Error message in default size version](../../../../assets/images/dsp-ui/message-error.png)","title":"Message type: KuiMessageData or ApiServiceError"},{"location":"developers/dsp-ui/documentation/action/progress-indicator/","text":"Progress Indicator (Component) The progress indicator can be used to show the status of loading something. This can be the simple loader or in case of submitting data it can show the status (not ready, loading, done or error). Parameters Name Type Description status (optional) number [status] is a number and can be used when submitting form data: - not ready: -1 - loading: 0 - done: 1 - error: 400 color=primary (optional) string Parameter to customize the appearance of the loader. Hexadecimal color value e.g. #00ff00 or similar color values 'red', 'green' etc. Examples You can use the progress indicator in two ways: Classic Loader HTML file <kui-progress-indicator></kui-progress-indicator> ### Submit-form-data loader e.g. as a list style type while submitting form data ![Submit form data loader](../../../../assets/images/dsp-ui/submit-form-data-loader.png) Angular Material Icons is required. You have to import the style file into your app and add the following line in your main styling file: `@import url('https://fonts.googleapis.com/icon?family=Material+Icons');` We recommend to host the Material Icons font in your app e.g. by using the [Material Icons package](https://www.npmjs.com/package/material-icons). ### Dynamic example of Submit-form-data loader ![Loader before submit stage](../../../../assets/images/dsp-ui/loader-before-submit-status.png) ![Loader submitting stage](../../../../assets/images/dsp-ui/loader-submitting-status.png) ![Loader after submit stage](../../../../assets/images/dsp-ui/loader-after-submit-status.png)","title":"Progress indicator"},{"location":"developers/dsp-ui/documentation/action/progress-indicator/#progress-indicator-component","text":"The progress indicator can be used to show the status of loading something. This can be the simple loader or in case of submitting data it can show the status (not ready, loading, done or error).","title":"Progress Indicator (Component)"},{"location":"developers/dsp-ui/documentation/action/progress-indicator/#parameters","text":"Name Type Description status (optional) number [status] is a number and can be used when submitting form data: - not ready: -1 - loading: 0 - done: 1 - error: 400 color=primary (optional) string Parameter to customize the appearance of the loader. Hexadecimal color value e.g. #00ff00 or similar color values 'red', 'green' etc.","title":"Parameters"},{"location":"developers/dsp-ui/documentation/action/progress-indicator/#examples","text":"You can use the progress indicator in two ways:","title":"Examples"},{"location":"developers/dsp-ui/documentation/action/progress-indicator/#classic-loader","text":"","title":"Classic Loader"},{"location":"developers/dsp-ui/documentation/action/progress-indicator/#html-file","text":"<kui-progress-indicator></kui-progress-indicator> ### Submit-form-data loader e.g. as a list style type while submitting form data ![Submit form data loader](../../../../assets/images/dsp-ui/submit-form-data-loader.png) Angular Material Icons is required. You have to import the style file into your app and add the following line in your main styling file: `@import url('https://fonts.googleapis.com/icon?family=Material+Icons');` We recommend to host the Material Icons font in your app e.g. by using the [Material Icons package](https://www.npmjs.com/package/material-icons). ### Dynamic example of Submit-form-data loader ![Loader before submit stage](../../../../assets/images/dsp-ui/loader-before-submit-status.png) ![Loader submitting stage](../../../../assets/images/dsp-ui/loader-submitting-status.png) ![Loader after submit stage](../../../../assets/images/dsp-ui/loader-after-submit-status.png)","title":"HTML file"},{"location":"developers/dsp-ui/documentation/action/sort-button/","text":"SortButton (Component) A component with a list of properties to sort a list by one of them. It can be used together with the KuiSortBy pipe. Parameters {string} sortKeyChange EventEmitter when a user selected a sort property; This is the selected key. Name Type Description sortProps Array An array of SortProp objects for the selection menu: SortProp: { key: string, label: string } position='left' (optional) string Optional position of the sort menu: right or left icon='sort' (optional) string Default icon is \"sort\" from material design. But you can replace it with another one e.g. sort_by_alpha sortKey string Set and get (two-way data binding) of current sort key Example - Simple Example HTML file <kui-sort-button [sortProps]=\"sortProps\" [(sortKey)]=\"sortKey\" [position]=\"'right'\"></kui-sort-button> <ul> <li *ngFor=\"let item of list | kuiSortBy: sortKey\"> <span [class.active]=\"sortKey === 'prename'\">{{item.prename}} </span> <span [class.active]=\"sortKey === 'lastname'\">{{item.lastname}} </span> by <span [class.active]=\"sortKey === 'creator'\">{{item.creator}}</span> </li> </ul> Typescript file sortProps: any = [ { key: 'prename', label: 'Prename' }, { key: 'lastname', label: 'Last name' }, { key: 'creator', label: 'Creator' } ]; sortKey: string = 'creator'; list = [ { prename: 'Gaston', lastname: 'Lagaffe', creator: 'Andr\u00e9 Franquin' }, { prename: 'Mickey', lastname: 'Mouse', creator: 'Walt Disney' }, { prename: 'Donald', lastname: 'Duck', creator: 'Walt Disney' }, { prename: 'Charlie', lastname: 'Brown', creator: 'Charles M. Schulz' } ]; Optional It's possible to set the position of the sort button to the right or left side with the property [position] .","title":"SortButton"},{"location":"developers/dsp-ui/documentation/action/sort-button/#sortbutton-component","text":"A component with a list of properties to sort a list by one of them. It can be used together with the KuiSortBy pipe.","title":"SortButton (Component)"},{"location":"developers/dsp-ui/documentation/action/sort-button/#parameters","text":"{string} sortKeyChange EventEmitter when a user selected a sort property; This is the selected key. Name Type Description sortProps Array An array of SortProp objects for the selection menu: SortProp: { key: string, label: string } position='left' (optional) string Optional position of the sort menu: right or left icon='sort' (optional) string Default icon is \"sort\" from material design. But you can replace it with another one e.g. sort_by_alpha sortKey string Set and get (two-way data binding) of current sort key","title":"Parameters"},{"location":"developers/dsp-ui/documentation/action/sort-button/#example-simple-example","text":"","title":"Example - Simple Example"},{"location":"developers/dsp-ui/documentation/action/sort-button/#html-file","text":"<kui-sort-button [sortProps]=\"sortProps\" [(sortKey)]=\"sortKey\" [position]=\"'right'\"></kui-sort-button> <ul> <li *ngFor=\"let item of list | kuiSortBy: sortKey\"> <span [class.active]=\"sortKey === 'prename'\">{{item.prename}} </span> <span [class.active]=\"sortKey === 'lastname'\">{{item.lastname}} </span> by <span [class.active]=\"sortKey === 'creator'\">{{item.creator}}</span> </li> </ul>","title":"HTML file"},{"location":"developers/dsp-ui/documentation/action/sort-button/#typescript-file","text":"sortProps: any = [ { key: 'prename', label: 'Prename' }, { key: 'lastname', label: 'Last name' }, { key: 'creator', label: 'Creator' } ]; sortKey: string = 'creator'; list = [ { prename: 'Gaston', lastname: 'Lagaffe', creator: 'Andr\u00e9 Franquin' }, { prename: 'Mickey', lastname: 'Mouse', creator: 'Walt Disney' }, { prename: 'Donald', lastname: 'Duck', creator: 'Walt Disney' }, { prename: 'Charlie', lastname: 'Brown', creator: 'Charles M. Schulz' } ];","title":"Typescript file"},{"location":"developers/dsp-ui/documentation/action/sort-button/#optional","text":"It's possible to set the position of the sort button to the right or left side with the property [position] .","title":"Optional"},{"location":"developers/dsp-ui/documentation/action/stringify-string-literal/","text":"StringifyStringLiteral (Pipe) This pipe stringifies an array of StringLiterals. With the parameter all , the pipe concats all values and appends the corresponding language in brackets. Otherwise the pipe displays the value corresponding to the default language which comes from the user profile (if a user is logged-in) or from the browser. With the predefined language the pipe checks, if a value exists in the array, otherwise it shows the first value. Example - StringifyStringLiteral Pipe HTML file <strong>Show all values</strong> <p>{{labels | kuiStringifyStringLiteral:'all'}}</p> <strong>Show only one value</strong> <p>{{labels | kuiStringifyStringLiteral}}</p> Typescript file labels: StringLiteral[] = '[{\"value\":\"Welt\",\"language\":\"de\"},{\"value\":\"World\",\"language\":\"en\"},{\"value\":\"Monde\",\"language\":\"fr\"},{\"value\":\"Mondo\",\"language\":\"it\"}]'; Show all values Welt (de) / World (en) / Monde (fr) / Mondo (it) Show only one value World","title":"StringifyStringLiteral"},{"location":"developers/dsp-ui/documentation/action/stringify-string-literal/#stringifystringliteral-pipe","text":"This pipe stringifies an array of StringLiterals. With the parameter all , the pipe concats all values and appends the corresponding language in brackets. Otherwise the pipe displays the value corresponding to the default language which comes from the user profile (if a user is logged-in) or from the browser. With the predefined language the pipe checks, if a value exists in the array, otherwise it shows the first value.","title":"StringifyStringLiteral (Pipe)"},{"location":"developers/dsp-ui/documentation/action/stringify-string-literal/#example-stringifystringliteral-pipe","text":"","title":"Example - StringifyStringLiteral Pipe"},{"location":"developers/dsp-ui/documentation/action/stringify-string-literal/#html-file","text":"<strong>Show all values</strong> <p>{{labels | kuiStringifyStringLiteral:'all'}}</p> <strong>Show only one value</strong> <p>{{labels | kuiStringifyStringLiteral}}</p>","title":"HTML file"},{"location":"developers/dsp-ui/documentation/action/stringify-string-literal/#typescript-file","text":"labels: StringLiteral[] = '[{\"value\":\"Welt\",\"language\":\"de\"},{\"value\":\"World\",\"language\":\"en\"},{\"value\":\"Monde\",\"language\":\"fr\"},{\"value\":\"Mondo\",\"language\":\"it\"}]'; Show all values Welt (de) / World (en) / Monde (fr) / Mondo (it) Show only one value World","title":"Typescript file"},{"location":"developers/dsp-ui/documentation/action/truncate/","text":"Truncate (Pipe) This pipe can be used to shorten long text by a defined length. In markup: {{ str | kuiTruncate:[24] }} or {{ str | kuiTruncate:[24, '...'] }} The first parameter defines the length where to truncate the string. Second optional parameter defines the characters to append to the shortened string. Default is ... . The advantage of this pipe over the default Angular slice pipe is the simplicity of adding additional characters at the end of the shortened string. The same construct with Angular slice pipe looks as follow: {{ (str.length>24)? (str | slice:0:24)+'...':(str) }} . Example - Truncate Pipe HTML file <p>{{longText | kuiTruncate:[24]}}</p> Typescript file longText: string = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Vel pharetra vel turpis nunc eget lorem dolor. Euismod lacinia at quis risus sed vulputate. Ultrices gravida dictum fusce ut placerat orci nulla pellentesque. Tortor consequat id porta nibh venenatis cras. Turpis tincidunt id aliquet risus feugiat in ante metus. Dictum fusce ut placerat orci nulla pellentesque dignissim enim sit. Mattis vulputate enim nulla aliquet porttitor lacus luctus accumsan. Mauris sit amet massa vitae tortor condimentum lacinia quis vel. Dictum sit amet justo donec enim diam vulputate. Dignissim convallis aenean et tortor. Ut tellus elementum sagittis vitae et. Pretium viverra suspendisse potenti nullam ac tortor vitae purus faucibus. Eget mauris pharetra et ultrices neque ornare aenean. Diam in arcu cursus euismod. Odio ut enim blandit volutpat maecenas volutpat. Suspendisse interdum consectetur libero id faucibus nisl tincidunt eget. Risus commodo viverra maecenas accumsan.'; Output: Lorem ipsum dolor sit am...","title":"Truncate"},{"location":"developers/dsp-ui/documentation/action/truncate/#truncate-pipe","text":"This pipe can be used to shorten long text by a defined length. In markup: {{ str | kuiTruncate:[24] }} or {{ str | kuiTruncate:[24, '...'] }} The first parameter defines the length where to truncate the string. Second optional parameter defines the characters to append to the shortened string. Default is ... . The advantage of this pipe over the default Angular slice pipe is the simplicity of adding additional characters at the end of the shortened string. The same construct with Angular slice pipe looks as follow: {{ (str.length>24)? (str | slice:0:24)+'...':(str) }} .","title":"Truncate (Pipe)"},{"location":"developers/dsp-ui/documentation/action/truncate/#example-truncate-pipe","text":"","title":"Example - Truncate Pipe"},{"location":"developers/dsp-ui/documentation/action/truncate/#html-file","text":"<p>{{longText | kuiTruncate:[24]}}</p>","title":"HTML file"},{"location":"developers/dsp-ui/documentation/action/truncate/#typescript-file","text":"longText: string = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Vel pharetra vel turpis nunc eget lorem dolor. Euismod lacinia at quis risus sed vulputate. Ultrices gravida dictum fusce ut placerat orci nulla pellentesque. Tortor consequat id porta nibh venenatis cras. Turpis tincidunt id aliquet risus feugiat in ante metus. Dictum fusce ut placerat orci nulla pellentesque dignissim enim sit. Mattis vulputate enim nulla aliquet porttitor lacus luctus accumsan. Mauris sit amet massa vitae tortor condimentum lacinia quis vel. Dictum sit amet justo donec enim diam vulputate. Dignissim convallis aenean et tortor. Ut tellus elementum sagittis vitae et. Pretium viverra suspendisse potenti nullam ac tortor vitae purus faucibus. Eget mauris pharetra et ultrices neque ornare aenean. Diam in arcu cursus euismod. Odio ut enim blandit volutpat maecenas volutpat. Suspendisse interdum consectetur libero id faucibus nisl tincidunt eget. Risus commodo viverra maecenas accumsan.'; Output: Lorem ipsum dolor sit am...","title":"Typescript file"},{"location":"developers/dsp-ui/documentation/core/index-core/","text":"DSP-UI CORE module DspCoreModule is a configuration handler for @knora/api which offers all the services to make DSP-API requests . Prerequisites For help getting started with a new Angular app, check out the Angular CLI . For existing apps, follow these steps to begin using DSP-UI CORE. Installation DspCoreModule is part of @dasch-swiss/dsp-ui, follow the installation guide . Usage The following ProjectsComponent example shows how to implement the two libraries to get all projects from DSP-API: import { Component, Inject, OnInit } from '@angular/core'; import { DspApiConnectionToken } from '@dasch-swiss/dsp-ui'; import { ApiResponseData, ApiResponseError, KnoraApiConnection, ProjectsResponse, ReadProject } from '@knora/api'; @Component({ selector: 'app-projects', template: `<ul><li *ngFor=\"let p of projects\">{{p.longname}} (<strong>{{p.shortname}}</strong> | {{p.shortcode}})</li></ul>` }) export class ProjectsComponent implements OnInit { projects: ReadProject[]; constructor( @Inject(DspApiConnectionToken) private dspApiConnection: KnoraApiConnection ) { } ngOnInit() { this.getProjects(); } getProjects() { this.dspApiConnection.admin.projectsEndpoint.getProjects().subscribe( (response: ApiResponseData<ProjectsResponse>) => { this.projects = response.body.projects; }, (error: ApiResponseError) => { console.error(error); } ); } }","title":"Readme"},{"location":"developers/dsp-ui/documentation/core/index-core/#dsp-ui-core-module","text":"DspCoreModule is a configuration handler for @knora/api which offers all the services to make DSP-API requests .","title":"DSP-UI CORE module"},{"location":"developers/dsp-ui/documentation/core/index-core/#prerequisites","text":"For help getting started with a new Angular app, check out the Angular CLI . For existing apps, follow these steps to begin using DSP-UI CORE.","title":"Prerequisites"},{"location":"developers/dsp-ui/documentation/core/index-core/#installation","text":"DspCoreModule is part of @dasch-swiss/dsp-ui, follow the installation guide .","title":"Installation"},{"location":"developers/dsp-ui/documentation/core/index-core/#usage","text":"The following ProjectsComponent example shows how to implement the two libraries to get all projects from DSP-API: import { Component, Inject, OnInit } from '@angular/core'; import { DspApiConnectionToken } from '@dasch-swiss/dsp-ui'; import { ApiResponseData, ApiResponseError, KnoraApiConnection, ProjectsResponse, ReadProject } from '@knora/api'; @Component({ selector: 'app-projects', template: `<ul><li *ngFor=\"let p of projects\">{{p.longname}} (<strong>{{p.shortname}}</strong> | {{p.shortcode}})</li></ul>` }) export class ProjectsComponent implements OnInit { projects: ReadProject[]; constructor( @Inject(DspApiConnectionToken) private dspApiConnection: KnoraApiConnection ) { } ngOnInit() { this.getProjects(); } getProjects() { this.dspApiConnection.admin.projectsEndpoint.getProjects().subscribe( (response: ApiResponseData<ProjectsResponse>) => { this.projects = response.body.projects; }, (error: ApiResponseError) => { console.error(error); } ); } }","title":"Usage"},{"location":"developers/dsp-ui/documentation/search/expert-search/","text":"Expert search (Component) The expert search is a textarea field in which Gravsearch queries can be written. Complex search can be made this way but you must know the Gravsearch language . Parameters Name Type Description route (optionnal) string Route to navigate after search. This route path should contain a component for search results. gravsearch string Send the gravsearch query back. toggleExpertSearchForm boolean Trigger toggle for extended search form. Examples Extended search panel <!-- param gravsearch is where the gravsearch query is cached or sent to Knora --> <kui-expert-search (gravsearch)=\"setGravsearch($event)\"></kui-expert-search>","title":"Expert search"},{"location":"developers/dsp-ui/documentation/search/expert-search/#expert-search-component","text":"The expert search is a textarea field in which Gravsearch queries can be written. Complex search can be made this way but you must know the Gravsearch language .","title":"Expert search (Component)"},{"location":"developers/dsp-ui/documentation/search/expert-search/#parameters","text":"Name Type Description route (optionnal) string Route to navigate after search. This route path should contain a component for search results. gravsearch string Send the gravsearch query back. toggleExpertSearchForm boolean Trigger toggle for extended search form.","title":"Parameters"},{"location":"developers/dsp-ui/documentation/search/expert-search/#examples","text":"Extended search panel <!-- param gravsearch is where the gravsearch query is cached or sent to Knora --> <kui-expert-search (gravsearch)=\"setGravsearch($event)\"></kui-expert-search>","title":"Examples"},{"location":"developers/dsp-ui/documentation/search/extended-search/","text":"Extended search (Component) The extended search allows you to filter by project, by source type (resource class), or by the metadata (properties) of source types. Each filter can be standalone or combined. The metadata field can be precisely filtered with criteria such as \"contains\", \"like\", \"equals to\", \"exists\" or in case of a date value with \"before\" or \"after\". In addition, for a metadata field that is connected to another source type, it's possible to filter by this second source type. If you are looking for the source type \"Photograph\" with the metadata field \"Photographer\", which is connected to source type \"Person\", you can search for photograph(s) taken by person(s) who is born before February 1970. The result of this request will be an intersection of the two source types. Parameters Name Type Description route string Route to navigate after search. This route path should contain a component for search results. toggleExtendedSearchForm boolean Trigger toggle for extended search form. gravsearch string Send the gravsearch query back. Examples Extended search panel <!-- param route is where the router-outlet is defined for search results --> <kui-extended-search [route]=\"'/search'\"></kui-search> <router-outlet></router-outlet>","title":"Extended search"},{"location":"developers/dsp-ui/documentation/search/extended-search/#extended-search-component","text":"The extended search allows you to filter by project, by source type (resource class), or by the metadata (properties) of source types. Each filter can be standalone or combined. The metadata field can be precisely filtered with criteria such as \"contains\", \"like\", \"equals to\", \"exists\" or in case of a date value with \"before\" or \"after\". In addition, for a metadata field that is connected to another source type, it's possible to filter by this second source type. If you are looking for the source type \"Photograph\" with the metadata field \"Photographer\", which is connected to source type \"Person\", you can search for photograph(s) taken by person(s) who is born before February 1970. The result of this request will be an intersection of the two source types.","title":"Extended search (Component)"},{"location":"developers/dsp-ui/documentation/search/extended-search/#parameters","text":"Name Type Description route string Route to navigate after search. This route path should contain a component for search results. toggleExtendedSearchForm boolean Trigger toggle for extended search form. gravsearch string Send the gravsearch query back.","title":"Parameters"},{"location":"developers/dsp-ui/documentation/search/extended-search/#examples","text":"Extended search panel <!-- param route is where the router-outlet is defined for search results --> <kui-extended-search [route]=\"'/search'\"></kui-search> <router-outlet></router-outlet>","title":"Examples"},{"location":"developers/dsp-ui/documentation/search/fulltext-search/","text":"Full-text search (Component) - DEPRECATED Input field to perform a full text search. Parameters Name Type Description route string Route to navigate after search. This route path should contain a component for search results. projectfilter (optional) boolean If true it shows the selection of projects to filter by one of them filterbyproject (optional) string If the full-text search should be filtered by one project, you can define it with project iri. Examples Simple full-text search <!-- param route is where the router-outlet is defined for search results --> <kui-fulltext-search [route]=\"'/search'\"></kui-fulltext-search> <router-outlet></router-outlet> Full-text search with project filter <!-- param route is where the router-outlet is defined for search results --> <kui-fulltext-search [route]=\"'/search'\" [projectfilter]=\"true\"></kui-fulltext-search> <router-outlet></router-outlet>","title":"Fulltext search"},{"location":"developers/dsp-ui/documentation/search/fulltext-search/#full-text-search-component-deprecated","text":"Input field to perform a full text search.","title":"Full-text search (Component) - DEPRECATED"},{"location":"developers/dsp-ui/documentation/search/fulltext-search/#parameters","text":"Name Type Description route string Route to navigate after search. This route path should contain a component for search results. projectfilter (optional) boolean If true it shows the selection of projects to filter by one of them filterbyproject (optional) string If the full-text search should be filtered by one project, you can define it with project iri.","title":"Parameters"},{"location":"developers/dsp-ui/documentation/search/fulltext-search/#examples","text":"","title":"Examples"},{"location":"developers/dsp-ui/documentation/search/fulltext-search/#simple-full-text-search","text":"<!-- param route is where the router-outlet is defined for search results --> <kui-fulltext-search [route]=\"'/search'\"></kui-fulltext-search> <router-outlet></router-outlet>","title":"Simple full-text search"},{"location":"developers/dsp-ui/documentation/search/fulltext-search/#full-text-search-with-project-filter","text":"<!-- param route is where the router-outlet is defined for search results --> <kui-fulltext-search [route]=\"'/search'\" [projectfilter]=\"true\"></kui-fulltext-search> <router-outlet></router-outlet>","title":"Full-text search with project filter"},{"location":"developers/dsp-ui/documentation/search/index-search/","text":"DSP-UI SEARCH module DspSearchModule allows to make simple searches or extended searches in DSP-API. In extended search, resource class and its properties related to one specific ontology are selected to create your query. It is also possible to write Gravsearch queries to target specific data with the expert search form. Prerequisites For help getting started with a new Angular app, check out the Angular CLI . For existing apps, follow these steps to begin using DSP-UI SEARCH. Installation DspSearchModule is part of @dasch-swiss/dsp-ui, follow the installation guide . Components This module contains various components to search. The main component is the kui-search-panel, which contains the kui-fulltext-search, kui-extended-search and kui-expert-search. All of them can be used standalone or in combination in kui-search-panel. Search panel Fully customizable panel. You can set the following parameters in kui-search-panel: route: string; url-route for search results filterbyproject: string; project iri to limit search results by project projectfilter: boolean; selection of all projects to filter by one of them advanced: boolean; additional menu with advanced / extended search expert: boolean; additional menu with expert search / gravsearch \"editor\" If everything is set to false or undefined the search-panel is a simple full-text search. Read more Full-text search (Deprecated) <kui-fulltext-search [route]=\"/search-results\"></kui-fulltext-search> The parameter route defines the route where the search-results-component of the app is defined. We suggest to define a route for the search-results in the app.routing path: 'search', component: SearchComponent, // --> Component with the search panel children: [ { path: ':mode/:q/:project', component: SearchResultsComponent // --> search results, in case of paramter filterByProject and/or projectFilter }, { path: ':mode/:q', component: SearchResultsComponent } ] Extended / advanced search Generic search filter tool to limit search results to ontology and resource class and / or properties. If you want to use this search, you have to add the following css style to you main app stylesheet to style the date picker properly. .mat-datepicker-content { .mat-calendar { height: auto !important; } } Expert search Expert search is a textarea input field in which you can create Gravsearch queries. The expert search can be more powerful than the advanced search, but requires knowing how to use the query language Gravsearch (based on SparQL and developed by the DaSCH team). With Gravsearch, expert users can build searches by combining text-related criteria with any other criteria. Check the Gravsearch learning guide on DSP-API documentation. Setup Import the search module in your app.module.ts and add it to the NgModules's imports: import { AppComponent } from './app.component'; import { DspCoreModule, DspSearchModule } from '@dasch-swiss/dsp-ui'; @NgModule({ declarations: [ AppComponent ], imports: [ DspCoreModule, // <- core module is required for some components and directives DspSearchModule // <- add search module in the imports ], providers: [ ... ] // <-- add providers as mentioned in the installation guide bootstrap: [AppComponent] }) export class AppModule { } The search components need a global styling in the app to override some material styling rules. Please update your angular.json file as follow: ... \"styles\": [ \"src/styles.scss\", \"node_modules/@dasch-swiss/dsp-ui/search/assets/style/search.scss\" // <- add this line ], ...","title":"Readme"},{"location":"developers/dsp-ui/documentation/search/index-search/#dsp-ui-search-module","text":"DspSearchModule allows to make simple searches or extended searches in DSP-API. In extended search, resource class and its properties related to one specific ontology are selected to create your query. It is also possible to write Gravsearch queries to target specific data with the expert search form.","title":"DSP-UI SEARCH module"},{"location":"developers/dsp-ui/documentation/search/index-search/#prerequisites","text":"For help getting started with a new Angular app, check out the Angular CLI . For existing apps, follow these steps to begin using DSP-UI SEARCH.","title":"Prerequisites"},{"location":"developers/dsp-ui/documentation/search/index-search/#installation","text":"DspSearchModule is part of @dasch-swiss/dsp-ui, follow the installation guide .","title":"Installation"},{"location":"developers/dsp-ui/documentation/search/index-search/#components","text":"This module contains various components to search. The main component is the kui-search-panel, which contains the kui-fulltext-search, kui-extended-search and kui-expert-search. All of them can be used standalone or in combination in kui-search-panel.","title":"Components"},{"location":"developers/dsp-ui/documentation/search/index-search/#search-panel","text":"Fully customizable panel. You can set the following parameters in kui-search-panel: route: string; url-route for search results filterbyproject: string; project iri to limit search results by project projectfilter: boolean; selection of all projects to filter by one of them advanced: boolean; additional menu with advanced / extended search expert: boolean; additional menu with expert search / gravsearch \"editor\" If everything is set to false or undefined the search-panel is a simple full-text search. Read more","title":"Search panel"},{"location":"developers/dsp-ui/documentation/search/index-search/#full-text-search-deprecated","text":"<kui-fulltext-search [route]=\"/search-results\"></kui-fulltext-search> The parameter route defines the route where the search-results-component of the app is defined. We suggest to define a route for the search-results in the app.routing path: 'search', component: SearchComponent, // --> Component with the search panel children: [ { path: ':mode/:q/:project', component: SearchResultsComponent // --> search results, in case of paramter filterByProject and/or projectFilter }, { path: ':mode/:q', component: SearchResultsComponent } ]","title":"Full-text search (Deprecated)"},{"location":"developers/dsp-ui/documentation/search/index-search/#extended-advanced-search","text":"Generic search filter tool to limit search results to ontology and resource class and / or properties. If you want to use this search, you have to add the following css style to you main app stylesheet to style the date picker properly. .mat-datepicker-content { .mat-calendar { height: auto !important; } }","title":"Extended / advanced search"},{"location":"developers/dsp-ui/documentation/search/index-search/#expert-search","text":"Expert search is a textarea input field in which you can create Gravsearch queries. The expert search can be more powerful than the advanced search, but requires knowing how to use the query language Gravsearch (based on SparQL and developed by the DaSCH team). With Gravsearch, expert users can build searches by combining text-related criteria with any other criteria. Check the Gravsearch learning guide on DSP-API documentation.","title":"Expert search"},{"location":"developers/dsp-ui/documentation/search/index-search/#setup","text":"Import the search module in your app.module.ts and add it to the NgModules's imports: import { AppComponent } from './app.component'; import { DspCoreModule, DspSearchModule } from '@dasch-swiss/dsp-ui'; @NgModule({ declarations: [ AppComponent ], imports: [ DspCoreModule, // <- core module is required for some components and directives DspSearchModule // <- add search module in the imports ], providers: [ ... ] // <-- add providers as mentioned in the installation guide bootstrap: [AppComponent] }) export class AppModule { } The search components need a global styling in the app to override some material styling rules. Please update your angular.json file as follow: ... \"styles\": [ \"src/styles.scss\", \"node_modules/@dasch-swiss/dsp-ui/search/assets/style/search.scss\" // <- add this line ], ...","title":"Setup"},{"location":"developers/dsp-ui/documentation/search/search-panel/","text":"Search panel (Component) The search-panel contains the list of projects to filter and kui-fulltext-search and links to kui-extended-search and kui-expert-search. Parameters Name Type Description route string Route to navigate after search. This route path should contain a component for search results. projectfilter (optional) boolean If true it shows the selection of projects to filter by one of them filterbyproject (optional) string If your full-text search should be filtered by one project, you can define it with project iri in the parameter filterbyproject advanced (optional) boolean Adds the extended / advanced search to the panel expert (optional) boolean Adds the expert search / gravsearch editor to the panel Examples Implement the search panel in your HTML file: <kui-search-panel [filterbyproject]=\"http://rdfh.ch/projects/0001\" [projectfilter]=\"true\" [advanced]=\"true\" [expert]=\"true\"> </kui-search-panel> <router-outlet></router-outlet>","title":"Search-panel"},{"location":"developers/dsp-ui/documentation/search/search-panel/#search-panel-component","text":"The search-panel contains the list of projects to filter and kui-fulltext-search and links to kui-extended-search and kui-expert-search.","title":"Search panel (Component)"},{"location":"developers/dsp-ui/documentation/search/search-panel/#parameters","text":"Name Type Description route string Route to navigate after search. This route path should contain a component for search results. projectfilter (optional) boolean If true it shows the selection of projects to filter by one of them filterbyproject (optional) string If your full-text search should be filtered by one project, you can define it with project iri in the parameter filterbyproject advanced (optional) boolean Adds the extended / advanced search to the panel expert (optional) boolean Adds the expert search / gravsearch editor to the panel","title":"Parameters"},{"location":"developers/dsp-ui/documentation/search/search-panel/#examples","text":"Implement the search panel in your HTML file: <kui-search-panel [filterbyproject]=\"http://rdfh.ch/projects/0001\" [projectfilter]=\"true\" [advanced]=\"true\" [expert]=\"true\"> </kui-search-panel> <router-outlet></router-outlet>","title":"Examples"},{"location":"developers/dsp-ui/documentation/viewer/index-viewer/","text":"DSP-UI VIEWER module DspViewerModule contains components to display resources; as single item or as a list for search results. It is comprised of resource sub-components such as file representations components to display still image, video, audio or text only and also value components to use single property elements. Prerequisites For help getting started with a new Angular app, check out the Angular CLI . For existing apps, follow these steps to begin using DSP-UI VIEWER. Installation DspViewerModule is part of @dasch-swiss/dsp-ui, follow the installation guide . Setup Import the viewer module in your app.module.ts and add it to the NgModules's imports: import { AppComponent } from './app.component'; import { DspCoreModule, DspViewerModule } from '@dasch-swiss/dsp-ui'; @NgModule({ declarations: [ AppComponent ], imports: [ DspCoreModule, // <- core module is required for some components and directives DspViewerModule // <- add viewer module in the imports ], providers: [ ... ] // <-- add providers as mentioned in the installation guide bootstrap: [AppComponent] }) export class AppModule { } Usage Use DSP-UI VIEWER module in the component template as follows. The example shows how to display a resource by iri = 'http://rdfh.ch/0803/18a671b8a601'. <dsp-resource-view [iri]=\"'http://rdfh.ch/0803/18a671b8a601'\"></dsp-resource-view>","title":"Readme"},{"location":"developers/dsp-ui/documentation/viewer/index-viewer/#dsp-ui-viewer-module","text":"DspViewerModule contains components to display resources; as single item or as a list for search results. It is comprised of resource sub-components such as file representations components to display still image, video, audio or text only and also value components to use single property elements.","title":"DSP-UI VIEWER module"},{"location":"developers/dsp-ui/documentation/viewer/index-viewer/#prerequisites","text":"For help getting started with a new Angular app, check out the Angular CLI . For existing apps, follow these steps to begin using DSP-UI VIEWER.","title":"Prerequisites"},{"location":"developers/dsp-ui/documentation/viewer/index-viewer/#installation","text":"DspViewerModule is part of @dasch-swiss/dsp-ui, follow the installation guide .","title":"Installation"},{"location":"developers/dsp-ui/documentation/viewer/index-viewer/#setup","text":"Import the viewer module in your app.module.ts and add it to the NgModules's imports: import { AppComponent } from './app.component'; import { DspCoreModule, DspViewerModule } from '@dasch-swiss/dsp-ui'; @NgModule({ declarations: [ AppComponent ], imports: [ DspCoreModule, // <- core module is required for some components and directives DspViewerModule // <- add viewer module in the imports ], providers: [ ... ] // <-- add providers as mentioned in the installation guide bootstrap: [AppComponent] }) export class AppModule { }","title":"Setup"},{"location":"developers/dsp-ui/documentation/viewer/index-viewer/#usage","text":"Use DSP-UI VIEWER module in the component template as follows. The example shows how to display a resource by iri = 'http://rdfh.ch/0803/18a671b8a601'. <dsp-resource-view [iri]=\"'http://rdfh.ch/0803/18a671b8a601'\"></dsp-resource-view>","title":"Usage"},{"location":"developers/dsp-ui/documentation/viewer/search-results/","text":"Search results (Component) The search-results gets the search mode and parameters from routes or inputs, and returns the corresponding resources that are displayed in a list or a grid. The results can be filtered by project. List of parameters complexView (optional) searchQuery (optional) searchMode (optional) projectIri (optional) Simple search results example HTML file <kui-search-results></kui-search-results> Search results filtered by project example HTML file <kui-search-results [projectIri]=\"projectIri\"></kui-search-results> Typescript file export class SearchResultsComponent { projectIri = 'http://rdfh.ch/projects/0001'; // project iri constructor() { } } Search results providing search mode and query parameters example HTML file <!-- example of an extended search where we pass a gravsearch query as search parameter --> <kui-search-results [searchMode]=\"'extended'\" [searchQuery]=\"gravsearch\"></kui-search-results> Typescript file export class SearchResultsComponent { gravsearch: string = `PREFIX knora-api: <http://api.knora.org/ontology/knora-api/simple/v2#> CONSTRUCT { ?mainRes knora-api:isMainResource true . } WHERE { ?mainRes a knora-api:Resource . ?mainRes a <http://0.0.0.0:3333/ontology/0001/anything/simple/v2#BlueThing> . } OFFSET 0`; constructor() { } }","title":"Search-results"},{"location":"developers/dsp-ui/documentation/viewer/search-results/#search-results-component","text":"The search-results gets the search mode and parameters from routes or inputs, and returns the corresponding resources that are displayed in a list or a grid. The results can be filtered by project.","title":"Search results (Component)"},{"location":"developers/dsp-ui/documentation/viewer/search-results/#list-of-parameters","text":"complexView (optional) searchQuery (optional) searchMode (optional) projectIri (optional)","title":"List of parameters"},{"location":"developers/dsp-ui/documentation/viewer/search-results/#simple-search-results-example","text":"","title":"Simple search results example"},{"location":"developers/dsp-ui/documentation/viewer/search-results/#html-file","text":"<kui-search-results></kui-search-results>","title":"HTML file"},{"location":"developers/dsp-ui/documentation/viewer/search-results/#search-results-filtered-by-project-example","text":"","title":"Search results filtered by project example"},{"location":"developers/dsp-ui/documentation/viewer/search-results/#html-file_1","text":"<kui-search-results [projectIri]=\"projectIri\"></kui-search-results>","title":"HTML file"},{"location":"developers/dsp-ui/documentation/viewer/search-results/#typescript-file","text":"export class SearchResultsComponent { projectIri = 'http://rdfh.ch/projects/0001'; // project iri constructor() { } }","title":"Typescript file"},{"location":"developers/dsp-ui/documentation/viewer/search-results/#search-results-providing-search-mode-and-query-parameters-example","text":"","title":"Search results providing search mode and query parameters example"},{"location":"developers/dsp-ui/documentation/viewer/search-results/#html-file_2","text":"<!-- example of an extended search where we pass a gravsearch query as search parameter --> <kui-search-results [searchMode]=\"'extended'\" [searchQuery]=\"gravsearch\"></kui-search-results>","title":"HTML file"},{"location":"developers/dsp-ui/documentation/viewer/search-results/#typescript-file_1","text":"export class SearchResultsComponent { gravsearch: string = `PREFIX knora-api: <http://api.knora.org/ontology/knora-api/simple/v2#> CONSTRUCT { ?mainRes knora-api:isMainResource true . } WHERE { ?mainRes a knora-api:Resource . ?mainRes a <http://0.0.0.0:3333/ontology/0001/anything/simple/v2#BlueThing> . } OFFSET 0`; constructor() { } }","title":"Typescript file"},{"location":"developers/knora/getting-started/","text":"How to install Knora Developing for Knora requires a complete local installation of Knora. The different parts are: The cloned Knora Github repository [https://github.com/dhlab-basel/Knora] One of the supplied triplestores in the Knora Github repository Sipi by using the docker image . Install additional software For a successful local installation of Knora additional software has to be installed. First of all Xcode must be installed. Xcode is an integrated developer environment of Apple for macOS. Thus, you can find Xcode in the App Store. After downloading the app, agree to the license terms and install the components. Next, we recommend to install Homebrew [https://brew.sh] . If you haven't installed Homebrew yet, open a terminal window and type ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" You'll then see messages explaining what you need to do to complete the installation process. If Homebrew is already installed on your computer, update it before installing further packages by typing brew update Then, install Java Adoptopenjdk 11 following these steps: $ brew tap AdoptOpenJDK/openjdk $ brew cask install AdoptOpenJDK/openjdk/adoptopenjdk11 It is necessary to pin the version of Java to version 11. To achieve this, please add the following environment variable to your startup script (.bashrc, .zshenv, etc. - depending on the shell you're using): export JAVA_HOME=`/usr/libexec/java_home -v 11` Running Knora also requires Docker which can be downloaded free of charge. Please follow the instructions for installing Docker Desktop . It is useful if you increase the memory to 6.50 GB in docker > preferences > resources. For a successful local installation of Knora the following additional software is necessary too: git expect sbt redis Python 3 Simply type brew install git brew install expect brew install sbt brew install redis brew install python to install the necessary additional software. Git is a version-control system for tracking changes in files. Expect is a tool for automating interactive applications. Sbt is a build-tool for Scala and Java projects. Redis is a data structure store needed for caching. Clone Knora from Github To clone Knora from Github open a terminal window and change to the directory where you intend to install Knora. Then type git clone https://github.com/dasch-swiss/knora-api.git This will install the directory Knora with subdirectories in the chosen directory. Chose and install a triplestore There are a number of triplestore implementations available, including free software as well as proprietary options. Knora is aimed to work with any standards-compliant triplestore. However, it is primarily tested with Ontotext GraphDB [http://ontotext.com/products/graphdb/] , a high-performance, proprietary triplestore. We recommend GraphDB Standard Edition, but GraphDB Free - which is proprietary but available free of charge - also works. Both versions need to be licensed separately from Ontotext [http://ontotext.com] . GraphDB-Free can be simply licensed by filling in the respective online registration from. Depending on which GraphDB version has been licensed, some environment variables may have to be set: GraphDB-Free: Type export KNORA_GDB_TYPE=graphdb-free to tell Knora that you use GraphDB-Free. If you decide to use another folder than the default folder ./triplestores/graphdb/ , it is necessary to tell Knora the path to your folder: export KNORA_GDB_HOME=/path/to/your/folder Copy the GraphDB license file into the folder ./triplestores/graphdb/ or into a folder of your choice and name it graphdb.license . GraphDB-SE: Since GraphDB-SE is our default triplestore version you only need to modify the settings if you aren't using the following default value paths: ./triplestores/graphdb/ for KNORA_GDB_HOME ./triplestores/graphdb/graphdb.license for the license file. If you chose other locations, you need to tell Knora the path to your folder and to the license file: export KNORA_GDB_TYPE=graphdb-se export KNORA_GDB_LICENSE=/path/to/your/licensefile export KNORA_GDB_HOME=/path/to/your/folder Copy the GraphDB license file into the folder ./triplestores/graphdb/ or into a folder of your choice and name it graphdb.license . Then restart your terminal. Build the docker image From inside the cloned Knora repository folder run make stack-up to compose the Docker image. This should start the complete Knora stack consisting of GraphDB, Webapi, Salsah1 and Sipi which may take some time. If everything worked properly, when typing the command docker ps you should see five active processes / available endpoints for your local instance: sipi at 0.0.0.0:1024 salsah1 at 0.0.0.0:3335 webapi at 0.0.0.0:3333 redis at 0.0.0.0:6379 graphdb at 0.0.0.0:7200 If everything worked fine, type make init-db-test to load some test data. Afterwards it is necessary to restart the API. Type make stack-restart-api Then, the test data are available to play with them. If not, try make stack-down make stack-up to stop and reload everything. You can then create your own scripts based on the knora-test scripts to create new repositories and optionally load existing Knora-compliant RDF data into them. When you open 0.0.0.0:3335 in your Browser, you should see our Web-API start page called SALSAH. The GraphDB workbench you can find at 0.0.0.0:7200 . To stop everything again, type make stack-down","title":"Knora Getting Started"},{"location":"developers/knora/getting-started/#how-to-install-knora","text":"Developing for Knora requires a complete local installation of Knora. The different parts are: The cloned Knora Github repository [https://github.com/dhlab-basel/Knora] One of the supplied triplestores in the Knora Github repository Sipi by using the docker image .","title":"How to install Knora"},{"location":"developers/knora/getting-started/#install-additional-software","text":"For a successful local installation of Knora additional software has to be installed. First of all Xcode must be installed. Xcode is an integrated developer environment of Apple for macOS. Thus, you can find Xcode in the App Store. After downloading the app, agree to the license terms and install the components. Next, we recommend to install Homebrew [https://brew.sh] . If you haven't installed Homebrew yet, open a terminal window and type ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" You'll then see messages explaining what you need to do to complete the installation process. If Homebrew is already installed on your computer, update it before installing further packages by typing brew update Then, install Java Adoptopenjdk 11 following these steps: $ brew tap AdoptOpenJDK/openjdk $ brew cask install AdoptOpenJDK/openjdk/adoptopenjdk11 It is necessary to pin the version of Java to version 11. To achieve this, please add the following environment variable to your startup script (.bashrc, .zshenv, etc. - depending on the shell you're using): export JAVA_HOME=`/usr/libexec/java_home -v 11` Running Knora also requires Docker which can be downloaded free of charge. Please follow the instructions for installing Docker Desktop . It is useful if you increase the memory to 6.50 GB in docker > preferences > resources. For a successful local installation of Knora the following additional software is necessary too: git expect sbt redis Python 3 Simply type brew install git brew install expect brew install sbt brew install redis brew install python to install the necessary additional software. Git is a version-control system for tracking changes in files. Expect is a tool for automating interactive applications. Sbt is a build-tool for Scala and Java projects. Redis is a data structure store needed for caching.","title":"Install additional software"},{"location":"developers/knora/getting-started/#clone-knora-from-github","text":"To clone Knora from Github open a terminal window and change to the directory where you intend to install Knora. Then type git clone https://github.com/dasch-swiss/knora-api.git This will install the directory Knora with subdirectories in the chosen directory.","title":"Clone Knora from Github"},{"location":"developers/knora/getting-started/#chose-and-install-a-triplestore","text":"There are a number of triplestore implementations available, including free software as well as proprietary options. Knora is aimed to work with any standards-compliant triplestore. However, it is primarily tested with Ontotext GraphDB [http://ontotext.com/products/graphdb/] , a high-performance, proprietary triplestore. We recommend GraphDB Standard Edition, but GraphDB Free - which is proprietary but available free of charge - also works. Both versions need to be licensed separately from Ontotext [http://ontotext.com] . GraphDB-Free can be simply licensed by filling in the respective online registration from. Depending on which GraphDB version has been licensed, some environment variables may have to be set:","title":"Chose and install a triplestore"},{"location":"developers/knora/getting-started/#graphdb-free","text":"Type export KNORA_GDB_TYPE=graphdb-free to tell Knora that you use GraphDB-Free. If you decide to use another folder than the default folder ./triplestores/graphdb/ , it is necessary to tell Knora the path to your folder: export KNORA_GDB_HOME=/path/to/your/folder Copy the GraphDB license file into the folder ./triplestores/graphdb/ or into a folder of your choice and name it graphdb.license .","title":"GraphDB-Free:"},{"location":"developers/knora/getting-started/#graphdb-se","text":"Since GraphDB-SE is our default triplestore version you only need to modify the settings if you aren't using the following default value paths: ./triplestores/graphdb/ for KNORA_GDB_HOME ./triplestores/graphdb/graphdb.license for the license file. If you chose other locations, you need to tell Knora the path to your folder and to the license file: export KNORA_GDB_TYPE=graphdb-se export KNORA_GDB_LICENSE=/path/to/your/licensefile export KNORA_GDB_HOME=/path/to/your/folder Copy the GraphDB license file into the folder ./triplestores/graphdb/ or into a folder of your choice and name it graphdb.license . Then restart your terminal.","title":"GraphDB-SE:"},{"location":"developers/knora/getting-started/#build-the-docker-image","text":"From inside the cloned Knora repository folder run make stack-up to compose the Docker image. This should start the complete Knora stack consisting of GraphDB, Webapi, Salsah1 and Sipi which may take some time. If everything worked properly, when typing the command docker ps you should see five active processes / available endpoints for your local instance: sipi at 0.0.0.0:1024 salsah1 at 0.0.0.0:3335 webapi at 0.0.0.0:3333 redis at 0.0.0.0:6379 graphdb at 0.0.0.0:7200 If everything worked fine, type make init-db-test to load some test data. Afterwards it is necessary to restart the API. Type make stack-restart-api Then, the test data are available to play with them. If not, try make stack-down make stack-up to stop and reload everything. You can then create your own scripts based on the knora-test scripts to create new repositories and optionally load existing Knora-compliant RDF data into them. When you open 0.0.0.0:3335 in your Browser, you should see our Web-API start page called SALSAH. The GraphDB workbench you can find at 0.0.0.0:7200 . To stop everything again, type make stack-down","title":"Build the docker image"},{"location":"developers/knora/api-reference/","text":"Knora API reference The Knora APIs include: The Knora API versions 1 and 2, which is intended to be used by virtual research environments and other clients for querying and updating data. The Knora Admin API, which is intended to be used only by the SALSAH user interface, for administering projects that use Knora as well as Knora itself.","title":"Introduction"},{"location":"developers/knora/api-reference/#knora-api-reference","text":"The Knora APIs include: The Knora API versions 1 and 2, which is intended to be used by virtual research environments and other clients for querying and updating data. The Knora Admin API, which is intended to be used only by the SALSAH user interface, for administering projects that use Knora as well as Knora itself.","title":"Knora API reference"},{"location":"developers/knora/api-reference/queries/","text":"How to build queries The simplest form of a query is a full-text search. For more complex queries than a full-text search, Knora offers a special query language called Gravsearch which is based on the query language SPARQL ( S PARQL P rotocol A nd R DF Q uery L anguage). Full-text search Knora offers a full-text search that searches all textual representations of values and rdfs:label -labels of resources. The full-text search supports the Lucene Query Parser syntax . Search terms can be seperated by a white space - then they will be combined using the Boolean operator OR since this is Lucene's default operator. Be aware, that the search terms have to be URL encoded! The recommended way to submit a full-text query is via HTTP GET in the following form. HTTP GET request sent to https://api.dasch.swiss/v2/search/searchValue[limitToResourceClass=resourceClassIRI][limitToStandoffClass=standoffClassIri][limitToProject=projectIRI][offset=Integer] Most of these parameters can be set optionally: * limitToResourceClass=resourceClassIRI : this restricts the search to resources of the specified resource class and its subclasses. * LimitToStandoffClass=standoffClassIRI : this will force Knora to look for search terms that are marked up with the indicated standoff class. * limitToProject=projectIRI : this restricts the search to resources of the specified project. * offset=Integer : this parameter can be used to enable paging and to go through all the results request by request. The default value for the parameter offset is 0 which will return the first page of search results. Subsequent pages can be retrieved by increasing the parameter offset by one. This means, offset=1 fetches the second page of serach results, offset=2 the third, and so on. The amount of retrieved search results per page is defined in app/v2 in the file application.conf . The first search parameter has to be preceded by a question mark ? and any following parameter by an ampersand & . A search value must have a minimal length of three characters (default value) as defined in app/v2 in the file application.conf . Wildcards may be used. * An ampersand & represents a single missing character. However, it has to be URL encoded as %3F because it has a special meaning in the URL syntax. * An asterisk * represents zero, one or multiple missing characters. The URL encode of an asterisk is %2A . To request the number of results rather than the results themselves, a count query can be made, where the first parameter has to be preceded by a question mark ? and any following parameter by an ampersand & : HTTP GET request sent to https://api.dasch.swiss/v2/search/count/searchValue[limitToResourceClass=resourceClassIRI][limitToStandoffClass=standoffClassIri][limitToProject=projectIRI][offset=Integer] To combine two search terms with boolean AND the two search terms have to be combined with AND : A AND B For expressing that a query MUST contain the first search term and MAY contain the second search term, the plus sign ( + ; required operator) can be used. +A B Sometimes it may be useful to search for one term that doesn't appear in connection with another term. For such a query, the NOT operator can be used: A NOT B Be aware that a NOT search with only one term is not possible, there have to be two search terms! The minus sign ( - ; prohibit operator) enables to exclude hits that contain the term after the prohibit operator: A -B A short note on the following examples All examples in the following sections are from Bernoulli-Euler-Online (BEOL) which is a research platform for the study of early modern mathematics and science implemented within Knora. Examples of full-text searches Let's assume we intend to search for the term \"Bernoulli\" with and without wildcard options. To send HTTP GET requests you can use a program such as Postman or simply use the Firefox request detail panel or a similar tool in your favorite browser. For HTTP POST requests, a program such as Postman has to be used. The query HTTP GET request sent to https://api.dasch.swiss/v2/search/Bernoulli retrieves all resources containing the term \"Bernoulli\". The beginning of the request result when using Postman and chosing \"JSON\" as output format looks as follows: { \"@graph\": [ { \"@id\": \"http://rdfh.ch/0801/--rbZIzLTNC4qrcpAAkjwA\", \"@type\": \"beol:letter\", \"beol:hasText\": { \"@id\": \"http://rdfh.ch/0801/--rbZIzLTNC4qrcpAAkjwA/values/wiWf4Ta_QX2jYOiRcUNZlQ\", \"@type\": \"knora-api:TextValue\", \"knora-api:arkUrl\": { \"@type\": \"xsd:anyURI\", \"@value\": \"http://ark.dasch.swiss/ark:/72163/1/0801/==rbZIzLTNC4qrcpAAkjwAc/K0Ik_ElfQtOOTkgn4h4MnQQ\" }, We learn that our search term \"Bernoulli\" appears in a letter which belongs to the BEOL project. If we possess the necessary permissions, the web adress given in @value copied to a browser guides us to the corresponding entry of the letter and all of its available additional information in the Knora App. The following query with the URL encoded ( %3F ) wildcard & HTTP GET request sent to https://api.dasch.swiss/v2/search/Bernoull%3F retrieves all resources containing the term \"Bernoulli\" in the same way as in the preceeding example. The wildcard * (URL encoded %2A ) in the following query HTTP GET request sent to https://api.dasch.swiss/v2/search/Bern%2A retrieves all resources containing the term \"Bernoulli\", but would also retrieve hits for e.g. \"Bern\" or \"Bernina\". To search only for the number of hits for the term \"Bernoulli\" the following count query can be used: HTTP GET request sent to https://api.dasch.swiss/v2/search/count/Bernoulli The answer to this query is at the moment \"1989\": { \"schema:numberOfItems\": 1989, \"@context\": { \"schema\": \"http://schema.org/\" } } If we only intend to search within the BEOL project for the term \"Bern*\", we can specify this in our full-text query, but we have to know the projectIRI of the BEOL project which is http://rdfh.ch/projects/yTerZGyxjZVqFMNNKXCDPF1 : HTTP GET request sent to https://api.dasch.swiss/v2/search/Bern%2A?limitToProject=http://rdfh.ch/projects/yTerZGyxjZVqFMNNKXCDPF For the use of wildcards just replace the letter(s) in the search term by one of the wildcards. Be aware that the first parameter after the search term has to be preceded by a question mark ? . However, any following parameter has to be preceded by an ampersamd & ! Thus, a successful request with two parameters looks as follows: HTTP GET request sent to https://api.dasch.swiss/v2/search/Bernoulli?limitToProject=http://rdfh.ch/projects/yTerZGyxjZVqFMNNKXCDPF&offset=1 We added here, that we want to see the second page of the results instead of the first one which is the default value (offset=0). To combine the two search terms \"Bernoulli\" and \"Euler\" the logical operator AND has to be used: HTTP GET request sent to https://api.dasch.swiss/v2/search/Bernoulli%20AND%20Euler For expressing that a query must contain the first search term and may contain the second search term, the required operator + can be used: HTTP GET request sent to https://api.dasch.swiss/v2/search/+Bernoulli%20Euler Here it is required that the search results contain the term \"Bernoulli\", but it is optional that they contain the second term \"Euler\". Sometimes we may be interested in searching for one term that doesn't appear in connection with another term. For such a query, the NOT operator can be used: https://api.dasch.swiss/v2/search/Bernoulli%20NOT%20Euler With this query we are searching for everything that contains Bernoulli, but not Euler. If we want to exclude all search results that contain \"Euler\", the prohibit operator - has to be used: https://api.dasch.swiss/v2/search/Bernoulli%20-Euler Count queries for the above mentioned combinations of the search terms \"Bernoulli\" and \"Euler\" restricted to the BEOL project currently (Dec. 2019) produces the following numbers: |search term|number| |-----|:----:| |Bernoulli|1937| |Euler|1435| |Bernoulli%20AND%20Euler|165| |Bernoulli%20NOT%20Euler|1775| |Bernoulli%20OR%20Euler|3201| |Bernoulli%20Euler|3201| |+Bernoulli%20Euler|1937| |Bernoulli%20-Euler|1775| SPARQL queries SPARQL is a set of specifications that provide languages and protocols to query and manipulate RDF graph content on the Web or in an RDF triplestore. In the following the Turtle data format will be used to show each triple. The following introduction to SPARQL draws heavily on the book of Bob DuCharme, Learning SPARQL. Querying and Updating with SPARQL 1.1, 2nd edition, Sebastopol 2013 which we warmly recommend for reading. The most basic keywords are SELECT and WHERE . Moreover, a very useful keyword is LIMIT . * SELECT names which part of the data we want to see. If all data should be shown, use SELECT * , the asterisk functions as wildcard. * WHERE is used to formulate a clause - it decides which data should be retrieved from the whole dataset. * LIMIT limits the query to the first e.g. 20 ( LIMIT 20 ) or 100 hits. The limit has to be specified outside the curly braces of the WHERE -clause. If you've no idea what the test data are about or if you know that the dataset is large, it's very useful to limit your query in order not to ask too much from the query endpoint. Be aware, that if you're sorting your data, the LIMIT keyword will only apply after all data have been retrieved and sorted! Thus, LIMIT will give you the first results of the sorted data. Query forms In SPARQL four different query forms do exist: SELECT , CONSTRUCT , ASK and DESCRIBE . * The most common one is probably SELECT which enables requesting data from a collection. * Using CONSTRUCT instead will return triples. Triples can be retrieved without modifying them or the retrieved triples can be used to generate new triples. CONSTRUCT enables to copy, create and convert RDF data, and it makes it easier to identify data that do not conform to specific rules. * Using ASK asks the processor whether a certain given graph pattern fits a set of triples in the requested dataset or not. The processor returns a boolean true or false . * DESCRIBE asks for triples which describe a particular resource. This query form isn't popular because different processors return different triples as a description of the named resource. Our knora-api only allows CONSTRUCT requests and a limited set of SPARQL keywords. Thus, the main part of the following examples to illustrate the possibilities of SPARQL use the SPARQL endpoint of Wikipedia called DBpedia accessible at http://dbpedia.org/snorql/. There, the following prefixes are predefined: PREFIX owl: <http://www.w3.org/2002/07/owl#> PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> PREFIX foaf: <http://xmlns.com/foaf/0.1/> PREFIX dc: <http://purl.org/dc/elements/1.1/> PREFIX : <http://dbpedia.org/resource/> PREFIX dbpedia2: <http://dbpedia.org/property/> PREFIX dbpedia: <http://dbpedia.org/> PREFIX skos: <http://www.w3.org/2004/02/skos/core#> Additional prefixes can be defined in the query window before the SELECT statement, e.g. PREFIX knora-api: <https://api.dasch.swiss/ontology/knora-api/v2#> A query asking for all data If we have no idea what our data is all about, a nice first query is the following - but don't forget to set a limit because it asks for all the triples in the dataset! Using your local Knora installation Go to http://0.0.0.0:7200/sparql in your browser which will guide you to the GraphDB SPARQL Query & Update page if you've Knora installed locally. Copy the following code into the window: PREFIX knora-api: <https://api.dasch.swiss/ontology/knora-api/v2#> select * where { ?s ?p ?o . } limit 100 This query retrieves the first 100 triples of the data. The asterisk after SELECT indicates that all variables should be selected to get bound in this query. Setting a limit with the keyword LIMIT prevents a server timeout. Using Postman and HTTP POST If you haven't installed Knora locally or if you want to run the same query on our live-server, you'll see that this query isn't allowed because it's supposed to be too broad to be meaningful. Additionally, the query has to be adapted because only CONSTRUCT queries are allowed, the main resource has to be named and the keyword LIMIT is not supported. Remember, that all variables in the CONSTRUCT must appear also in the WHERE -clause! Open Postman and chose HTTP POST sent to https://api.dasch.swiss/v2/searchextended Then click \"Body\" and chose \"raw\". Theoretically, the adapted query asking for all resources in Knora would look like the following: PREFIX knora-api: <http://api.knora.org/ontology/knora-api/simple/v2#> CONSTRUCT { ?s knora-api:isMainResource true . } WHERE { ?s a knora-api:Resource . } This is a syntactically correct query, but it returns no results due to access limitations. However, we can ask for all resources of a certain kind, e.g. for all who are a foaf:Person : PREFIX knora-api: <http://api.knora.org/ontology/knora-api/simple/v2#> PREFIX foaf: <http://xmlns.com/foaf/0.1/> CONSTRUCT { ?s knora-api:isMainResource true . } WHERE { ?s a knora-api:Resource . ?s a foaf:Person . } If you do a count search, i.e. sending a POST request to https://api.dasch.swiss/v2/searchextended/search , you retrieve 2643 results at the moment. A query asking for one specific variable If we are interested in works of the artist Marc Chagall, we can send a first query to the DBpedia endpoint, asking for information about Chagall with results stored in the variable ?artist : SELECT ?artist WHERE { <http://dbpedia.org/resource/Chagall> ?p ?artist . } The angle brackets surrounding \"http://dbpedia.org/resource/Chagall\" tell the processor that it is an URI. The query retrieves the following results in tabular form (if the simple output format \"Browse\" is chosen): |artist| |-----| |\"Chagall\"@en| |158693| |600433204| |:Marc_Chagall link | | http://en.wikipedia.org/wiki/Chagall link | | http://en.wikipedia.org/wiki/Chagall?oldid=600433204 link | After having verified in this way that http://dbpedia.org/resource/Chagall is a valid URI, we can ask for properties and values with the following query: SELECT ?property ?hasValue WHERE { <http://dbpedia.org/resource/Marc_Chagall> ?property ?hasValue . } One of the results obtained is a property dbpedia:ontology/wikiPageExternalLink with the value \"<http://www.thejewishmuseum.org/collection/search?artist=Marc%20Chagall%2C%20French%2C%20b.%20Belorussia%2C%201887-1985> . Following this link leads us to the homepage of the Jewish Museum in New York and the works of Marc Chagall the museum possesses. If you intend to query data that isn't stored locally, the keyword FROM could be used to specify the data set. It is also possible to read data from a file when using the FROM keyword. If the data are stored in a file named example.ttl stored in the same folder as the query itself, then the SELECT -part of the request looks as follows: SELECT * <example.ttl> WHERE { ... } A query with matching on multiple triples The following query uses a ?films variable to tie together two triple patterns in the WHERE -clause. SELECT ?films WHERE { ?films <http://dbpedia.org/ontology/starring> :Iggy_Pop . ?films <http://dbpedia.org/ontology/starring> :Johnny_Depp . } Such a set of triple patterns within curly braces is called a graph pattern . The ?films variable is used in two different triples to find connected triples in the queried data. The first triple looks for films starring Iggy Pop, the second triple then searches if in one of these films also Johnny Depp was involved. The result shows all the films these actors played in together: Cry Baby and Dead Man. Searching for strings and values The keyword FILTER tells the query processor to return only those triples which meet the given condition in the filter. This time we're searching for films starring David Bowie, but only those which have a runtime longer than 89 minutes. SELECT ?BowieFilm ?runtime WHERE { ?BowieFilm <http://dbpedia.org/ontology/starring> :David_Bowie . ?BowieFilm <http://dbpedia.org/ontology/Work/runtime> ?runtime . FILTER (xsd:double(?runtime) > 89.0 ) } ORDER BY xsd:double(?runtime) The keyword ORDER BY allows to sort the results with runtime in increasing order. Be aware that it is necessary to specify the datatype xsd:double of the ?runtime variable, otherwise the filter and also the sorting doesn't work properly! Searching for data that may exist or not The keyword OPTIONAL can be used to express \"show this value if it exists\". SELECT * WHERE { <http://dbpedia.org/resource/Pink_Floyd> <http://dbpedia.org/ontology/formerBandMember> ?members . OPTIONAL { ?members <http://dbpedia.org/ontology/deathDate> ?deathDate . } } The above query asks for the former members of the band Pink Floyd and for their death date if they passed away already. If they still enjoy their life, their names are listed anyway since the additional information about the death date is set in an OPTIONAL graph pattern. If there is more than one OPTIONAL triple pattern, they are processed in the order the processor sees them. Hence, the order of OPTIONAL patterns matters - this fact can be taken advantage of. However, excessive use of the keyword OPTIONAL can slow down the queries when dealing with large datasets! Searching for data that doesn't meet a condition While cleaning up data it is very useful if one can search for missing entries. FILTER NOT EXISTS is a filter condition that returns a boolean value true if the specified graph pattern doesn't exist. SELECT * WHERE { ?artist rdf:type <http://dbpedia.org/ontology/Artist> . FILTER NOT EXISTS {?artist dbpedia2:works ?works } } LIMIT 1000 When searching dbpedia data I realised that the information provided for different artists isn't very consistent. If we would intend to homogenise the basic information given for each artist we could use the above query to identify those for which the basic information about at least some of their works is still missing. Another possibility is to use the keyword MINUS . As its name suggests, it subtracts from a group A all those which satisfy the condition. The last query using the keyword MINUS looks as follows: SELECT * WHERE { ?artist rdf:type <http://dbpedia.org/ontology/Artist> . MINUS {?artist dbpedia2:works ?works } } LIMIT 1000 Be aware that FILTER NOT EXISTS and MINUS may return different results! A joined search To link up different sets of data the same variable can be in the object position in one triple and in the subject position of another triple as in the following example: SELECT DISTINCT ?actor ?value WHERE { ?film <http://dbpedia.org/ontology/starring> ?actor . ?actor <http://dbpedia.org/ontology/birthYear> ?value . } LIMIT 1000 In this query with the first triple we ask for all actors, in the second triple for the birth dates of the actors. The DISTINCT keyword tells the processor that duplicate answers shouldn't be displayed, thus, redundant results are eliminated. Without the DISTINCT keyword we would receive lots of identical responses since most actors played in more than one film. Whether the queried data stem from the same repository or from different ones doesn't matter as long there are resource URIs in one dataset that can be paralleled with resource URIs in another. Asking about patterns Property paths are a way to express more extensive patterns to look for. They provide a possibility to search for the requested data and in addition to that keep looking for more data. An example where this may be useful is the citation pattern of a certain paper. By simply adding a + sign we can tell the query processor to look for papers that cite paper A, and papers that cite those, etc. until the tree of papers is finished. The plus sign means \"one or more\". One could use an asterisk instead, which means \"zero or more\". It is also possible to be much more specific by using a property path which asks for papers that are exactly three links away, i.e. papers that cited papers that cited papers that cited paper A. This is laid out by a a series of steps separated by slashes. The WHERE -clauses of such queries could look like as follows: WHERE -clause meaning WHERE {?s :cites :paperA .} papers that cited paper A. WHERE {?s :cites+ :paperA .} one or more links away: papers that cited paper A, and papers that cited those, and papers that cited those, etc. WHERE {?s :cites* :paperA .} zero or more links away: papers that cited paper A, and papers that cited those, and papers that cited those, etc. WHERE {?s :cites/:cites/:cites :paperA .} three links away: papers that cited papers that cited paper A. Property paths are powerful to ask about patterns in all kinds of datasets. They are also very useful to cope with data which has been prepared or published with differing naming conventions. One such specific example is if we're interested in the total population of the British Islands: CONSTRUCT { ?country <http://dbpedia.org/ontology/populationTotal> ?pop } WHERE { VALUES ?country { :England :Scotland :Wales :Northern_Ireland :Ireland } ?country <http://dbpedia.org/property/populationCensus> | <http://dbpedia.org/ontology/populationTotal> ?pop . } For all countries except Ireland the corresponding number is returned when asking for <http://dbpedia.org/property/populationCensus> . To find Ireland's population we need to use another predicate, namely <http://dbpedia.org/ontology/populationTotal> . Use of the so-called alternative property path | as in the above example allows searching for both options at the same time. Furthermore, using CONSTRUCT instead of SELECT enables to connect each country to its population with <http://dbpedia.org/ontology/populationTotal> , thus returning consistent triples! Combining search conditions The UNION keyword allows to specify multiple different graph pattern and to ask for a combination of all the data which fit any of these patterns. No connection between the sets of data need to be specified. However, probably it is more useful to use UNION for retrieving two overlapping sets of data. SELECT * WHERE { {?artist rdf:type <http://dbpedia.org/ontology/Artist> . ?artist <http://dbpedia.org/ontology/birthPlace> <http://dbpedia.org/resource/Russia> . ?artist <http://dbpedia.org/ontology/deathPlace> <http://dbpedia.org/resource/Paris> . } UNION {?artist rdf:type <http://dbpedia.org/ontology/Artist> . ?artist <http://dbpedia.org/ontology/deathPlace> <http://dbpedia.org/resource/Saint-Paul-de-Vence> . } } The above query asks for all artists that were born in Russia and died in Paris and for all those artists who died in St. Paul de Vence. Filtering data The keyword FILTER takes a single argument and it is used to retrieve those triples that match the filter argument. The filter argument can contain strings, a function or a simple comparison. Here are a few examples of filter arguments and the corresponding queries: Filter argument Meaning FILTER (regex(?o, \"Leiden\",\"i\")) searches in the ?o value for the substring \"Leiden\", the \"i\" means case insensitivity. FILTER (?o < 10) searches for all items with ?o values of less than 10. FILTER (!(isURI(?city))) returns a boolean true if the value for ?city isn't a proper URI, the ! means \"not\". SELECT * WHERE { ?s rdfs:label ?o . FILTER (regex(?o, \"Leiden\",\"i\")) } LIMIT 1000 SELECT DISTINCT ?actor ?year WHERE { ?film <http://dbpedia.org/ontology/starring> ?actor . ?actor <http://dbpedia.org/ontology/birthDate> ?year . FILTER (xsd:date(?year) > \"1980-01-01\"^^xsd:date) } LIMIT 1000 Be aware that it is necessary to specify the datatype xsd:date of the ?year variable, otherwise the filter doesn't work properly. SELECT * WHERE { <http://dbpedia.org/resource/Leiden> a ?o . FILTER (!(isURI(?o))) } This query retrieves no results since all values for ?o for the city of Leiden in dbpedia are proper URIs. Skip a number of results The OFFSET keyword can be used to tell the processor to skip a certain number of search results before picking those to return. This is useful for paging. Just type OFFSET and an integer number (e.g. OFFSET 5 ) after the last closing curly brace of the query. Subqueries Subqueries are queries inside queries. With the help of subqueries a complex query can be broken down into easier manageable parts. Each subquery must be enclosed in its own set of curly braces. SELECT ?capital ?latitude WHERE { { SELECT ?capital WHERE { ?capital ?p <http://dbpedia.org/resource/Category:Capitals_in_Europe> . } } { SELECT * WHERE { ?capital <http://dbpedia.org/property/latd> ?latitude . FILTER (?latitude < 52.0)} } } ORDER BY DESC(?latitude) This query first asks for all capital cities of Europe. The subquery then retrieves the corresponding geographical latitudes and filters out all of them with latitudes larger than 52.0\u00b0. Finally, the results are sorted in decreasing order of geographical latitude. Storing results in variables The AS keyword can be used to store the query result in a variable. SELECT (SUM(?height) AS ?total) WHERE { ?skyscrapers <http://purl.org/dc/terms/subject> <http://dbpedia.org/resource/Category:Skyscrapers_in_Manhattan> . ?skyscrapers <http://dbpedia.org/ontology/height> ?height . } The above example asks for the heights of all skyscrapers in Manhattan, the sum of all their heights is calculated and then stored in the variable ?total . The SUM() function adds up all values. If we're not interested in the sum of the heights of the skyscrapers in Manhattan, but rather in the tallest, the shortest or the average value, the functions MAX() , MIN() or AVG() can be used - they enable to find the maximum, minmum or the average value. Just replace SUM in the query by MAX , MIN or AVG . A more common way of assigning a value to a variable is with the keyword BIND . Arithmetic expressions can be used when a new value is created with the help of the keyword BIND : + for addition, - for subtraction, * for multiplication and / for division. SELECT ?elmax ?elmin ?eldiff WHERE { <http://dbpedia.org/resource/Rouffignac> <http://dbpedia.org/ontology/maximumElevation> ?elmax . <http://dbpedia.org/resource/Rouffignac> <http://dbpedia.org/ontology/minimumElevation> ?elmin . BIND (?elmax - ?elmin AS ?eldiff) } We asked for the maximum and minimum elevation of the cave of Rouffignac, calculated the elevation difference and stored it in a variable ?eldiff with the help of the keyword BIND . Sorting The keyword ORDER BY enables the sorting of data. Values can e.g. be sorted in ascending or descending order - the ascending order is the default, for a descending order the sort key has to be wrapped in the DESC() function. SELECT ?BowieFilm ?runtime WHERE { ?BowieFilm <http://dbpedia.org/ontology/starring> :David_Bowie . ?BowieFilm <http://dbpedia.org/ontology/Work/runtime> ?runtime . } ORDER BY DESC(xsd:double(?runtime)) This example is almost identical to the one in the section \"Searching for strings and values\", but we eliminated the filter and now we list all films in decreasing order of runtime. Be aware that it is necessary to specify the datatype xsd:double of the ?runtime variable, otherwise the filter and also the sorting doesn't work properly! Sorting on multiple keys is possible if the key value names are separated by spaces: SELECT ?height ?floors WHERE { ?skyscrapers <http://purl.org/dc/terms/subject> <http://dbpedia.org/resource/Category:Skyscrapers_in_Manhattan> . ?skyscrapers <http://dbpedia.org/ontology/height> ?height . ?skyscrapers <http://dbpedia.org/ontology/floorCount> ?floors . } ORDER BY DESC(?floors) DESC(?height) This query returns all skyscrapers of Manhattan sorted by their number of floors and in the second place by their height. Querying a remote endpoint The SERVICE keyword provides a possibility to query remote data from a distant SPARQL endpoint. The usual way to formulate such a query is the following with an outer SELECT or CONSTRUCT indicating which values we're interested in: PREFIX xy: <http://your.external.querypoint> SELECT ?p ?o WHERE { SERVICE <http://your.external.querypoint/sparql> {xy:Person_XY ?p ?o} } However, the SPARQL Explorer for DBpedia doesn't allow such queries to external query points. Such requests have to be sent with e.g. python scripts - see section \"Python example scripts\". Queries using CONSTRUCT In contrast to a SELECT query, a CONSTRUCT query specifies a triple to create with each set of values that got bound to the three variables while it has the same graph pattern following the WHERE keyword. Thus, the following SELECT version of a query asking for all information - subjects, predicates and objects of all triples - in DBpedia where the same subject has a foaf:givenName value of \"Peter\" and a foaf:surname value of \"Morris\" SELECT ?person ?p ?o WHERE { ?person <http://xmlns.com/foaf/0.1/givenName> \"Peter\"@en ; <http://xmlns.com/foaf/0.1/surname> \"Morris\"@en ; ?p ?o . } corresponds to the following CONSTRUCT version: CONSTRUCT { ?person ?p ?o . } WHERE { ?person <http://xmlns.com/foaf/0.1/givenName> \"Peter\"@en ; <http://xmlns.com/foaf/0.1/surname> \"Morris\"@en ; ?p ?o . } Query efficiency Sometimes there are different possibilities for a query to ask for the same set of information which differ in efficiency. The heart of any query is the WHERE -clause and the order of its components and the functions it calls can speed things up or slow them down. Although the order of a graph pattern's triple in a WHERE -clause does not effect the query results, the ordering may have a huge effect on the speed of the query's execution. Here are a few rules of thumb one should keep in mind: * You can speed up your searches if you reduce the search space as much as possible as soon as possible. * The keywort OPTIONAL will very likely slow your query down considerably. The best optimization is to avoid the use of OPTIONAL whenever possible. * Also the order of triple pattern influences the execution time. The fewer triples a triple pattern matches against the more it narrows down the search space and hence the faster the query processor will finish its job. Usually, a triple pattern with more unbound variables will match against more triples than a triple pattern with less unbound variables. Furthermore, the variable's position in the triple matters: a given dataset is more likely to have the same property in the predicate position of a large number of triples than in the subject position. * Moving a FILTER statement earlier can help to reduce the serach space as long as all variables referenced in the FILTER statement have already been bound. * The use of property paths can be expensive in terms of execution time. Outside the WHERE -clause the following points should be kept in mind: * Naming fewer variables in the SELECT statement can make the query run faster. * Sorting of the returned values with ORDER BY costs some time. SPARQL Query Result Formats The retrieved results can usually be returned in different formats, suitable for the different needs of different target groups. Standardized formats are: E x tensible M arkup L anguage (XML), J ava S cript O bject N otation (JSON), C omma- S eparated V alue (CSV) and T abular- S eparated V alue (TSV). These formats do not only differ in the syntax used to represent the query results, but also in the amount of metadata provided with the results. For our purposes especially the XML and the JSON formats are useful. SPARQL Query Result XML Format The SPARQL query result XML format describes a standard XML format for returning the results of a SPARQL query. The structure of a returned XML document is as follows: * The document element is called sparql and it has two child elements - the head element lists the selected variable names and the results element contains the actual results. * The returned results are stored in result children of the results element with a binding child for each bound variable. SPARQL Query Result JSON Format A JSON object is defined as \u201can unordered collection of zero or more name-value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array.\u201d The syntax is as follows: * Objects are in curly braces. * A name-value pair is separated by a colon. The name has to be unique within an object. * A list of name-value pairs is delimited by commas. * Arrays are in square braces. The results of a SELECT query in JSON format are a table. The uppermost JSON object has two name-value pairs head and results - both have an object as their values. The variables the SELECT query asked for a stored in the vars value of the head object. The most important part of the results element is its bindings object. Each object in the bindings array has a name-value pair for each requested variable. Python example scripts If you have Python 3 installed on your computer the following SPARQL query can be stored in a file testxml.py and run from the directory where the file is stored with the command python testxml.py . We query the dbpedia SPARQL endpoint for the ID of Jakob Bernoulli and return the result in XML format. # Send SPARQL query to dbpedia SPARQL endpoint, store and output result in XML format. import urllib.request endpointURL = \"http://dbpedia.org/sparql\" query = \"\"\" SELECT ?bernoulliID WHERE { <http://dbpedia.org/resource/Jakob_Bernoulli> <http://dbpedia.org/ontology/wikiPageID> ?bernoulliID . } \"\"\" escapedQuery = urllib.parse.quote(query) requestURL = endpointURL + \"?query=\" + escapedQuery request = urllib.request.Request(requestURL) result = urllib.request.urlopen(request) print (result.read()) The output in XML format looks as follows: <sparql xmlns=\"http://www.w3.org/2005/sparql-results#\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.w3.org/2001/sw/DataAccess/rf1/result2.xsd\"> <head> <variable name=\"bernoulliID\"/> </head> <results distinct=\"false\" ordered=\"true\"> <result> <binding name=\"bernoulliID\"> <literal datatype=\"http://www.w3.org/2001/XMLSchema#integer\">7500054</literal> </binding> </result> </results> </sparql> We are told that the bound variable is named \"bernoulliID\" and we receive the information that the questioned ID is a literal value, namely the integer 7500054. The following SPARQL query can be stored in a file testjson.py and run from the directory where the file is stored with the command python testjson.py . We query the dbpedia SPARQL endpoint for the labels of the resource \"Switzerland\" and return the result in JSON format. # Query dbpedia SPARQL endpoint about labels of resource Switzerland from SPARQLWrapper import SPARQLWrapper, JSON sparql = SPARQLWrapper(\"http://dbpedia.org/sparql\") sparql.setQuery(\"\"\" PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> SELECT ?label WHERE { <http://dbpedia.org/resource/Switzerland> rdfs:label ?label } \"\"\") sparql.setReturnFormat(JSON) results = sparql.query().convert() if (len(results[\"results\"][\"bindings\"]) == 0): print (\"No results found.\") else: for result in results[\"results\"][\"bindings\"]: print(result[\"label\"][\"value\"]) The output in JSON format looks as follows: Switzerland \u0633\u0648\u064a\u0633\u0631\u0627 Schweiz Suiza Suisse Svizzera \u30b9\u30a4\u30b9 Zwitserland Szwajcaria Su\u00ed\u00e7a \u0428\u0432\u0435\u0439\u0446\u0430\u0440\u0438\u044f \u745e\u58eb Thus, the result is presented in list form. Different ways to send queries As we've seen in the last paragraph, SPARQL queries can be stored in a file and run from the command line with e.g. Python. However, there are other ways to send your query and the resulting output will differ slightly, depending on which way you chose. Here are a few examples if we query the dbpedia SPARQL endpoint about labels of the resource Switzerland as in the python example in the last paragraph. If the query part of the script SELECT ?label WHERE { <http://dbpedia.org/resource/Switzerland> rdfs:label ?label . } is directly copied into the query text box of the Virtuoso SPARQL Query Editor at http://dbpedia.org/sparql and the results format is chosen as \"JSON\", the output looks as follows: head: link: [] vars: 0: \"label\" results: distinct: false ordered: true bindings: 0: label: type: \"literal\" xml:lang: \"en\" value: \"Switzerland\" 1: label: type: \"literal\" xml:lang: \"ar\" value: \"\u0633\u0648\u064a\u0633\u0631\u0627\" 2: label: type: \"literal\" xml:lang: \"de\" value: \"Schweiz\" 3: label: type: \"literal\" xml:lang: \"es\" value: \"Suiza\" 4: label: type: \"literal\" xml:lang: \"fr\" value: \"Suisse\" 5: label: type: \"literal\" xml:lang: \"it\" value: \"Svizzera\" 6: label: type: \"literal\" xml:lang: \"ja\" value: \"\u30b9\u30a4\u30b9\" 7: label: type: \"literal\" xml:lang: \"nl\" value: \"Zwitserland\" 8: label: type: \"literal\" xml:lang: \"pl\" value: \"Szwajcaria\" 9: label: type: \"literal\" xml:lang: \"pt\" value: \"Su\u00ed\u00e7a\" 10: label: type: \"literal\" xml:lang: \"ru\" value: \"\u0428\u0432\u0435\u0439\u0446\u0430\u0440\u0438\u044f\" 11: label: type: \"literal\" xml:lang: \"zh\" value: \"\u745e\u58eb\" Another possibility to retrieve the result of the same query is to send the whole query URL encoded via your browser. To URL encode your query, you can use a tool such as URL Decode and Encode : http://dbpedia.org/sparql?query=SELECT%20%3Flabel%20WHERE%20%7B%20%0A%3Chttp%3A%2F%2Fdbpedia.org%2Fresource%2FSwitzerland%3E%20rdfs%3Alabel%20%3Flabel%20.%0A%7D The result will be a table with included language tabs in HTML format: label \"Switzerland\"@en \"\u0633\u0648\u064a\u0633\u0631\u0627\"@ar \"Schweiz\"@de \"Suiza\"@es \"Suisse\"@fr \"Svizzera\"@it \"\u30b9\u30a4\u30b9\"@ja \"Zwitserland\"@nl \"Szwajcaria\"@pl \"Su\u00ed\u00e7a\"@pt \"\u0428\u0432\u0435\u0439\u0446\u0430\u0440\u0438\u044f\"@ru \"\u745e\u58eb\"@zh Or you can send the whole query URL encoded as HTTP GET request using e.g. Postman: HTTP GET sent to http://dbpedia.org/sparql?query=SELECT%20%3Flabel%20WHERE%20%7B%20%0A%3Chttp%3A%2F%2Fdbpedia.org%2Fresource%2FSwitzerland%3E%20rdfs%3Alabel%20%3Flabel%20.%0A%7D This retrieves the following result in JSON format: <sparql xmlns=\"http://www.w3.org/2005/sparql-results#\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.w3.org/2001/sw/DataAccess/rf1/result2.xsd\"> <head> <variable name=\"label\"/> </head> <results distinct=\"false\" ordered=\"true\"> <result> <binding name=\"label\"><literal xml:lang=\"en\">Switzerland</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"ar\">\u0633\u0648\u064a\u0633\u0631\u0627</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"de\">Schweiz</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"es\">Suiza</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"fr\">Suisse</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"it\">Svizzera</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"ja\">\u30b9\u30a4\u30b9</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"nl\">Zwitserland</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"pl\">Szwajcaria</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"pt\">Su\u00ed\u00e7a</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"ru\">\u0428\u0432\u0435\u0439\u0446\u0430\u0440\u0438\u044f</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"zh\">\u745e\u58eb</literal></binding> </result> </results> </sparql> Gravsearch queries Gravsearch is a query language which is able to perform queries with complex search criteria that work well in terms of perforance and security. Furthermore, it enables clients to work with a simpler RDF data model than the one Knora actually uses to store data in the triplestore, and it permits to provide better error-checking than SPARQL. A Gravsearch query isn't being processed directly by the triplestore. Instead, the query is interpreted by Knora, which enforces certain restrictions on the query, implements paging and permission checking. The API server then generates a SPARQL query based on the submitted Gravsearch query, queries the triplestore, filters the results according to the user\u2019s permissions, and returns each page of query results as a Knora API response. Thus, Gravsearch is a hybrid between a RESTful API and a SPARQL endpoint. A Gravsearch query conforms to a subset of the syntax of a SPARQL CONSTRUCT query, with some additional restrictions and functionality. In particular, the variable representing the top-level (or \u2018main\u2019) resource that will appear in each search result must be identified, statements must be included to specify the types of the entities being queried, OFFSET is used to control paging, and ORDER BY is used to sort the results. The current version of Gravsearch accepts CONSTRUCT queries whose WHERE -clauses use the following patterns, with the specified restrictions: OPTIONAL : cannot be nested in a UNION . UNION : cannot be nested in a UNION . FILTER : may contain a complex expression using the Boolean operators AND (&&) and OR (||), as well as comparison operators. The left argument of a comparison operator must be a query variable. A Knora ontology entity IRI used in a FILTER must be a property IRI. FILTER NOT EXISTS MINUS OFFSET : the OFFSET is needed for paging. It does not actually refer to the number of triples to be returned, but to the requested page of results. The default value is 0, which refers to the first page of results. The number of results per page is defined in app/v2 in application.conf . ORDER BY : In SPARQL, the result of a CONSTRUCT query is an unordered set of triples. However, a Gravsearch query returns an ordered list of resources, which can be ordered by the values of specified properties. If the query is written in the complex schema, items below the level of Knora values may not be used in ORDER BY . BIND : The value assigned must be a Knora resource IRI. Gravsearch query examples To send queries to our live-server it is easiest to use the program Postman. You have to chose the method POST . Open Postman and type HTTP POST sent to https://api.dasch.swiss/v2/searchextended Then click \"Body\" and chose \"raw\". You can then write your queries in the window before sending your request. Be aware, that only CONSTRUCT requests are supported by knora-api . Here is one query examples, more will follow. PREFIX beol: <http://api.dasch.swiss/ontology/0801/beol/simple/v2#> PREFIX knora-api: <http://api.knora.org/ontology/knora-api/simple/v2#> CONSTRUCT { ?letter knora-api:isMainResource true . ?letter beol:creationDate ?date . ?letter ?linkingProp1 ?person1 . ?letter ?linkingProp2 ?person2 . } WHERE { ?letter a knora-api:Resource . ?letter a beol:letter . ?letter beol:letterHasTranslation ?translation . beol:letterHasTranslation knora-api:objectType knora-api:Resource . ?translation a knora-api:Resource . ?letter beol:creationDate ?date . beol:creationDate knora-api:objectType knora-api:Date . ?date a knora-api:Date . ?letter ?linkingProp1 ?person1 . ?linkingProp1 knora-api:objectType knora-api:Resource . FILTER(?linkingProp1 = beol:hasAuthor || ?linkingProp1 = beol:hasRecipient ) ?person1 a beol:person . ?person1 a knora-api:Resource . ?person1 beol:hasIAFIdentifier ?gnd1 . FILTER(?gnd1 = \"(DE-588)116610832\") ?gnd1 a xsd:string . ?letter ?linkingProp2 ?person2 . ?linkingProp2 knora-api:objectType knora-api:Resource . FILTER(?linkingProp2 = beol:hasAuthor || ?linkingProp2 = beol:hasRecipient ) ?person2 a beol:person . ?person2 a knora-api:Resource . ?person2 beol:hasIAFIdentifier ?gnd2 . FILTER(?gnd2 = \"(DE-588)118696149\") ?gnd2 a xsd:string . beol:hasIAFIdentifier knora-api:objectType xsd:string . } ORDER BY ?date OFFSET 0","title":"Queries"},{"location":"developers/knora/api-reference/queries/#how-to-build-queries","text":"The simplest form of a query is a full-text search. For more complex queries than a full-text search, Knora offers a special query language called Gravsearch which is based on the query language SPARQL ( S PARQL P rotocol A nd R DF Q uery L anguage).","title":"How to build queries"},{"location":"developers/knora/api-reference/queries/#full-text-search","text":"Knora offers a full-text search that searches all textual representations of values and rdfs:label -labels of resources. The full-text search supports the Lucene Query Parser syntax . Search terms can be seperated by a white space - then they will be combined using the Boolean operator OR since this is Lucene's default operator. Be aware, that the search terms have to be URL encoded! The recommended way to submit a full-text query is via HTTP GET in the following form. HTTP GET request sent to https://api.dasch.swiss/v2/search/searchValue[limitToResourceClass=resourceClassIRI][limitToStandoffClass=standoffClassIri][limitToProject=projectIRI][offset=Integer] Most of these parameters can be set optionally: * limitToResourceClass=resourceClassIRI : this restricts the search to resources of the specified resource class and its subclasses. * LimitToStandoffClass=standoffClassIRI : this will force Knora to look for search terms that are marked up with the indicated standoff class. * limitToProject=projectIRI : this restricts the search to resources of the specified project. * offset=Integer : this parameter can be used to enable paging and to go through all the results request by request. The default value for the parameter offset is 0 which will return the first page of search results. Subsequent pages can be retrieved by increasing the parameter offset by one. This means, offset=1 fetches the second page of serach results, offset=2 the third, and so on. The amount of retrieved search results per page is defined in app/v2 in the file application.conf . The first search parameter has to be preceded by a question mark ? and any following parameter by an ampersand & . A search value must have a minimal length of three characters (default value) as defined in app/v2 in the file application.conf . Wildcards may be used. * An ampersand & represents a single missing character. However, it has to be URL encoded as %3F because it has a special meaning in the URL syntax. * An asterisk * represents zero, one or multiple missing characters. The URL encode of an asterisk is %2A . To request the number of results rather than the results themselves, a count query can be made, where the first parameter has to be preceded by a question mark ? and any following parameter by an ampersand & : HTTP GET request sent to https://api.dasch.swiss/v2/search/count/searchValue[limitToResourceClass=resourceClassIRI][limitToStandoffClass=standoffClassIri][limitToProject=projectIRI][offset=Integer] To combine two search terms with boolean AND the two search terms have to be combined with AND : A AND B For expressing that a query MUST contain the first search term and MAY contain the second search term, the plus sign ( + ; required operator) can be used. +A B Sometimes it may be useful to search for one term that doesn't appear in connection with another term. For such a query, the NOT operator can be used: A NOT B Be aware that a NOT search with only one term is not possible, there have to be two search terms! The minus sign ( - ; prohibit operator) enables to exclude hits that contain the term after the prohibit operator: A -B","title":"Full-text search"},{"location":"developers/knora/api-reference/queries/#a-short-note-on-the-following-examples","text":"All examples in the following sections are from Bernoulli-Euler-Online (BEOL) which is a research platform for the study of early modern mathematics and science implemented within Knora.","title":"A short note on the following examples"},{"location":"developers/knora/api-reference/queries/#examples-of-full-text-searches","text":"Let's assume we intend to search for the term \"Bernoulli\" with and without wildcard options. To send HTTP GET requests you can use a program such as Postman or simply use the Firefox request detail panel or a similar tool in your favorite browser. For HTTP POST requests, a program such as Postman has to be used. The query HTTP GET request sent to https://api.dasch.swiss/v2/search/Bernoulli retrieves all resources containing the term \"Bernoulli\". The beginning of the request result when using Postman and chosing \"JSON\" as output format looks as follows: { \"@graph\": [ { \"@id\": \"http://rdfh.ch/0801/--rbZIzLTNC4qrcpAAkjwA\", \"@type\": \"beol:letter\", \"beol:hasText\": { \"@id\": \"http://rdfh.ch/0801/--rbZIzLTNC4qrcpAAkjwA/values/wiWf4Ta_QX2jYOiRcUNZlQ\", \"@type\": \"knora-api:TextValue\", \"knora-api:arkUrl\": { \"@type\": \"xsd:anyURI\", \"@value\": \"http://ark.dasch.swiss/ark:/72163/1/0801/==rbZIzLTNC4qrcpAAkjwAc/K0Ik_ElfQtOOTkgn4h4MnQQ\" }, We learn that our search term \"Bernoulli\" appears in a letter which belongs to the BEOL project. If we possess the necessary permissions, the web adress given in @value copied to a browser guides us to the corresponding entry of the letter and all of its available additional information in the Knora App. The following query with the URL encoded ( %3F ) wildcard & HTTP GET request sent to https://api.dasch.swiss/v2/search/Bernoull%3F retrieves all resources containing the term \"Bernoulli\" in the same way as in the preceeding example. The wildcard * (URL encoded %2A ) in the following query HTTP GET request sent to https://api.dasch.swiss/v2/search/Bern%2A retrieves all resources containing the term \"Bernoulli\", but would also retrieve hits for e.g. \"Bern\" or \"Bernina\". To search only for the number of hits for the term \"Bernoulli\" the following count query can be used: HTTP GET request sent to https://api.dasch.swiss/v2/search/count/Bernoulli The answer to this query is at the moment \"1989\": { \"schema:numberOfItems\": 1989, \"@context\": { \"schema\": \"http://schema.org/\" } } If we only intend to search within the BEOL project for the term \"Bern*\", we can specify this in our full-text query, but we have to know the projectIRI of the BEOL project which is http://rdfh.ch/projects/yTerZGyxjZVqFMNNKXCDPF1 : HTTP GET request sent to https://api.dasch.swiss/v2/search/Bern%2A?limitToProject=http://rdfh.ch/projects/yTerZGyxjZVqFMNNKXCDPF For the use of wildcards just replace the letter(s) in the search term by one of the wildcards. Be aware that the first parameter after the search term has to be preceded by a question mark ? . However, any following parameter has to be preceded by an ampersamd & ! Thus, a successful request with two parameters looks as follows: HTTP GET request sent to https://api.dasch.swiss/v2/search/Bernoulli?limitToProject=http://rdfh.ch/projects/yTerZGyxjZVqFMNNKXCDPF&offset=1 We added here, that we want to see the second page of the results instead of the first one which is the default value (offset=0). To combine the two search terms \"Bernoulli\" and \"Euler\" the logical operator AND has to be used: HTTP GET request sent to https://api.dasch.swiss/v2/search/Bernoulli%20AND%20Euler For expressing that a query must contain the first search term and may contain the second search term, the required operator + can be used: HTTP GET request sent to https://api.dasch.swiss/v2/search/+Bernoulli%20Euler Here it is required that the search results contain the term \"Bernoulli\", but it is optional that they contain the second term \"Euler\". Sometimes we may be interested in searching for one term that doesn't appear in connection with another term. For such a query, the NOT operator can be used: https://api.dasch.swiss/v2/search/Bernoulli%20NOT%20Euler With this query we are searching for everything that contains Bernoulli, but not Euler. If we want to exclude all search results that contain \"Euler\", the prohibit operator - has to be used: https://api.dasch.swiss/v2/search/Bernoulli%20-Euler Count queries for the above mentioned combinations of the search terms \"Bernoulli\" and \"Euler\" restricted to the BEOL project currently (Dec. 2019) produces the following numbers: |search term|number| |-----|:----:| |Bernoulli|1937| |Euler|1435| |Bernoulli%20AND%20Euler|165| |Bernoulli%20NOT%20Euler|1775| |Bernoulli%20OR%20Euler|3201| |Bernoulli%20Euler|3201| |+Bernoulli%20Euler|1937| |Bernoulli%20-Euler|1775|","title":"Examples of full-text searches"},{"location":"developers/knora/api-reference/queries/#sparql-queries","text":"SPARQL is a set of specifications that provide languages and protocols to query and manipulate RDF graph content on the Web or in an RDF triplestore. In the following the Turtle data format will be used to show each triple. The following introduction to SPARQL draws heavily on the book of Bob DuCharme, Learning SPARQL. Querying and Updating with SPARQL 1.1, 2nd edition, Sebastopol 2013 which we warmly recommend for reading. The most basic keywords are SELECT and WHERE . Moreover, a very useful keyword is LIMIT . * SELECT names which part of the data we want to see. If all data should be shown, use SELECT * , the asterisk functions as wildcard. * WHERE is used to formulate a clause - it decides which data should be retrieved from the whole dataset. * LIMIT limits the query to the first e.g. 20 ( LIMIT 20 ) or 100 hits. The limit has to be specified outside the curly braces of the WHERE -clause. If you've no idea what the test data are about or if you know that the dataset is large, it's very useful to limit your query in order not to ask too much from the query endpoint. Be aware, that if you're sorting your data, the LIMIT keyword will only apply after all data have been retrieved and sorted! Thus, LIMIT will give you the first results of the sorted data.","title":"SPARQL queries"},{"location":"developers/knora/api-reference/queries/#query-forms","text":"In SPARQL four different query forms do exist: SELECT , CONSTRUCT , ASK and DESCRIBE . * The most common one is probably SELECT which enables requesting data from a collection. * Using CONSTRUCT instead will return triples. Triples can be retrieved without modifying them or the retrieved triples can be used to generate new triples. CONSTRUCT enables to copy, create and convert RDF data, and it makes it easier to identify data that do not conform to specific rules. * Using ASK asks the processor whether a certain given graph pattern fits a set of triples in the requested dataset or not. The processor returns a boolean true or false . * DESCRIBE asks for triples which describe a particular resource. This query form isn't popular because different processors return different triples as a description of the named resource. Our knora-api only allows CONSTRUCT requests and a limited set of SPARQL keywords. Thus, the main part of the following examples to illustrate the possibilities of SPARQL use the SPARQL endpoint of Wikipedia called DBpedia accessible at http://dbpedia.org/snorql/. There, the following prefixes are predefined: PREFIX owl: <http://www.w3.org/2002/07/owl#> PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> PREFIX foaf: <http://xmlns.com/foaf/0.1/> PREFIX dc: <http://purl.org/dc/elements/1.1/> PREFIX : <http://dbpedia.org/resource/> PREFIX dbpedia2: <http://dbpedia.org/property/> PREFIX dbpedia: <http://dbpedia.org/> PREFIX skos: <http://www.w3.org/2004/02/skos/core#> Additional prefixes can be defined in the query window before the SELECT statement, e.g. PREFIX knora-api: <https://api.dasch.swiss/ontology/knora-api/v2#>","title":"Query forms"},{"location":"developers/knora/api-reference/queries/#a-query-asking-for-all-data","text":"If we have no idea what our data is all about, a nice first query is the following - but don't forget to set a limit because it asks for all the triples in the dataset!","title":"A query asking for all data"},{"location":"developers/knora/api-reference/queries/#using-your-local-knora-installation","text":"Go to http://0.0.0.0:7200/sparql in your browser which will guide you to the GraphDB SPARQL Query & Update page if you've Knora installed locally. Copy the following code into the window: PREFIX knora-api: <https://api.dasch.swiss/ontology/knora-api/v2#> select * where { ?s ?p ?o . } limit 100 This query retrieves the first 100 triples of the data. The asterisk after SELECT indicates that all variables should be selected to get bound in this query. Setting a limit with the keyword LIMIT prevents a server timeout.","title":"Using your local Knora installation"},{"location":"developers/knora/api-reference/queries/#using-postman-and-http-post","text":"If you haven't installed Knora locally or if you want to run the same query on our live-server, you'll see that this query isn't allowed because it's supposed to be too broad to be meaningful. Additionally, the query has to be adapted because only CONSTRUCT queries are allowed, the main resource has to be named and the keyword LIMIT is not supported. Remember, that all variables in the CONSTRUCT must appear also in the WHERE -clause! Open Postman and chose HTTP POST sent to https://api.dasch.swiss/v2/searchextended Then click \"Body\" and chose \"raw\". Theoretically, the adapted query asking for all resources in Knora would look like the following: PREFIX knora-api: <http://api.knora.org/ontology/knora-api/simple/v2#> CONSTRUCT { ?s knora-api:isMainResource true . } WHERE { ?s a knora-api:Resource . } This is a syntactically correct query, but it returns no results due to access limitations. However, we can ask for all resources of a certain kind, e.g. for all who are a foaf:Person : PREFIX knora-api: <http://api.knora.org/ontology/knora-api/simple/v2#> PREFIX foaf: <http://xmlns.com/foaf/0.1/> CONSTRUCT { ?s knora-api:isMainResource true . } WHERE { ?s a knora-api:Resource . ?s a foaf:Person . } If you do a count search, i.e. sending a POST request to https://api.dasch.swiss/v2/searchextended/search , you retrieve 2643 results at the moment.","title":"Using Postman and HTTP POST"},{"location":"developers/knora/api-reference/queries/#a-query-asking-for-one-specific-variable","text":"If we are interested in works of the artist Marc Chagall, we can send a first query to the DBpedia endpoint, asking for information about Chagall with results stored in the variable ?artist : SELECT ?artist WHERE { <http://dbpedia.org/resource/Chagall> ?p ?artist . } The angle brackets surrounding \"http://dbpedia.org/resource/Chagall\" tell the processor that it is an URI. The query retrieves the following results in tabular form (if the simple output format \"Browse\" is chosen): |artist| |-----| |\"Chagall\"@en| |158693| |600433204| |:Marc_Chagall link | | http://en.wikipedia.org/wiki/Chagall link | | http://en.wikipedia.org/wiki/Chagall?oldid=600433204 link | After having verified in this way that http://dbpedia.org/resource/Chagall is a valid URI, we can ask for properties and values with the following query: SELECT ?property ?hasValue WHERE { <http://dbpedia.org/resource/Marc_Chagall> ?property ?hasValue . } One of the results obtained is a property dbpedia:ontology/wikiPageExternalLink with the value \"<http://www.thejewishmuseum.org/collection/search?artist=Marc%20Chagall%2C%20French%2C%20b.%20Belorussia%2C%201887-1985> . Following this link leads us to the homepage of the Jewish Museum in New York and the works of Marc Chagall the museum possesses. If you intend to query data that isn't stored locally, the keyword FROM could be used to specify the data set. It is also possible to read data from a file when using the FROM keyword. If the data are stored in a file named example.ttl stored in the same folder as the query itself, then the SELECT -part of the request looks as follows: SELECT * <example.ttl> WHERE { ... }","title":"A query asking for one specific variable"},{"location":"developers/knora/api-reference/queries/#a-query-with-matching-on-multiple-triples","text":"The following query uses a ?films variable to tie together two triple patterns in the WHERE -clause. SELECT ?films WHERE { ?films <http://dbpedia.org/ontology/starring> :Iggy_Pop . ?films <http://dbpedia.org/ontology/starring> :Johnny_Depp . } Such a set of triple patterns within curly braces is called a graph pattern . The ?films variable is used in two different triples to find connected triples in the queried data. The first triple looks for films starring Iggy Pop, the second triple then searches if in one of these films also Johnny Depp was involved. The result shows all the films these actors played in together: Cry Baby and Dead Man.","title":"A query with matching on multiple triples"},{"location":"developers/knora/api-reference/queries/#searching-for-strings-and-values","text":"The keyword FILTER tells the query processor to return only those triples which meet the given condition in the filter. This time we're searching for films starring David Bowie, but only those which have a runtime longer than 89 minutes. SELECT ?BowieFilm ?runtime WHERE { ?BowieFilm <http://dbpedia.org/ontology/starring> :David_Bowie . ?BowieFilm <http://dbpedia.org/ontology/Work/runtime> ?runtime . FILTER (xsd:double(?runtime) > 89.0 ) } ORDER BY xsd:double(?runtime) The keyword ORDER BY allows to sort the results with runtime in increasing order. Be aware that it is necessary to specify the datatype xsd:double of the ?runtime variable, otherwise the filter and also the sorting doesn't work properly!","title":"Searching for strings and values"},{"location":"developers/knora/api-reference/queries/#searching-for-data-that-may-exist-or-not","text":"The keyword OPTIONAL can be used to express \"show this value if it exists\". SELECT * WHERE { <http://dbpedia.org/resource/Pink_Floyd> <http://dbpedia.org/ontology/formerBandMember> ?members . OPTIONAL { ?members <http://dbpedia.org/ontology/deathDate> ?deathDate . } } The above query asks for the former members of the band Pink Floyd and for their death date if they passed away already. If they still enjoy their life, their names are listed anyway since the additional information about the death date is set in an OPTIONAL graph pattern. If there is more than one OPTIONAL triple pattern, they are processed in the order the processor sees them. Hence, the order of OPTIONAL patterns matters - this fact can be taken advantage of. However, excessive use of the keyword OPTIONAL can slow down the queries when dealing with large datasets!","title":"Searching for data that may exist or not"},{"location":"developers/knora/api-reference/queries/#searching-for-data-that-doesnt-meet-a-condition","text":"While cleaning up data it is very useful if one can search for missing entries. FILTER NOT EXISTS is a filter condition that returns a boolean value true if the specified graph pattern doesn't exist. SELECT * WHERE { ?artist rdf:type <http://dbpedia.org/ontology/Artist> . FILTER NOT EXISTS {?artist dbpedia2:works ?works } } LIMIT 1000 When searching dbpedia data I realised that the information provided for different artists isn't very consistent. If we would intend to homogenise the basic information given for each artist we could use the above query to identify those for which the basic information about at least some of their works is still missing. Another possibility is to use the keyword MINUS . As its name suggests, it subtracts from a group A all those which satisfy the condition. The last query using the keyword MINUS looks as follows: SELECT * WHERE { ?artist rdf:type <http://dbpedia.org/ontology/Artist> . MINUS {?artist dbpedia2:works ?works } } LIMIT 1000 Be aware that FILTER NOT EXISTS and MINUS may return different results!","title":"Searching for data that doesn't meet a condition"},{"location":"developers/knora/api-reference/queries/#a-joined-search","text":"To link up different sets of data the same variable can be in the object position in one triple and in the subject position of another triple as in the following example: SELECT DISTINCT ?actor ?value WHERE { ?film <http://dbpedia.org/ontology/starring> ?actor . ?actor <http://dbpedia.org/ontology/birthYear> ?value . } LIMIT 1000 In this query with the first triple we ask for all actors, in the second triple for the birth dates of the actors. The DISTINCT keyword tells the processor that duplicate answers shouldn't be displayed, thus, redundant results are eliminated. Without the DISTINCT keyword we would receive lots of identical responses since most actors played in more than one film. Whether the queried data stem from the same repository or from different ones doesn't matter as long there are resource URIs in one dataset that can be paralleled with resource URIs in another.","title":"A joined search"},{"location":"developers/knora/api-reference/queries/#asking-about-patterns","text":"Property paths are a way to express more extensive patterns to look for. They provide a possibility to search for the requested data and in addition to that keep looking for more data. An example where this may be useful is the citation pattern of a certain paper. By simply adding a + sign we can tell the query processor to look for papers that cite paper A, and papers that cite those, etc. until the tree of papers is finished. The plus sign means \"one or more\". One could use an asterisk instead, which means \"zero or more\". It is also possible to be much more specific by using a property path which asks for papers that are exactly three links away, i.e. papers that cited papers that cited papers that cited paper A. This is laid out by a a series of steps separated by slashes. The WHERE -clauses of such queries could look like as follows: WHERE -clause meaning WHERE {?s :cites :paperA .} papers that cited paper A. WHERE {?s :cites+ :paperA .} one or more links away: papers that cited paper A, and papers that cited those, and papers that cited those, etc. WHERE {?s :cites* :paperA .} zero or more links away: papers that cited paper A, and papers that cited those, and papers that cited those, etc. WHERE {?s :cites/:cites/:cites :paperA .} three links away: papers that cited papers that cited paper A. Property paths are powerful to ask about patterns in all kinds of datasets. They are also very useful to cope with data which has been prepared or published with differing naming conventions. One such specific example is if we're interested in the total population of the British Islands: CONSTRUCT { ?country <http://dbpedia.org/ontology/populationTotal> ?pop } WHERE { VALUES ?country { :England :Scotland :Wales :Northern_Ireland :Ireland } ?country <http://dbpedia.org/property/populationCensus> | <http://dbpedia.org/ontology/populationTotal> ?pop . } For all countries except Ireland the corresponding number is returned when asking for <http://dbpedia.org/property/populationCensus> . To find Ireland's population we need to use another predicate, namely <http://dbpedia.org/ontology/populationTotal> . Use of the so-called alternative property path | as in the above example allows searching for both options at the same time. Furthermore, using CONSTRUCT instead of SELECT enables to connect each country to its population with <http://dbpedia.org/ontology/populationTotal> , thus returning consistent triples!","title":"Asking about patterns"},{"location":"developers/knora/api-reference/queries/#combining-search-conditions","text":"The UNION keyword allows to specify multiple different graph pattern and to ask for a combination of all the data which fit any of these patterns. No connection between the sets of data need to be specified. However, probably it is more useful to use UNION for retrieving two overlapping sets of data. SELECT * WHERE { {?artist rdf:type <http://dbpedia.org/ontology/Artist> . ?artist <http://dbpedia.org/ontology/birthPlace> <http://dbpedia.org/resource/Russia> . ?artist <http://dbpedia.org/ontology/deathPlace> <http://dbpedia.org/resource/Paris> . } UNION {?artist rdf:type <http://dbpedia.org/ontology/Artist> . ?artist <http://dbpedia.org/ontology/deathPlace> <http://dbpedia.org/resource/Saint-Paul-de-Vence> . } } The above query asks for all artists that were born in Russia and died in Paris and for all those artists who died in St. Paul de Vence.","title":"Combining search conditions"},{"location":"developers/knora/api-reference/queries/#filtering-data","text":"The keyword FILTER takes a single argument and it is used to retrieve those triples that match the filter argument. The filter argument can contain strings, a function or a simple comparison. Here are a few examples of filter arguments and the corresponding queries: Filter argument Meaning FILTER (regex(?o, \"Leiden\",\"i\")) searches in the ?o value for the substring \"Leiden\", the \"i\" means case insensitivity. FILTER (?o < 10) searches for all items with ?o values of less than 10. FILTER (!(isURI(?city))) returns a boolean true if the value for ?city isn't a proper URI, the ! means \"not\". SELECT * WHERE { ?s rdfs:label ?o . FILTER (regex(?o, \"Leiden\",\"i\")) } LIMIT 1000 SELECT DISTINCT ?actor ?year WHERE { ?film <http://dbpedia.org/ontology/starring> ?actor . ?actor <http://dbpedia.org/ontology/birthDate> ?year . FILTER (xsd:date(?year) > \"1980-01-01\"^^xsd:date) } LIMIT 1000 Be aware that it is necessary to specify the datatype xsd:date of the ?year variable, otherwise the filter doesn't work properly. SELECT * WHERE { <http://dbpedia.org/resource/Leiden> a ?o . FILTER (!(isURI(?o))) } This query retrieves no results since all values for ?o for the city of Leiden in dbpedia are proper URIs.","title":"Filtering data"},{"location":"developers/knora/api-reference/queries/#skip-a-number-of-results","text":"The OFFSET keyword can be used to tell the processor to skip a certain number of search results before picking those to return. This is useful for paging. Just type OFFSET and an integer number (e.g. OFFSET 5 ) after the last closing curly brace of the query.","title":"Skip a number of results"},{"location":"developers/knora/api-reference/queries/#subqueries","text":"Subqueries are queries inside queries. With the help of subqueries a complex query can be broken down into easier manageable parts. Each subquery must be enclosed in its own set of curly braces. SELECT ?capital ?latitude WHERE { { SELECT ?capital WHERE { ?capital ?p <http://dbpedia.org/resource/Category:Capitals_in_Europe> . } } { SELECT * WHERE { ?capital <http://dbpedia.org/property/latd> ?latitude . FILTER (?latitude < 52.0)} } } ORDER BY DESC(?latitude) This query first asks for all capital cities of Europe. The subquery then retrieves the corresponding geographical latitudes and filters out all of them with latitudes larger than 52.0\u00b0. Finally, the results are sorted in decreasing order of geographical latitude.","title":"Subqueries"},{"location":"developers/knora/api-reference/queries/#storing-results-in-variables","text":"The AS keyword can be used to store the query result in a variable. SELECT (SUM(?height) AS ?total) WHERE { ?skyscrapers <http://purl.org/dc/terms/subject> <http://dbpedia.org/resource/Category:Skyscrapers_in_Manhattan> . ?skyscrapers <http://dbpedia.org/ontology/height> ?height . } The above example asks for the heights of all skyscrapers in Manhattan, the sum of all their heights is calculated and then stored in the variable ?total . The SUM() function adds up all values. If we're not interested in the sum of the heights of the skyscrapers in Manhattan, but rather in the tallest, the shortest or the average value, the functions MAX() , MIN() or AVG() can be used - they enable to find the maximum, minmum or the average value. Just replace SUM in the query by MAX , MIN or AVG . A more common way of assigning a value to a variable is with the keyword BIND . Arithmetic expressions can be used when a new value is created with the help of the keyword BIND : + for addition, - for subtraction, * for multiplication and / for division. SELECT ?elmax ?elmin ?eldiff WHERE { <http://dbpedia.org/resource/Rouffignac> <http://dbpedia.org/ontology/maximumElevation> ?elmax . <http://dbpedia.org/resource/Rouffignac> <http://dbpedia.org/ontology/minimumElevation> ?elmin . BIND (?elmax - ?elmin AS ?eldiff) } We asked for the maximum and minimum elevation of the cave of Rouffignac, calculated the elevation difference and stored it in a variable ?eldiff with the help of the keyword BIND .","title":"Storing results in variables"},{"location":"developers/knora/api-reference/queries/#sorting","text":"The keyword ORDER BY enables the sorting of data. Values can e.g. be sorted in ascending or descending order - the ascending order is the default, for a descending order the sort key has to be wrapped in the DESC() function. SELECT ?BowieFilm ?runtime WHERE { ?BowieFilm <http://dbpedia.org/ontology/starring> :David_Bowie . ?BowieFilm <http://dbpedia.org/ontology/Work/runtime> ?runtime . } ORDER BY DESC(xsd:double(?runtime)) This example is almost identical to the one in the section \"Searching for strings and values\", but we eliminated the filter and now we list all films in decreasing order of runtime. Be aware that it is necessary to specify the datatype xsd:double of the ?runtime variable, otherwise the filter and also the sorting doesn't work properly! Sorting on multiple keys is possible if the key value names are separated by spaces: SELECT ?height ?floors WHERE { ?skyscrapers <http://purl.org/dc/terms/subject> <http://dbpedia.org/resource/Category:Skyscrapers_in_Manhattan> . ?skyscrapers <http://dbpedia.org/ontology/height> ?height . ?skyscrapers <http://dbpedia.org/ontology/floorCount> ?floors . } ORDER BY DESC(?floors) DESC(?height) This query returns all skyscrapers of Manhattan sorted by their number of floors and in the second place by their height.","title":"Sorting"},{"location":"developers/knora/api-reference/queries/#querying-a-remote-endpoint","text":"The SERVICE keyword provides a possibility to query remote data from a distant SPARQL endpoint. The usual way to formulate such a query is the following with an outer SELECT or CONSTRUCT indicating which values we're interested in: PREFIX xy: <http://your.external.querypoint> SELECT ?p ?o WHERE { SERVICE <http://your.external.querypoint/sparql> {xy:Person_XY ?p ?o} } However, the SPARQL Explorer for DBpedia doesn't allow such queries to external query points. Such requests have to be sent with e.g. python scripts - see section \"Python example scripts\".","title":"Querying a remote endpoint"},{"location":"developers/knora/api-reference/queries/#queries-using-construct","text":"In contrast to a SELECT query, a CONSTRUCT query specifies a triple to create with each set of values that got bound to the three variables while it has the same graph pattern following the WHERE keyword. Thus, the following SELECT version of a query asking for all information - subjects, predicates and objects of all triples - in DBpedia where the same subject has a foaf:givenName value of \"Peter\" and a foaf:surname value of \"Morris\" SELECT ?person ?p ?o WHERE { ?person <http://xmlns.com/foaf/0.1/givenName> \"Peter\"@en ; <http://xmlns.com/foaf/0.1/surname> \"Morris\"@en ; ?p ?o . } corresponds to the following CONSTRUCT version: CONSTRUCT { ?person ?p ?o . } WHERE { ?person <http://xmlns.com/foaf/0.1/givenName> \"Peter\"@en ; <http://xmlns.com/foaf/0.1/surname> \"Morris\"@en ; ?p ?o . }","title":"Queries using CONSTRUCT"},{"location":"developers/knora/api-reference/queries/#query-efficiency","text":"Sometimes there are different possibilities for a query to ask for the same set of information which differ in efficiency. The heart of any query is the WHERE -clause and the order of its components and the functions it calls can speed things up or slow them down. Although the order of a graph pattern's triple in a WHERE -clause does not effect the query results, the ordering may have a huge effect on the speed of the query's execution. Here are a few rules of thumb one should keep in mind: * You can speed up your searches if you reduce the search space as much as possible as soon as possible. * The keywort OPTIONAL will very likely slow your query down considerably. The best optimization is to avoid the use of OPTIONAL whenever possible. * Also the order of triple pattern influences the execution time. The fewer triples a triple pattern matches against the more it narrows down the search space and hence the faster the query processor will finish its job. Usually, a triple pattern with more unbound variables will match against more triples than a triple pattern with less unbound variables. Furthermore, the variable's position in the triple matters: a given dataset is more likely to have the same property in the predicate position of a large number of triples than in the subject position. * Moving a FILTER statement earlier can help to reduce the serach space as long as all variables referenced in the FILTER statement have already been bound. * The use of property paths can be expensive in terms of execution time. Outside the WHERE -clause the following points should be kept in mind: * Naming fewer variables in the SELECT statement can make the query run faster. * Sorting of the returned values with ORDER BY costs some time.","title":"Query efficiency"},{"location":"developers/knora/api-reference/queries/#sparql-query-result-formats","text":"The retrieved results can usually be returned in different formats, suitable for the different needs of different target groups. Standardized formats are: E x tensible M arkup L anguage (XML), J ava S cript O bject N otation (JSON), C omma- S eparated V alue (CSV) and T abular- S eparated V alue (TSV). These formats do not only differ in the syntax used to represent the query results, but also in the amount of metadata provided with the results. For our purposes especially the XML and the JSON formats are useful.","title":"SPARQL Query Result Formats"},{"location":"developers/knora/api-reference/queries/#sparql-query-result-xml-format","text":"The SPARQL query result XML format describes a standard XML format for returning the results of a SPARQL query. The structure of a returned XML document is as follows: * The document element is called sparql and it has two child elements - the head element lists the selected variable names and the results element contains the actual results. * The returned results are stored in result children of the results element with a binding child for each bound variable.","title":"SPARQL Query Result XML Format"},{"location":"developers/knora/api-reference/queries/#sparql-query-result-json-format","text":"A JSON object is defined as \u201can unordered collection of zero or more name-value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array.\u201d The syntax is as follows: * Objects are in curly braces. * A name-value pair is separated by a colon. The name has to be unique within an object. * A list of name-value pairs is delimited by commas. * Arrays are in square braces. The results of a SELECT query in JSON format are a table. The uppermost JSON object has two name-value pairs head and results - both have an object as their values. The variables the SELECT query asked for a stored in the vars value of the head object. The most important part of the results element is its bindings object. Each object in the bindings array has a name-value pair for each requested variable.","title":"SPARQL Query Result JSON Format"},{"location":"developers/knora/api-reference/queries/#python-example-scripts","text":"If you have Python 3 installed on your computer the following SPARQL query can be stored in a file testxml.py and run from the directory where the file is stored with the command python testxml.py . We query the dbpedia SPARQL endpoint for the ID of Jakob Bernoulli and return the result in XML format. # Send SPARQL query to dbpedia SPARQL endpoint, store and output result in XML format. import urllib.request endpointURL = \"http://dbpedia.org/sparql\" query = \"\"\" SELECT ?bernoulliID WHERE { <http://dbpedia.org/resource/Jakob_Bernoulli> <http://dbpedia.org/ontology/wikiPageID> ?bernoulliID . } \"\"\" escapedQuery = urllib.parse.quote(query) requestURL = endpointURL + \"?query=\" + escapedQuery request = urllib.request.Request(requestURL) result = urllib.request.urlopen(request) print (result.read()) The output in XML format looks as follows: <sparql xmlns=\"http://www.w3.org/2005/sparql-results#\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.w3.org/2001/sw/DataAccess/rf1/result2.xsd\"> <head> <variable name=\"bernoulliID\"/> </head> <results distinct=\"false\" ordered=\"true\"> <result> <binding name=\"bernoulliID\"> <literal datatype=\"http://www.w3.org/2001/XMLSchema#integer\">7500054</literal> </binding> </result> </results> </sparql> We are told that the bound variable is named \"bernoulliID\" and we receive the information that the questioned ID is a literal value, namely the integer 7500054. The following SPARQL query can be stored in a file testjson.py and run from the directory where the file is stored with the command python testjson.py . We query the dbpedia SPARQL endpoint for the labels of the resource \"Switzerland\" and return the result in JSON format. # Query dbpedia SPARQL endpoint about labels of resource Switzerland from SPARQLWrapper import SPARQLWrapper, JSON sparql = SPARQLWrapper(\"http://dbpedia.org/sparql\") sparql.setQuery(\"\"\" PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> SELECT ?label WHERE { <http://dbpedia.org/resource/Switzerland> rdfs:label ?label } \"\"\") sparql.setReturnFormat(JSON) results = sparql.query().convert() if (len(results[\"results\"][\"bindings\"]) == 0): print (\"No results found.\") else: for result in results[\"results\"][\"bindings\"]: print(result[\"label\"][\"value\"]) The output in JSON format looks as follows: Switzerland \u0633\u0648\u064a\u0633\u0631\u0627 Schweiz Suiza Suisse Svizzera \u30b9\u30a4\u30b9 Zwitserland Szwajcaria Su\u00ed\u00e7a \u0428\u0432\u0435\u0439\u0446\u0430\u0440\u0438\u044f \u745e\u58eb Thus, the result is presented in list form.","title":"Python example scripts"},{"location":"developers/knora/api-reference/queries/#different-ways-to-send-queries","text":"As we've seen in the last paragraph, SPARQL queries can be stored in a file and run from the command line with e.g. Python. However, there are other ways to send your query and the resulting output will differ slightly, depending on which way you chose. Here are a few examples if we query the dbpedia SPARQL endpoint about labels of the resource Switzerland as in the python example in the last paragraph. If the query part of the script SELECT ?label WHERE { <http://dbpedia.org/resource/Switzerland> rdfs:label ?label . } is directly copied into the query text box of the Virtuoso SPARQL Query Editor at http://dbpedia.org/sparql and the results format is chosen as \"JSON\", the output looks as follows: head: link: [] vars: 0: \"label\" results: distinct: false ordered: true bindings: 0: label: type: \"literal\" xml:lang: \"en\" value: \"Switzerland\" 1: label: type: \"literal\" xml:lang: \"ar\" value: \"\u0633\u0648\u064a\u0633\u0631\u0627\" 2: label: type: \"literal\" xml:lang: \"de\" value: \"Schweiz\" 3: label: type: \"literal\" xml:lang: \"es\" value: \"Suiza\" 4: label: type: \"literal\" xml:lang: \"fr\" value: \"Suisse\" 5: label: type: \"literal\" xml:lang: \"it\" value: \"Svizzera\" 6: label: type: \"literal\" xml:lang: \"ja\" value: \"\u30b9\u30a4\u30b9\" 7: label: type: \"literal\" xml:lang: \"nl\" value: \"Zwitserland\" 8: label: type: \"literal\" xml:lang: \"pl\" value: \"Szwajcaria\" 9: label: type: \"literal\" xml:lang: \"pt\" value: \"Su\u00ed\u00e7a\" 10: label: type: \"literal\" xml:lang: \"ru\" value: \"\u0428\u0432\u0435\u0439\u0446\u0430\u0440\u0438\u044f\" 11: label: type: \"literal\" xml:lang: \"zh\" value: \"\u745e\u58eb\" Another possibility to retrieve the result of the same query is to send the whole query URL encoded via your browser. To URL encode your query, you can use a tool such as URL Decode and Encode : http://dbpedia.org/sparql?query=SELECT%20%3Flabel%20WHERE%20%7B%20%0A%3Chttp%3A%2F%2Fdbpedia.org%2Fresource%2FSwitzerland%3E%20rdfs%3Alabel%20%3Flabel%20.%0A%7D The result will be a table with included language tabs in HTML format: label \"Switzerland\"@en \"\u0633\u0648\u064a\u0633\u0631\u0627\"@ar \"Schweiz\"@de \"Suiza\"@es \"Suisse\"@fr \"Svizzera\"@it \"\u30b9\u30a4\u30b9\"@ja \"Zwitserland\"@nl \"Szwajcaria\"@pl \"Su\u00ed\u00e7a\"@pt \"\u0428\u0432\u0435\u0439\u0446\u0430\u0440\u0438\u044f\"@ru \"\u745e\u58eb\"@zh Or you can send the whole query URL encoded as HTTP GET request using e.g. Postman: HTTP GET sent to http://dbpedia.org/sparql?query=SELECT%20%3Flabel%20WHERE%20%7B%20%0A%3Chttp%3A%2F%2Fdbpedia.org%2Fresource%2FSwitzerland%3E%20rdfs%3Alabel%20%3Flabel%20.%0A%7D This retrieves the following result in JSON format: <sparql xmlns=\"http://www.w3.org/2005/sparql-results#\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.w3.org/2001/sw/DataAccess/rf1/result2.xsd\"> <head> <variable name=\"label\"/> </head> <results distinct=\"false\" ordered=\"true\"> <result> <binding name=\"label\"><literal xml:lang=\"en\">Switzerland</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"ar\">\u0633\u0648\u064a\u0633\u0631\u0627</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"de\">Schweiz</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"es\">Suiza</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"fr\">Suisse</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"it\">Svizzera</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"ja\">\u30b9\u30a4\u30b9</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"nl\">Zwitserland</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"pl\">Szwajcaria</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"pt\">Su\u00ed\u00e7a</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"ru\">\u0428\u0432\u0435\u0439\u0446\u0430\u0440\u0438\u044f</literal></binding> </result> <result> <binding name=\"label\"><literal xml:lang=\"zh\">\u745e\u58eb</literal></binding> </result> </results> </sparql>","title":"Different ways to send queries"},{"location":"developers/knora/api-reference/queries/#gravsearch-queries","text":"Gravsearch is a query language which is able to perform queries with complex search criteria that work well in terms of perforance and security. Furthermore, it enables clients to work with a simpler RDF data model than the one Knora actually uses to store data in the triplestore, and it permits to provide better error-checking than SPARQL. A Gravsearch query isn't being processed directly by the triplestore. Instead, the query is interpreted by Knora, which enforces certain restrictions on the query, implements paging and permission checking. The API server then generates a SPARQL query based on the submitted Gravsearch query, queries the triplestore, filters the results according to the user\u2019s permissions, and returns each page of query results as a Knora API response. Thus, Gravsearch is a hybrid between a RESTful API and a SPARQL endpoint. A Gravsearch query conforms to a subset of the syntax of a SPARQL CONSTRUCT query, with some additional restrictions and functionality. In particular, the variable representing the top-level (or \u2018main\u2019) resource that will appear in each search result must be identified, statements must be included to specify the types of the entities being queried, OFFSET is used to control paging, and ORDER BY is used to sort the results. The current version of Gravsearch accepts CONSTRUCT queries whose WHERE -clauses use the following patterns, with the specified restrictions: OPTIONAL : cannot be nested in a UNION . UNION : cannot be nested in a UNION . FILTER : may contain a complex expression using the Boolean operators AND (&&) and OR (||), as well as comparison operators. The left argument of a comparison operator must be a query variable. A Knora ontology entity IRI used in a FILTER must be a property IRI. FILTER NOT EXISTS MINUS OFFSET : the OFFSET is needed for paging. It does not actually refer to the number of triples to be returned, but to the requested page of results. The default value is 0, which refers to the first page of results. The number of results per page is defined in app/v2 in application.conf . ORDER BY : In SPARQL, the result of a CONSTRUCT query is an unordered set of triples. However, a Gravsearch query returns an ordered list of resources, which can be ordered by the values of specified properties. If the query is written in the complex schema, items below the level of Knora values may not be used in ORDER BY . BIND : The value assigned must be a Knora resource IRI.","title":"Gravsearch queries"},{"location":"developers/knora/api-reference/queries/#gravsearch-query-examples","text":"To send queries to our live-server it is easiest to use the program Postman. You have to chose the method POST . Open Postman and type HTTP POST sent to https://api.dasch.swiss/v2/searchextended Then click \"Body\" and chose \"raw\". You can then write your queries in the window before sending your request. Be aware, that only CONSTRUCT requests are supported by knora-api . Here is one query examples, more will follow. PREFIX beol: <http://api.dasch.swiss/ontology/0801/beol/simple/v2#> PREFIX knora-api: <http://api.knora.org/ontology/knora-api/simple/v2#> CONSTRUCT { ?letter knora-api:isMainResource true . ?letter beol:creationDate ?date . ?letter ?linkingProp1 ?person1 . ?letter ?linkingProp2 ?person2 . } WHERE { ?letter a knora-api:Resource . ?letter a beol:letter . ?letter beol:letterHasTranslation ?translation . beol:letterHasTranslation knora-api:objectType knora-api:Resource . ?translation a knora-api:Resource . ?letter beol:creationDate ?date . beol:creationDate knora-api:objectType knora-api:Date . ?date a knora-api:Date . ?letter ?linkingProp1 ?person1 . ?linkingProp1 knora-api:objectType knora-api:Resource . FILTER(?linkingProp1 = beol:hasAuthor || ?linkingProp1 = beol:hasRecipient ) ?person1 a beol:person . ?person1 a knora-api:Resource . ?person1 beol:hasIAFIdentifier ?gnd1 . FILTER(?gnd1 = \"(DE-588)116610832\") ?gnd1 a xsd:string . ?letter ?linkingProp2 ?person2 . ?linkingProp2 knora-api:objectType knora-api:Resource . FILTER(?linkingProp2 = beol:hasAuthor || ?linkingProp2 = beol:hasRecipient ) ?person2 a beol:person . ?person2 a knora-api:Resource . ?person2 beol:hasIAFIdentifier ?gnd2 . FILTER(?gnd2 = \"(DE-588)118696149\") ?gnd2 a xsd:string . beol:hasIAFIdentifier knora-api:objectType xsd:string . } ORDER BY ?date OFFSET 0","title":"Gravsearch query examples"},{"location":"developers/knora/contribution/","text":"","title":"Knora"},{"location":"developers/knora/documentation/","text":"DaSCH Service Platform documentation The main software framework in the back-end of the DaSCH Service Platform is called Knora ( Kn owledge O rganization, R epresentation, and A nnotation). Knora is a content management system for the long-term preservation and reuse of humanities data. It is designed to accommodate data with a complex internal structure, including data that could be stored in relational databases. Knora aims to solve key problems in the long-term preservation and reuse of humanities data: Traditional archives preserve data, but do not facilitate reuse. Typically, only metadata can be searched, not the data itself. Downloading the data to check whether the data are interesting or not is time-consuming and makes it impractical to reuse data from many different sources. Knora solves this problem by keeping the data alive. You can query all the data in a Knora repository, not just the metadata. You can import thousands of databases into Knora, and run queries that search through all of them at once. Another problem is that researchers use a multitude of different data formats, many of which are proprietary and quickly become obsolete. It is not practical to maintain all the programs that were used to create and read old data files, or even all the operating systems that these programs ran on. Instead of preserving all these data formats, Knora supports the conversion of all sorts of data to a small number of formats that are suitable for long-term preservation, and that maintain the data\u2019s meaning and structure: Non-binary data is stored as R esource D escription F ramework ( RDF ), in a dedicated database called a triplestore. RDF is an open, vendor-independent standard that can express any data structure. For a concise information about RDF basics see here . Binary media files (images, audio, and video) are converted to a few specialised archival file formats and stored by the media server SIPI , with metadata stored in the triplestore. For a concise information about SIPI see here . Moreover, Knora has built-in support for special data structures that occur on a regular basis in humanities data: persistent links, calender-independent dates and flexible searchable text markup. Persistent links are a very important feature. If a resource is changed, a new resource will be created in Knora. The older version remains available and citable, there will be no dead links. This means that if in a publication an older version is referenced, the cited version still can be displayed, but there will be a notice that a newer version exists with the corresponding link attached to it. A date could be given in any kind of calendar - e.g. the Julian, Gregorian, Jewish or Islamic - just to name the most frequent ones. Knora stores dates using the Julian day count that was established by astronomers. Use of the Julian day count easily allows for conversion from one calendar into another and to calculate distances between two dates. It is possible to search for a date in one calendar and to convert it into another one. Commonly used text markup systems have troubles to cope with overlapping markup. Knora solves this problem by using Standoff/RDF markup where the markup is stored as RDF data, separately from the text. This enables overlapping markup. Knora\u2019s RDF-based standoff is designed to support the needs of complex digital critical editions. Knora can import any XML document (including TEI/XML) for storage as standoff/RDF, and can regenerate the original XML document at any time. The following table contains a non-exhaustive list of data formats and the information on how these formats are stored and managed by Knora (and SIPI): Original format Format in Knora Text (XML, LaTEX, Word, etc.) Knora resources (RDF) containing Standoff/RDF Tabular data, including relational databases Knora resources Data in tree or graph structures Knora resources Images (jpg, png, tiff, etc.) JPEG 2000 files stored by SIPI Audio and video files format not decided yet, stored by SIPI pdf stored by SIPI, but data reuse is improved by extracting the text for storage as Standoff/RDF Knora makes data available for reuse via its generic, standards-based A pplication P rogramming I nterfaces (APIs). A V irtual R esearch E nvironment (VRE) can then use these APIs to search, link together, and add to data from different research projects in a unified way. The full Knora documentation can be found here . Layout of DaSCH Service Platform The DaSCH Service Platform is a platform that includes five layers (see Figure 1). The bottom layer consists of an RDF triplestore, the IIIF-based media server SIPI , the Knora-base ontology and any project specific ontologies that extend the base ontology. The second layer is occupied by the Knora API which is a RESTful API, i.e. an application program interface that uses HTTP requests to GET, PUT, POST and DELETE data. The Knora API has an implemented access control. It returns information in JSON-LD format. In order to make the data accessible in an easy way, three more layers are built on top of the Knora API. The Knora API JS lib comprises the third layer, it contains a reusable Node.js module for HTTP requests written in TypeScript. Layer four is occupied by DSP UI modules . These modules help to create a graphical user interface. They are developed with Angular and TypeScript and designed in such a way that they can be integrated to an Angular project. The top layer is made up of the generic Knora App and the more specific project Apps. From the top layer Gravsearch queries are sent to the Knora API, where permissions are checked and the queries translated into SPARQL queries which are sent further down to the triplestore. The results are returned to the Knora App if the user has the sufficient permissions. In such a way, copyrighted material can be protected. Figure 1: DaSCH Service Platform architecture. The generic web app Knora App itself consists of three different parts (see Figure 2). First, there is the project administration part where you can manage your project - build your data model, set permissions, add users, etc. Then, there is a cross-project research platform where you search (full text, advanced or expert search), add or modify your data - this is your working environment. The third component is the Manifest+ viewer wich is designed for project presentation. Alternatively, it is possible to build more elaborate project-specific Apps based on the provided Knora modules in the different layers. However, it's up to you to keep such project-specific Apps compatible with the latest Knora API version. Figure 2: Details of Knora App. Currently, the following programming languages, software and formats are used for the various components: Component Software and formats RDF triplestore GraphDB-SE or GraphDB-FREE, Fuseki (in preparation) Ontologies Knora-base ontology and derived project ontologies SIPI C++, Lua, API-format: JSON Knora API Scala, API-formats: JSON-LD, RDF/XML or Turtle Knora API JS lib TypeScript, communication with Knora-API Knora UI modules Angular modules, TypeScript, uses Knora API JS lib Knora App Angular, TypeScript, uses Knora UI modules and Knora API JS lib The Knora-base ontology Knora has a base ontology , i.e. a data model, with pre-defined basic data types. In addition to this base ontology, each project can create its own data model which is capable to describe the types of items it wishes to store. Project specific ontologies must be extensions of the Knora base ontology. The Knora-base ontology is identified by the IRI http://www.knora.org/ontology/knora-base . In our documents it will be identified by the prefix knora-base or simply kb . More information about the Knora-base ontology can be found here . Standoff/RDF Text Markup Standoff markup is text markup that is stored separately from the content it describes. Knora\u2019s Standoff/RDF markup stores content as a simple Unicode string, and represents markup separately as RDF data. By storing markup as RDF, Knora can search for markup structures in the same way as for any RDF data structure. This enables searches that combine text-related criteria with other sorts of criteria. For example, if persons and events are represented as Knora resources, and texts are represented in Standoff/RDF, a text can contain tags representing links to persons or events. One could then search for a text that mentions a person who lived in the same city as another person who is the author of a text that mentions an event that occurred during a certain period of time. In Knora\u2019s Standoff/RDF, a tag is an RDF entity that is linked to a text value . Each tag points to a substring of the text, but has its own semantic properties. It is possible to define own tag classes in the ontology by creating subclasses of the already defined kb:StandoffTag , and to attach own properties to them. ### http://www.knora.org/ontology/knora-base#StandoffLinkTag kb:StandoffLinkTag rdf:type owl:Class ; rdfs:subClassOf kb:StandoffTag , [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasLink ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ] ; rdfs:comment \"Represents a reference to a Knora resource in a TextValue\"@en . Knora\u2019s API supports automatic conversion between XML and Standoff/RDF. This can be achieved by Standoff/RDF storing the order of tags and their hierarchical relationships. Then, an XML-to-Standoff Mapping for the standoff tag classes and properties has to be defined. The mapping is written in XML. Afterwards, an XML document can be imported into Knora, which will store it in Standoff/RDF format. The following example shows a possible mapping for a knoraDate: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <mapping> <mappingElement> <tag> <name>text</name> <class>noClass</class> <namespace>noNamespace</namespace> <separatesWords>false</separatesWords> </tag> <standoffClass> <classIri>http://www.knora.org/ontology/standoff#StandoffRootTag</classIri> </standoffClass> </mappingElement> <mappingElement> <tag> <name>mydate</name> <class>noClass</class> <namespace>noNamespace</namespace> <separatesWords>false</separatesWords> </tag> <standoffClass> <classIri>http://www.knora.org/ontology/0001/anything#StandoffEventTag</classIri> <attributes> <attribute> <attributeName>description</attributeName> <namespace>noNamespace</namespace> <propertyIri>http://www.knora.org/ontology/0001/anything#standoffEventTagHasDescription</propertyIri> </attribute> </attributes> <datatype> <type>http://www.knora.org/ontology/knora-base#StandoffDateTag</type> <attributeName>knoraDate</attributeName> </datatype> </standoffClass> </mappingElement> </mapping> Once the mapping has been created, an XML like the following could be sent to Knora and converted to standoff: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <text> We had a party on <mydate description=\"new year\" knoraDate=\"GREGORIAN:2016-12-31\">New Year's Eve</mydate>. It was a lot of fun. </text> The text and markup can then be searched using the search language Gravsearch . When the document is retrieved, Knora converts it back to the original XML. Using Gravsearch for searches Knora\u2019s API provides a search language, Gravsearch , that is based on the SPARQL language. Gravsearch supports Knora\u2019s humanites-focused data structures, including calendar-independent dates and standoff markup, as well as fast full-text searches. This allows for combining text-related criteria with any other criteria in searches. Examples for queries and how to build queries you can find here .","title":"Introduction"},{"location":"developers/knora/documentation/#dasch-service-platform-documentation","text":"The main software framework in the back-end of the DaSCH Service Platform is called Knora ( Kn owledge O rganization, R epresentation, and A nnotation). Knora is a content management system for the long-term preservation and reuse of humanities data. It is designed to accommodate data with a complex internal structure, including data that could be stored in relational databases. Knora aims to solve key problems in the long-term preservation and reuse of humanities data: Traditional archives preserve data, but do not facilitate reuse. Typically, only metadata can be searched, not the data itself. Downloading the data to check whether the data are interesting or not is time-consuming and makes it impractical to reuse data from many different sources. Knora solves this problem by keeping the data alive. You can query all the data in a Knora repository, not just the metadata. You can import thousands of databases into Knora, and run queries that search through all of them at once. Another problem is that researchers use a multitude of different data formats, many of which are proprietary and quickly become obsolete. It is not practical to maintain all the programs that were used to create and read old data files, or even all the operating systems that these programs ran on. Instead of preserving all these data formats, Knora supports the conversion of all sorts of data to a small number of formats that are suitable for long-term preservation, and that maintain the data\u2019s meaning and structure: Non-binary data is stored as R esource D escription F ramework ( RDF ), in a dedicated database called a triplestore. RDF is an open, vendor-independent standard that can express any data structure. For a concise information about RDF basics see here . Binary media files (images, audio, and video) are converted to a few specialised archival file formats and stored by the media server SIPI , with metadata stored in the triplestore. For a concise information about SIPI see here . Moreover, Knora has built-in support for special data structures that occur on a regular basis in humanities data: persistent links, calender-independent dates and flexible searchable text markup. Persistent links are a very important feature. If a resource is changed, a new resource will be created in Knora. The older version remains available and citable, there will be no dead links. This means that if in a publication an older version is referenced, the cited version still can be displayed, but there will be a notice that a newer version exists with the corresponding link attached to it. A date could be given in any kind of calendar - e.g. the Julian, Gregorian, Jewish or Islamic - just to name the most frequent ones. Knora stores dates using the Julian day count that was established by astronomers. Use of the Julian day count easily allows for conversion from one calendar into another and to calculate distances between two dates. It is possible to search for a date in one calendar and to convert it into another one. Commonly used text markup systems have troubles to cope with overlapping markup. Knora solves this problem by using Standoff/RDF markup where the markup is stored as RDF data, separately from the text. This enables overlapping markup. Knora\u2019s RDF-based standoff is designed to support the needs of complex digital critical editions. Knora can import any XML document (including TEI/XML) for storage as standoff/RDF, and can regenerate the original XML document at any time. The following table contains a non-exhaustive list of data formats and the information on how these formats are stored and managed by Knora (and SIPI): Original format Format in Knora Text (XML, LaTEX, Word, etc.) Knora resources (RDF) containing Standoff/RDF Tabular data, including relational databases Knora resources Data in tree or graph structures Knora resources Images (jpg, png, tiff, etc.) JPEG 2000 files stored by SIPI Audio and video files format not decided yet, stored by SIPI pdf stored by SIPI, but data reuse is improved by extracting the text for storage as Standoff/RDF Knora makes data available for reuse via its generic, standards-based A pplication P rogramming I nterfaces (APIs). A V irtual R esearch E nvironment (VRE) can then use these APIs to search, link together, and add to data from different research projects in a unified way. The full Knora documentation can be found here .","title":"DaSCH Service Platform documentation"},{"location":"developers/knora/documentation/#layout-of-dasch-service-platform","text":"The DaSCH Service Platform is a platform that includes five layers (see Figure 1). The bottom layer consists of an RDF triplestore, the IIIF-based media server SIPI , the Knora-base ontology and any project specific ontologies that extend the base ontology. The second layer is occupied by the Knora API which is a RESTful API, i.e. an application program interface that uses HTTP requests to GET, PUT, POST and DELETE data. The Knora API has an implemented access control. It returns information in JSON-LD format. In order to make the data accessible in an easy way, three more layers are built on top of the Knora API. The Knora API JS lib comprises the third layer, it contains a reusable Node.js module for HTTP requests written in TypeScript. Layer four is occupied by DSP UI modules . These modules help to create a graphical user interface. They are developed with Angular and TypeScript and designed in such a way that they can be integrated to an Angular project. The top layer is made up of the generic Knora App and the more specific project Apps. From the top layer Gravsearch queries are sent to the Knora API, where permissions are checked and the queries translated into SPARQL queries which are sent further down to the triplestore. The results are returned to the Knora App if the user has the sufficient permissions. In such a way, copyrighted material can be protected. Figure 1: DaSCH Service Platform architecture. The generic web app Knora App itself consists of three different parts (see Figure 2). First, there is the project administration part where you can manage your project - build your data model, set permissions, add users, etc. Then, there is a cross-project research platform where you search (full text, advanced or expert search), add or modify your data - this is your working environment. The third component is the Manifest+ viewer wich is designed for project presentation. Alternatively, it is possible to build more elaborate project-specific Apps based on the provided Knora modules in the different layers. However, it's up to you to keep such project-specific Apps compatible with the latest Knora API version. Figure 2: Details of Knora App. Currently, the following programming languages, software and formats are used for the various components: Component Software and formats RDF triplestore GraphDB-SE or GraphDB-FREE, Fuseki (in preparation) Ontologies Knora-base ontology and derived project ontologies SIPI C++, Lua, API-format: JSON Knora API Scala, API-formats: JSON-LD, RDF/XML or Turtle Knora API JS lib TypeScript, communication with Knora-API Knora UI modules Angular modules, TypeScript, uses Knora API JS lib Knora App Angular, TypeScript, uses Knora UI modules and Knora API JS lib","title":"Layout of DaSCH Service Platform"},{"location":"developers/knora/documentation/#the-knora-base-ontology","text":"Knora has a base ontology , i.e. a data model, with pre-defined basic data types. In addition to this base ontology, each project can create its own data model which is capable to describe the types of items it wishes to store. Project specific ontologies must be extensions of the Knora base ontology. The Knora-base ontology is identified by the IRI http://www.knora.org/ontology/knora-base . In our documents it will be identified by the prefix knora-base or simply kb . More information about the Knora-base ontology can be found here .","title":"The Knora-base ontology"},{"location":"developers/knora/documentation/#standoffrdf-text-markup","text":"Standoff markup is text markup that is stored separately from the content it describes. Knora\u2019s Standoff/RDF markup stores content as a simple Unicode string, and represents markup separately as RDF data. By storing markup as RDF, Knora can search for markup structures in the same way as for any RDF data structure. This enables searches that combine text-related criteria with other sorts of criteria. For example, if persons and events are represented as Knora resources, and texts are represented in Standoff/RDF, a text can contain tags representing links to persons or events. One could then search for a text that mentions a person who lived in the same city as another person who is the author of a text that mentions an event that occurred during a certain period of time. In Knora\u2019s Standoff/RDF, a tag is an RDF entity that is linked to a text value . Each tag points to a substring of the text, but has its own semantic properties. It is possible to define own tag classes in the ontology by creating subclasses of the already defined kb:StandoffTag , and to attach own properties to them. ### http://www.knora.org/ontology/knora-base#StandoffLinkTag kb:StandoffLinkTag rdf:type owl:Class ; rdfs:subClassOf kb:StandoffTag , [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasLink ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ] ; rdfs:comment \"Represents a reference to a Knora resource in a TextValue\"@en . Knora\u2019s API supports automatic conversion between XML and Standoff/RDF. This can be achieved by Standoff/RDF storing the order of tags and their hierarchical relationships. Then, an XML-to-Standoff Mapping for the standoff tag classes and properties has to be defined. The mapping is written in XML. Afterwards, an XML document can be imported into Knora, which will store it in Standoff/RDF format. The following example shows a possible mapping for a knoraDate: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <mapping> <mappingElement> <tag> <name>text</name> <class>noClass</class> <namespace>noNamespace</namespace> <separatesWords>false</separatesWords> </tag> <standoffClass> <classIri>http://www.knora.org/ontology/standoff#StandoffRootTag</classIri> </standoffClass> </mappingElement> <mappingElement> <tag> <name>mydate</name> <class>noClass</class> <namespace>noNamespace</namespace> <separatesWords>false</separatesWords> </tag> <standoffClass> <classIri>http://www.knora.org/ontology/0001/anything#StandoffEventTag</classIri> <attributes> <attribute> <attributeName>description</attributeName> <namespace>noNamespace</namespace> <propertyIri>http://www.knora.org/ontology/0001/anything#standoffEventTagHasDescription</propertyIri> </attribute> </attributes> <datatype> <type>http://www.knora.org/ontology/knora-base#StandoffDateTag</type> <attributeName>knoraDate</attributeName> </datatype> </standoffClass> </mappingElement> </mapping> Once the mapping has been created, an XML like the following could be sent to Knora and converted to standoff: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <text> We had a party on <mydate description=\"new year\" knoraDate=\"GREGORIAN:2016-12-31\">New Year's Eve</mydate>. It was a lot of fun. </text> The text and markup can then be searched using the search language Gravsearch . When the document is retrieved, Knora converts it back to the original XML.","title":"Standoff/RDF Text Markup"},{"location":"developers/knora/documentation/#using-gravsearch-for-searches","text":"Knora\u2019s API provides a search language, Gravsearch , that is based on the SPARQL language. Gravsearch supports Knora\u2019s humanites-focused data structures, including calendar-independent dates and standoff markup, as well as fast full-text searches. This allows for combining text-related criteria with any other criteria in searches. Examples for queries and how to build queries you can find here .","title":"Using Gravsearch for searches"},{"location":"developers/knora/documentation/knora-admin/","text":"Knora-admin ontology Knora has an admin ontology where object properties, datatype properties, classes, individuals and permission class properties necessary for project administration are modelled. The Knora-admin ontology is identified by the IRI http://www.knora.org/ontology/knora-admin . In our documents it will be identified by the prefix knora-admin . The prefix kb used here refers to the Knora-base ontology . Projects In Knora each item of data belongs to some particular project. Each project using Knora must define a knora-admin:knoraProject , which has the following properties: * projectShortname : A short name that can be used to identify the project in configuration files and the like. * projectLongname : The full name of the project. * projectShortcode : A hexadecimal code that uniquely identiXes the project. These codes are assigned to projects by the DaSCH . * projectDescription : A description of the project. * belongsToInstitution : The knora-admin:Institution that the project belongs to. Ontologies, resources and values are attached to projects by means of the kb:attachedToProject property. Users are associated with a project by means of the knora-admin:isInProject property. Authorisation Users and Groups Each Knora user is represented by an object belonging to the class knora-admin:User , which is a subclass of foaf:Person , and has the properties in the following list. The numbers given in parentheses after each property are the so-called cardinalities . For more information on cardinalities see here . * userid (1): A unique identifier that the user must provide when logging in. * password (1): A cryptographic hash of the user\u2019s password. * email (0-n): Email addresses belonging to the user. * isInProject (0-n): Projects that the user is a member of. * isInGroup (0-n): User-created groups that the user is a member of. * foaf:familyName (1): The user\u2019s family name. * foaf:givenName (1): The user\u2019s given name. Knora\u2019s concept of access control is that an object -a resource or value - can grant permissions to groups of users, but not to individual users. There are several built-in groups: * knora-admin:UnknownUser : Any user who has not logged into Knora is automatically assigned to this group. * knora-admin:KnownUser : Any user who has logged into Knora is automatically assigned to this group. * knora-admin:ProjectMember : When checking a user\u2019s permissions on an object, the user is automatically assigned to this group if she is a member of the project that the object belongs to. * knora-admin:Creator : When checking a user\u2019s permissions on an object, the user is automatically assigned to this group if he is the creator of the object. * knora-admin:ProjectAdmin : When checking a user\u2019s permissions on an object, the user is automatically assigned to this group if she is an administrator of the project that the object belongs to. * knora-admin:SystemAdmin : The group of Knora system administrators. A user-created ontology can define additional groups, which must belong to the OWL class knora-admin:UserGroup . There is one built-in knora-admin:SystemUser , which is the creator of link values created automatically for resource references in standoff markup (see StandoffLinkTag ). Permissions Each resource or value can grant certain permissions to specified user groups. These permissions are represented as the object of the predicate kb:hasPermissions , which is required on every kb:Resource and on the current version of every kb:Value . The permissions attached to the current version of a value also apply to previous versions of the value. Value versions other than the current one do not have this predicate. The following permissions can be granted: 1. Restricted view permission (RV) : Allows a restricted view of the object, e.g. a view of an image with a watermark. 2. View permission (V) : Allows an unrestricted view of the object. Having view permission on a resource only affects the user\u2019s ability to view information about the resource other than its values. To view a value, she must have view permission on the value itself. 3. Modify permission (M) : For values, this permission allows a new version of a value to be created. For resources, this allows the user to create a new value (as opposed to a new version of an existing value), or to change information about the resource other than its values. When he wants to make a new version of a value, his permissions on the containing resource are not relevant. However, when he wants to change the target of a link, the old link must be deleted and a new one created, so he needs modify permission on the resource. 4. Delete permission (D) : Allows the item to be marked as deleted. 5. Change rights permission (CR) : Allows the permissions granted by the object to be changed. Each permission in the above list implies all lower-numbered permissions. A user\u2019s permission level on a particular object is calculated in the following way: 1. Make a list of the groups that the user belongs to, including knora-admin:Creator and/or knora-admin:ProjectMember if applicable. 2. Make a list of the permissions that she can obtain on the object, by iterating over the permissions that the object grants. For each permission, if she is in the specified group, add the specified permission to the list of permissions she can obtain. 3. From the resulting list, select the highest-level permission. 4. If the result is that she would have no permissions, give her whatever permission knora-admin:UnknownUser would have. To view a link between resources, a user needs permission to view the source and target resources. He also needs permission to view the kb:LinkValue representing the link, unless the link property is kb:hasStandoffLinkTo (see StandoffLinkTag ). The format of the object of kb:hasPermissions is as follows: * Each permission is represented by the one-letter or two-letter abbreviation given above. * Each permission abbreviation is followed by a space, then a comma-separated list of groups that the permission is granted to. * The IRIs of built-in groups are shortened using the knora-admin prefix. Multiple permissions are separated by a vertical bar ( | ). For example, if an object grants view permission to unknown and known users, and modify permission to project members, the resulting permission literal would be: V knora-admin:UnknownUser,knora-admin:KnownUser|M knora-admin:ProjectMember","title":"Knora-admin ontology"},{"location":"developers/knora/documentation/knora-admin/#knora-admin-ontology","text":"Knora has an admin ontology where object properties, datatype properties, classes, individuals and permission class properties necessary for project administration are modelled. The Knora-admin ontology is identified by the IRI http://www.knora.org/ontology/knora-admin . In our documents it will be identified by the prefix knora-admin . The prefix kb used here refers to the Knora-base ontology .","title":"Knora-admin ontology"},{"location":"developers/knora/documentation/knora-admin/#projects","text":"In Knora each item of data belongs to some particular project. Each project using Knora must define a knora-admin:knoraProject , which has the following properties: * projectShortname : A short name that can be used to identify the project in configuration files and the like. * projectLongname : The full name of the project. * projectShortcode : A hexadecimal code that uniquely identiXes the project. These codes are assigned to projects by the DaSCH . * projectDescription : A description of the project. * belongsToInstitution : The knora-admin:Institution that the project belongs to. Ontologies, resources and values are attached to projects by means of the kb:attachedToProject property. Users are associated with a project by means of the knora-admin:isInProject property.","title":"Projects"},{"location":"developers/knora/documentation/knora-admin/#authorisation","text":"","title":"Authorisation"},{"location":"developers/knora/documentation/knora-admin/#users-and-groups","text":"Each Knora user is represented by an object belonging to the class knora-admin:User , which is a subclass of foaf:Person , and has the properties in the following list. The numbers given in parentheses after each property are the so-called cardinalities . For more information on cardinalities see here . * userid (1): A unique identifier that the user must provide when logging in. * password (1): A cryptographic hash of the user\u2019s password. * email (0-n): Email addresses belonging to the user. * isInProject (0-n): Projects that the user is a member of. * isInGroup (0-n): User-created groups that the user is a member of. * foaf:familyName (1): The user\u2019s family name. * foaf:givenName (1): The user\u2019s given name. Knora\u2019s concept of access control is that an object -a resource or value - can grant permissions to groups of users, but not to individual users. There are several built-in groups: * knora-admin:UnknownUser : Any user who has not logged into Knora is automatically assigned to this group. * knora-admin:KnownUser : Any user who has logged into Knora is automatically assigned to this group. * knora-admin:ProjectMember : When checking a user\u2019s permissions on an object, the user is automatically assigned to this group if she is a member of the project that the object belongs to. * knora-admin:Creator : When checking a user\u2019s permissions on an object, the user is automatically assigned to this group if he is the creator of the object. * knora-admin:ProjectAdmin : When checking a user\u2019s permissions on an object, the user is automatically assigned to this group if she is an administrator of the project that the object belongs to. * knora-admin:SystemAdmin : The group of Knora system administrators. A user-created ontology can define additional groups, which must belong to the OWL class knora-admin:UserGroup . There is one built-in knora-admin:SystemUser , which is the creator of link values created automatically for resource references in standoff markup (see StandoffLinkTag ).","title":"Users and Groups"},{"location":"developers/knora/documentation/knora-admin/#permissions","text":"Each resource or value can grant certain permissions to specified user groups. These permissions are represented as the object of the predicate kb:hasPermissions , which is required on every kb:Resource and on the current version of every kb:Value . The permissions attached to the current version of a value also apply to previous versions of the value. Value versions other than the current one do not have this predicate. The following permissions can be granted: 1. Restricted view permission (RV) : Allows a restricted view of the object, e.g. a view of an image with a watermark. 2. View permission (V) : Allows an unrestricted view of the object. Having view permission on a resource only affects the user\u2019s ability to view information about the resource other than its values. To view a value, she must have view permission on the value itself. 3. Modify permission (M) : For values, this permission allows a new version of a value to be created. For resources, this allows the user to create a new value (as opposed to a new version of an existing value), or to change information about the resource other than its values. When he wants to make a new version of a value, his permissions on the containing resource are not relevant. However, when he wants to change the target of a link, the old link must be deleted and a new one created, so he needs modify permission on the resource. 4. Delete permission (D) : Allows the item to be marked as deleted. 5. Change rights permission (CR) : Allows the permissions granted by the object to be changed. Each permission in the above list implies all lower-numbered permissions. A user\u2019s permission level on a particular object is calculated in the following way: 1. Make a list of the groups that the user belongs to, including knora-admin:Creator and/or knora-admin:ProjectMember if applicable. 2. Make a list of the permissions that she can obtain on the object, by iterating over the permissions that the object grants. For each permission, if she is in the specified group, add the specified permission to the list of permissions she can obtain. 3. From the resulting list, select the highest-level permission. 4. If the result is that she would have no permissions, give her whatever permission knora-admin:UnknownUser would have. To view a link between resources, a user needs permission to view the source and target resources. He also needs permission to view the kb:LinkValue representing the link, unless the link property is kb:hasStandoffLinkTo (see StandoffLinkTag ). The format of the object of kb:hasPermissions is as follows: * Each permission is represented by the one-letter or two-letter abbreviation given above. * Each permission abbreviation is followed by a space, then a comma-separated list of groups that the permission is granted to. * The IRIs of built-in groups are shortened using the knora-admin prefix. Multiple permissions are separated by a vertical bar ( | ). For example, if an object grants view permission to unknown and known users, and modify permission to project members, the resulting permission literal would be: V knora-admin:UnknownUser,knora-admin:KnownUser|M knora-admin:ProjectMember","title":"Permissions"},{"location":"developers/knora/documentation/knora-base/","text":"Knora-base ontology Knora has a base ontology, i.e. a data model, with pre-defined basic data types. In addition to this base ontology, each project can create its own data model which is capable to describe the types of items it wishes to store. Project specific ontologies must be extensions of the Knora base ontology. The Knora-base ontology is identified by the IRI http://www.knora.org/ontology/knora-base . In our documents it will be identified by the prefix kb . The examples in this document are expressed in Turtle format, and often simplified for the purposes of illustration. Knowledge of some basics of the R esource D escription F ramework (RDF) are presupposed in this document. The Knora Data Model The Knora-base ontology describes structured value types that can store also metadata of values such as its creation date, viewing permissions etc. The following figure illustrates a possible scenario for a book which has a title and a certain publication date which both have some metadata attached. Our book ex:book2 ist the subject of a triple with the predicate ex:title and the object kb:TextValue . The metadata of kb:TextValue are the title of ex:book2 , namely King Lear which is attached to kb:TextValue by the predicate kb:valueHasString , as well as the creation date of the value 2015-08-12 13:00 attached by the predicate kb:valueCreationDate . Similarly, ex:book2 ist the subject of a triple with the predicate ex:pubdate and the object kb:DateValue . The metadata of kb:DateValue are a starting publication date with the value 2364669 attached by the predicate kb:valueHasStartJDN , an end publication date with the value 2364669 attached by the predicate kb:valueHasEndJDN as well as the creation date with the value 2015-08-12 13:03 attached by the predicate kb:valueCreationDate . Projects In Knora each item of data belongs to some particular project. The properties each project has to define are summarised in Knora-admin ontology . Ontologies, resources and values are attached to projects by means of the kb:attachedToProject property. Ontologies Each user-created ontology must be defined as an owl:Ontology with the properties rdfs:label and kb:attachedToProject : <http://www.knora.org/ontology/example-project> rdf:type owl:Ontology ; rdfs:label \"Our example project ontology\"@en ; kb:attachedToProject knora-admin:ExampleProject . Resources All the content produced by a project (e.g. digitised primary source materials or research data) must be stored in objects that belong to subclasses of kb:Resource , in order that Knora can query and update that content. Each project using the Knora base ontology must define its own OWL classes, derived from kb:Resource , to represent the types of data it deals with. A subclass of kb:Resource may additionally be a subclass of any other class, e.g. an industry-standard class such as foaf:Person - this can facilitate searches across projects. Here is an example how a class named Annotation could be defined for our example project (prefix ex ): ### http://www.knora.org/ontology/example-project#Annotation ex:Annotation rdf:type owl:Class ; rdfs:subClassOf kb:Resource ; rdfs:label \"Annotation\"@de , \"Annotation\"@en , \"Annotation\"@fr ; rdfs:comment \"A class for representing annotations\"@en . Resources have properties that point to different parts of the content they contain. For example, a resource representing a book could have a property called ex:hasAuthor , pointing to the author of the book. There are two possible kinds of content in a Knora resource: Knora values or links to other resources. Properties that point to Knora values must be subproperties of kb:hasValue , and properties that point to other resources must be subproperties of kb:hasLinkTo . Either of these two types of properties may also be a subproperty of any other property, e.g. an industry- standard property such as foaf:name ; as in the case of classes this can facilitate searches across projects. Each property definition must specify the types that its subjects and objects must belong to. A definition of the property ex:hasAuthor may look as follows: ### http://www.knora.org/ontology/example-project#hasAuthor ex:hasAuthor rdf:type owl:ObjectProperty ; rdfs:label \"Autor\"@de , \"author\"@en , \"auteur\"@fr ; rdfs:comment \"\"\"Specifies the author of a book.\"\"\"@en ; kb:objectClassConstraint kb:Resource ; kb:subjectClassConstraint kb:Value ; rdfs:subPropertyOf kb:hasValue . A definition of a property ex:hasLink in our example ontology may look as follows: ### http://www.knora.org/ontology/example-project#hasLink ex:hasLink rdf:type owl:ObjectProperty ; rdfs:label \"hat Link zu\"@de , \"has Link to\"@en , \"a lien vers\"@fr ; rdfs:comment \"Represents a direct connection between two resources\"@en ; kb:objectClassConstraint kb:LinkValue ; kb:subjectClassConstraint kb:Resource ; rdfs:subPropertyOf kb:hasLinkTo . Each user-created resource class definition must use OWL cardinality restrictions to specify the properties that resources of that class can have. Thus, a valid definition of our above mentioned class ex:Annotation for the example project looks as follows: ### http://www.knora.org/ontology/example-project#Annotation ex:Annotation rdf:type owl:Class ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty kb:hasComment ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:isAnnotationOf ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:isAnnotationOfValue ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] ; rdfs:label \"Annotation\"@de , \"Annotation\"@en , \"Annotation\"@fr ; kb:canBeInstantiated true ; rdfs:comment \"A class for representing annotations\"@en . Every resource is required to have an rdfs:label . The object of this property is an xsd:string , rather than a Knora value. This means that resources are not versioned, only their values are. A user who has modify permission on a resource can change the label of a resource. A resource can be marked as deleted. Currently, this means that the respective data are not removed, but Knora solves this by adding the predicate kb:isDeleted true to the resource. An optional kb:deleteComment may be added to explain why the resource has been marked as deleted. Deleted resources are normally hidden. They cannot be undeleted, because even though resources are not versioned, it is necessary to be able to find out when a resource was deleted. If desired, a new resource can be created by copying data from a deleted resource. Properties of resources Properties of resources are summarised in the following list. The numbers given in parentheses after each property are the so-called cardinalities . For more information on cardinalities see here . * kb:creationDate (1): The time when the resource was created. * kb:attachedToUser (1): The user who owns the resource. * kb:attachedToProject (1): The project that the resource is part of. * kb:lastModificationDate (0\u20131): A timestamp indicating when the resource or one of its values was last modified. * kb:seqnum (0\u20131): The sequence number of the resource, if it is part of an ordered group of resources, such as the pages in a book. * kb:isDeleted (1): Indicates whether the resource has been deleted. * kb:deleteDate (0\u20131): If the resource has been deleted, indicates when it was deleted. * kb:deleteComment (0\u20131): If the resource has been deleted, indicates why it was deleted. Representations It is not practical to store all data in RDF. In particular, RDF is not a good storage medium for binary data such as images. Therefore, Knora stores such data outside the triplestore, in ordinary files. A resource can have metadata about a file attached to it. The technical term for such a resource in Knora is a Representation. For each file, there is a kb:FileValue in the triplestore containing metadata about the file. Knora uses Sipi to store files. The Knora API provides ways to create file values using Knora and Sipi. A resource that has a file value must belong to one of the subclasses of kb:Representation . Its subclasses include: * kb:StillImageRepresentation : A representation containing a still image file. * kb:MovingImageRepresentation : A representation containing a video file. * kb:AudioRepresentation : A representation containing an audio file. * kb:DDDrepresentation : A representation containing a 3D image file. * kb:TextRepresentation : A representation containing a formatted text file, such as an XML file. * kb:DocumentRepresentation : A representation containing a document such as a PDF file that is not a text file. These classes can be used directly, but it is often better to define subclasses of them. The latter enables to include metadata about the files being stored. The base class of all these classes is kb:Representation , which should not be used directly. It has the following property, which its subclasses override (see OWL cardinalities for more details): * kb:hasFileValue (1): Points to a file value. There are two ways for a project to define classes for representations. The simpler way is to create a resource class that represents something such as e.g. ex:Painting that belongs to a subclass of kb:Representation . This is adequate if the class can have only one type of file attached to it. For example, if paintings are represented only by still images, ex:Painting could be a subclass of kb:StillImageRepresentation : ### http://www.knora.org/ontology/example-project#Painting ex:Painting rdf:type owl:Class ; rdfs:subClassOf kb:StillImageRepresentation , [ rdf:type owl:Restriction ; owl:onProperty kb:hasStillImageFileValue ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ; ] rdfs:label \"Repr\u00e4sentation (Bild)\"@de , \"Representation (image)\"@en , \"R\u00e9presentation (image)\"@fr ; rdfs:comment \"Represents a file containing still image data\"@en . The more flexible approach is to link - by using kb:hasRepresentation or a subproperty - each ex:Painting to other resources which contain files that represent the painting. Each of these other resources can extend a different subclass of kb:Representation . For example, a painting could have a kb:StillImageRepresentation as well as a kb:DDDrepresentation . ### http://www.knora.org/ontology/example-project#Painting ex:Painting rdf:type owl:Class ; **WIE MUSS DAS AUSSEHEN???** Standard Resource Classes The Knora-base ontology provides the following standard subclasses of kb:Resource which can be used by any project: * kb:Region : Represents a region of a Representation. * kb:Annotation : Represents an annotation of a resource. The kb:hasComment property points to the text of the annotation, represented as a kb:TextValue . ### http://www.knora.org/ontology/knora-base#Annotation :Annotation rdf:type owl:Class ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty kb:hasComment ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:isAnnotationOf ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:isAnnotationOfValue ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] ; rdfs:label \"Annotation\"@de , \"Annotation\"@en , \"Annotation\"@fr ; rdfs:comment \"A generic class for representing annotations\"@en . kb:LinkObj : Represents a link that connects two or more resources. A kb:LinkObj has a kb:hasLinkTo property pointing to each resource that it connects,as well as a kb:hasLinkToValue property pointing to a reification of each of these direct links. A kb:LinkObj is more complex - and hence less convenient and readable - than a simple direct link, but it has the advantage that it can be annotated using an kb:Annotation . For improved readability, a project can make its own subclasses of kb:LinkObj with specific meanings. ### http://www.knora.org/ontology/knora-base#LinkObj kb:LinkObj rdf:type owl:Class ; rdfs:label \"Verkn\u00fcpfungsobjekt\"@de , \"Link Object\"@en , \"Objet de lien\"@fr ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty kb:hasComment ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:hasLinkTo ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:hasLinkToValue ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] ; rdfs:comment \"Verkn\u00fcpfung mehrerer Resourcen\"@de , \"Represents a generic link object\"@en . Furthermore, each project using Knora can define its own subclasses of kb:Resource . Values The Knora base ontology defines a set of OWL classes that are derived from kb:Value and represent different types of structured values found in humanities data. This set of classes may not be extended by user-created ontologies. A value is always part of one particular resource, which points to it using some property derived from kb:hasValue . For example, a user-created ontology could specify a Book class with a property ex:hasSummary (derived from kb:hasValue ), and that property could have a kb:objectClassConstraint of kb:TextValue : ### http://www.knora.org/ontology/example-project#Book ex:Book rdf:type owl:Class ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty ex:hasSummary ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ] ; rdfs:label \"Buch\"@de , \"Book\"@en , \"Livre\"@fr ; rdfs:comment \"\"\"This resource class describes a book\"\"\"@en . ## http://www.knora.org/ontology/example-project#hasSummary ex:hasSummary rdf:type owl:ObjectProperty ; rdfs:label \"Zusammenfassung\"@de , \"summary\"@en , \"resumee\"@fr ; rdfs:comment \"\"\"Represents a summary of a resource as a kb:TextValue\"\"\"@de ; kb:subjectClassConstraint kb:Resource ; kb:objectClassConstraint kb:TextValue ; rdfs:subPropertyOf kb:hasValue . This means that the summary of each book is represented as a kb:TextValue . Knora values are versioned. Existing values are not modified. Instead, a new version of an existing value is created. The new version is linked to the old version via the kb:previousValue property. Since each value version has a different IRI, there is no IRI that can be used to cite the latest version of a value. Therefore, the latest version of each value has a separate UUID ( U niversally U nique Id entifier), as the object of the property kb:valueHasUUID . When a new version of the value is created, this UUID is moved to the new version. This makes it possible to cite the latest version of a value by searching for the UUID. \u201cDeleting\u201d a value means marking it with kb:isDeleted . An optional kb:deleteComment may be added to explain why the value has been marked as deleted. Deleted values are normally hidden. Most types of values are marked as deleted without creating a new version of the value. However, link values must be treated as a special case. Before a kb:LinkValue can be marked as deleted,its reference count must be decremented to 0. Therefore, a new version of the kb:LinkValue is made, with a reference count of 0, and it is this new version that is marked as deleted. To simplify the enforcement of ontology constraints, and for consistency with resource updates, no new versions of a deleted value can be made; it is not possible to undelete. Instead, if desired, a new value can be created by copying data from a deleted value. Properties of Value kb:valueCreationDate (1): The date and time when the value was created. kb:attachedToUser (1): The user who owns the value. kb:attachedToProject (0\u20131): The project that the value is part of. If not specified, defaults to the project of the containing resource. kb:valueHasString (1): A human-readable string representation of the value\u2019s contents, which is available to Knora\u2019s full-text search index. kb:valueHasOrder (0\u20131): A resource may have several properties of the same type with different values of the same class, and it may be necessary to indicate an order in which these values occur. For example, a book may have several authors which should appear in a defined order. Hence, kb:valueHasOrder , when present, points to an integer literal indicating the order of a given value relative to the other values of the same property. These integers will not necessarily start at any particular number, and will not necessarily be consecutive. kb:previousValue (0\u20131): The previous version of the value. kb:valueHasUUID (0\u20131): The UUID that refers to all versions of the value. Only the latest version of the value has this property. kb:isDeleted (1): Indicates whether the value has been deleted. kb:deleteDate (0\u20131): If the value has been deleted, indicates when it was deleted. kb:deleteComment (0\u20131): If the value has been deleted, indicates why it was deleted. Each Knora value can grant permissions. Subclasses of Value kb:TextValue kb:TextValue represents text, possibly including markup. The text is the object of the kb:valueHasString property. A line break is represented as a Unicode line feed character ( U+000A ). The non-printing Unicode character INFORMATION SEPARATOR TWO (U+001E) can be used to separate words that are separated only by standoff markup, in order that they are recognised as separate in a full-text search index. Markup is stored using this property: * kb:valueHasStandoff (0\u2013n): Points to a standoff markup tag. * kb:valueHasMapping (0\u20131): Points to the mapping used to create the standoff markup and to convert it back to the original XML. A text value can have a specified language: * kb:valueHasLanguage (0\u20131): An ISO 639-1 code as string specifying the language of the text. kb:DateValue Humanities data include many different types of dates. In Knora, a date belongs to a specified calendar, and is always represented as a period with start and end points. If a date concerns a specific day, then the start and the end day coincide. Each of these points has a certain precision ( DAY , MONTH , or YEAR ). An optional era indicator term ( BCE / CE , or BC / AD ) can be added to the date. When no era is provided the default era AD will be considered. Internally, the start and end points are stored as two Julian Day Numbers. This calendar-independent representation makes it possible to compare and search for dates regardless of the calendar in which they were supplied. These are the properties of kb:DateValue s: * kb:valueHasCalendar (1): The name of the calendar in which the date should be displayed. Currently, the GREGORIAN , JULIAN and ISLAMIC calendars are supported. * kb:valueHasStartJDN (1): The Julian Day Number of the start of the period (an xsd:integer ). * kb:valueHasStartPrecision (1): The precision of the start of the period. * kb:valueHasEndJDN (1): The Julian Day Number of the end of the period (an xsd:integer ). * kb:valueHasEndPrecision (1): The precision of the end of the period. kb:IntValue An kb:IntValue represents an integer. It has a property kb:valueHasInteger (1) which is an xsd:integer . kb:ColorValue A kb:ColorValue is a string respresenting a color. It has a property kb:valueHasColor (1). The string encodes the color as hexadecimal RGB values: |Color|HexCode #RGB| |-----|----| |red|#FF0000| |blue|#0000FF| |cyan|#00FFFF| |lime|#00FF00| |magenta|#FF00FF| |yellow|#FFFF00| kb:DecimalValue A kb:DecimalVallue represents an arbitrary-precision decimal number. It has a property kb:valueHasDecimal (1) which is an xsd:decimal . kb:UriValue A kb:UriValue represents a non-Knora URI. It has a property kb:valueHasUri (1) which is an xsd:anyURI . kb:BooleanValue A kb:BooleanValue represents an boolean value. It has a property kb:valueHasBoolean (1) which is an xsd:boolean . kb:GeomValue A kb:GeomValue represents a geometrical object as a JSON string, using normalized coordinates. It has a property kb:valueHasGeometry (1) which is a JSON string. E.g., a rectangle can be defined by: kb:valueHasGeometry \"{\\\"status\\\":\\\"active\\\",\\\"lineColor\\\":\\\"#ff3333\\\",\\\"lineWidth\\\":2,\\\"points\\\":[{\\\"x\\\":0.08098591549295775,\\\"y\\\":0.16741071428571427},{\\\"x\\\":0.7394366197183099,\\\"y\\\":0.7299107142857143}],\\\"type\\\":\\\"rectangle\\\",\\\"original_index\\\":0}\"; kb:GeonameValue A kb:GeonameValue represents a geolocation by using the identifiers provided at GeoNames . It has a property kb:valueHasGeonameCode (1) which is an xsd:string . kb:IntervalValue A kb:IintervalValue represents a time interval, with precise start and end times, e.g. relative to the beginning of an audio or video file. It has the following properties: * kb:valueHasIntervalStart (1): This is an xsd:decimal representing the start of the interval in seconds. * kb:valueHasIntervalEnd (1): This is an xsd:decimal representing the end of the interval in seconds. kb:ListValue Projects often need to define lists or hierarchies of categories that can be assigned to many different resources. Then, for example, a user interface can provide a drop-down menu to allow the user to assign a category to a resource. The kb:ListValue class provides a way to represent these sorts of data structures. It can represent either a flat list or a tree. A kb:ListValue has the property kb:valueHasListNode (1) which points to a kb:ListNode . Each kb:ListNode can have the following properties: * kb:isRootNode (0\u20131): Set to true if this is the root node. * kb:hasSubListNode (0\u2013n): Points to the node\u2019s child nodes, if any. * kb:hasRootNode (0\u20131): Points to the root node of the list. This property is absent if it is the root node ( kb:isRootNode is true ). * kb:listNodePosition (0\u20131): An integer indicating the node\u2019s position in the list of its siblings. This property is absent if it is the root node ( kb:isRootNode is true ). * kb:listNodeName (0\u20131): The node\u2019s human-readable name. This property is absent if it is the root node ( kb:isRootNode is true ). kb:FileValue Knora stores certain kinds of data outside the triplestore, in files (see Representations ). Each digital object that is stored outside the triplestore has associated metadata, which are stored in the triplestore in a kb:FileValue . The base class kb:FileValue , which should not be used directly, has the following properties: * kb:internalFilename (1): The name of the file as stored by Knora. * kb:internalMimeType (1): The MIME type of the file as stored by Knora. * kb:originalFilename (0\u20131): The original name of the file when it was uploaded to the Knora API server. * kb:originalMimeType (0\u20131): The original MIME type of the file when it was uploaded to the Knora API server. * kb:isPreview (0\u20131): A boolean indicating whether the file is a preview, i.e. a small image representing the contents of the file. A preview is always a kb:StillImageFileValue , regardless of the type of the enclosing kb:Representation . The subclasses of kb:FileValue , which are intended to be used directly in data, include: * kb:StillImageFileValue : Contains metadata about a still image file. * kb:MovingImageFileValue : Contains metadata about a video file. * kb:AudioFileValue : Contains metadata about an audio file. * kb:DDDFileValue : Contains metadata about a 3D image file. * kb:TextFileValue : Contains metadata about a text file. * kb:DocumentFileValue : Contains metadata about a document (such as PDF) that is not a text file. Each of these classes contains properties that are specific to the type of file it describes. For example, still image files have dimensions, video files have frame rates, and so on. kb:FileValue objects are versioned like other values,and the actual files stored by Knora are also versioned. kb:LinkValue A kb:LinkValue is an RDF reification containing metadata about a link between two resources. It is therefore a subclass of rdf:Statement as well as of kb:Value . It has these properties: * rdf:subject (1): The subject is the resource that is the source of the link. * rdf:predicate (1): The predicate is the link property. * rdf:object (1): The object is the resource that is the target of the link. * kb:valueHasRefCount (1): The reference count of the link. This is meaningful when the kb:LinkValue describes resource references in Standoff text markup . Otherwise, the reference count will always be 1 if the link exists, or 0 if it has been deleted. For details about how links are created in Knora, see Links Between Resources . kb:ExternalResValue A kb:ExternalResValue represents a resource that is not stored in the RDF triplestore managed by Knora, but instead resides in an external repository managed by some other software. The kb:ExternalResValue contains the information that Knora needs in order to access the resource, assuming that a suitable gateway plugin is installed. * kb:extResAccessInfo (1): Names the location of the repository containing the external resource, e.g. its URL. * kb:extResId (1): The repository-specific ID of the external resource. * kb:extResProvider (1): The name of the external provider of the resource. Links between Resources A link between two resources is expressed as a triple. The subject of this triple is the resource that is the source of the link, the predicate of the triple is a subproperty of kb:hasLinkTo , and the triple's object is the resource that is the target of the link. The following example shows how to link objects to a collection via a link property we call ex:isInCollection in our example project: ex:isInCollection rdf:type owl:ObjectProperty ; rdfs:subPropertyOf kb:hasLinkTo ; kb:subjectClassConstraint ex:Object ; kb:objectClassConstraint ex:Collection . It is useful to store metadata about links. For example, Knora needs to know who owns the link, who has permission to modify it, when it was created, and so on. Such metadata cannot simply describe the link property, because then it would refer to that property in general, not to any particular instance in which that property is used to connect two particular resources. To attach metadata to a specific link in RDF, it is necessary to create an RDF reification . In the case of links between resources, a reification makes statements about the triple that expresses the link between the resources. Knora uses reifications of type kb:LinkValue (described in kb:LinkValue to store metadata about links. For example, suppose our example project describes paintings that belong to collections. The project can define an ontology as follows: @prefix kb <http://www.knora.org/ontology/knora-base#> . @prefix ex: <http://www.knora.org/ontology/paintings#> . ex:Painting rdf:type owl:Class ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty ex:hasArtist ; owl:cardinality 1 ] , [ rdf:type owl:Restriction ; owl:onProperty ex:hasTitle ; owl:cardinality 1 ] ; [ rdf:type owl:Restriction ; owl:onProperty ex:isInCollection ; owl:minCardinality 1 ] ; [ rdf:type owl:Restriction ; owl:onProperty ex:isInCollectionValue ; owl:minCardinality 1 ] . ex:Collection rdf:type owl:Class ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty ex:hasCollectionName ; owl:cardinality 1 ] . ex:hasArtist rdf:type owl:ObjectProperty ; rdfs:label \"Name of artist\" ; kb:subjectClassConstraint ex:Painting ; kb:objectClassConstraint kb:TextValue . ex:hasTitle rdf:type owl:ObjectProperty ; rdfs:label \"Title of painting\" kb:subjectClassConstraint ex:Painting ; kb:objectClassConstraint kb:TextValue . ex:hasCollectionName rdf:type owl:ObjectProperty ; rdfs:label \"Name of collection\" ; kb:subjectClassConstraint ex:Collection ; kb:objectClassConstraint kb:TextValue . To link paintings to this collection it is necessary to add a property to the ontology, that points from a painting to the collection it belongs to. We call this link property ex:isInCollection which has to be a subproperty of kb:hasLinkTo : ex:isInCollection rdf:type owl:ObjectProperty ; rdfs:subPropertyOf kb:hasLinkTo ; kb:subjectClassConstraint ex:Painting ; kb:objectClassConstraint ex:Collection . We must then add a \u201clink value property\u201d, which will point from a painting to a kb:LinkValue . It will contain metadata about the link between the property and the collection. The link value specifies the creator of the link, the date when it was created, and the permissions that determine who can view or modify it. The name of the link value property is constructed using a simple naming convention: the word Value is appended to the name of the link property. In this case, since our link property is called ex:isInCollection , the link value property must be called ex:isInCollectionValue . Remember that every link value property must be a subproperty of kb:hasLinkToValue . Thus, we have: ex:isInCollectionValue rdf:type owl:ObjectProperty ; rdfs:subPropertyOf kb:hasLinkToValue ; kb:subjectClassConstraint ex:Painting ; kb:objectClassConstraint kb:LinkValue . Based on this ontology some RDF data describing a painting and a collection can be added: @prefix ex <http://www.knora.org/ontology/paintings#> . @prefix data <http://www.knora.org/ontology/paintings/data#> . data:dali_4587 rdf:type ex:Painting ; ex:hasTitle data:value_A ; ex:hasArtist data:value_B . data:value_A rdf:type kb:TextValue ; kb:valueHasString \"The Persistence of Memory\" . data:value_B rdf:type kb:TextValue ; kb:valueHasString \"Salvador Dali\" . data:pompidou rdf:type ex:Collection ; ex:hasCollectionName data:value_C . data:value_C rdf:type kb:TextValue ; kb:valueHasString \"Centre Pompidou, Paris\" . We can then state that the painting is in the collection: data:dali_4587 ex:isInCollection data:pompidou ; ex:isinCollectionValue data:value_D . data:value_D rdf:type kb:LinkValue ; rdf:subject data:dali_4587 ; rdf:predicate ex:isInCollection ; rdf:object data:pompidou ; kb:valueHasRefCount 1 . This creates a link ( ex:isInCollection ) between the painting and the collection, along with a reification containing metadata about the link. We can visualise the result as the following graph: Knora allows a user to see a link if the requesting user has permission to see the source and target resources as well as the kb:LinkValue . Text with Standoff Markup Knora is designed to be able to store text with markup, which can indicate formatting and structure, as well as the complex observations involved in transcribing handwritten manuscripts. One popular way of representing text in the humanities is to encode it in XML using the Text Encoding Initiative TEI guidelines. In Knora, a TEI/XML document can be stored as a file with attached metadata, but this is not recommended, because it does not allow Knora to perform searches across multiple documents. The recommended way to store text with markup in Knora is to use Knora\u2019s built-in support for \u201cstandoff\u201d markup, which is stored separately from the text. This has some advantages over embedded markup such as XML. While XML requires markup to have a hierarchical structure, and does not allow overlapping tags, the use of so-called standoff nodes does not have these limitations. A standoff tag can be attached to any substring in the text by giving its start and end positions. Unlike in corpus linguistics, we do not use any tokenisation resulting in a form of predefined segmentation, which would limit the user\u2019s ability to freely annotate any ranges in the text. For example, suppose we have the following text: This sentence has overlapping visual attributes. This would require just two standoff tags: ( italic, start=5, end=29) and ( bold, start=14, end=36 ) . Moreover, standoff makes it possible to mark up the same text in different, possibly incompatible ways, allowing for different interpretations without making redundant copies of the text. In the Knora base ontology, any text value can have standoff tags. By representing standoff as RDF triples, Knora makes markup searchable across multiple text documents in a repository. For example, if a repository contains documents in which references to persons are indicated in standoff, it is straightforward to find all the documents mentioning a particular person. Knora\u2019s standoff support is intended to make it possible to convert documents with embedded, hierarchical markup, such as TEI/XML, into RDF standoff and back again, with no data loss, thus bringing the benefits of RDF to existing TEI-encoded documents. In the Knora base ontology, a kb:TextValue can have one or more standoff tags. Each standoff tag indicates the start and end positions of a substring in the text that has a particular attribute. The OWL class kb:StandoffTag , which is the base class of all standoff node classes, has these properties: * kb:standoffTagHasStart (1): The index of the first character in the text that has the attribute. * kb:standoffTagHasEnd (1): The index of the last character in the text that has the attribute, plus 1. * kb:standoffTagHasUUID (1): A UUID identifying this instance and those corresponding to it in later versions of the kb:TextValue it belongs to. The UUID is a means to maintain a reference to a particular range of a text also when new versions are made and standoff tag IRIs change. * kb:standoffTagHasOriginalXMLID (0\u20131): The original ID of the XML element that the standoff tag represents, if any. * kb:standoffTagHasStartIndex (1): The start index of the standoff tag. Start indexes are numbered from 0 within the context of a particular text. When several standoff tags share the same start position, they can be nested correctly with this information when transforming them to XML. * kb:standoffTagHasEndIndex (1): The end index of the standoff tag. Start indexes are numbered from 0 within the context of a particular text. When several standoff tags share the same end position, they can be nested correctly with this information when transforming them to XML. * kb:standoffTagHasStartParent (0\u20131): Points to the parent standoff tag. This corresponds to the original nesting of tags in XML. If a standoff tag has no parent, it represents the XML root element. If the original XML element is a CLIX tag, i.e. valid XML for overlapping markup, it represents the start of a virtual (non syntactical) hierarchy. * kb:standoffTagHasEndParent (0\u20131): Points to the parent standoff tag if the original XML element is a CLIX tag and represents the end of a virtual (non syntactical) hierarchy. Thus, the definition of kb:StandoffTag is as follows: ### http://www.knora.org/ontology/knora-base#StandoffTag kb:StandoffTag rdf:type owl:Class ; rdfs:subClassOf [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasStart ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasEnd ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasUUID ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ], [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasOriginalXMLID ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasStartIndex ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ], [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasEndIndex ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ], [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasStartParent ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasEndParent ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:standoffParentClassConstraint; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ] ; rdfs:comment \"Represents a standoff markup tag\"@en . The kb:StandoffTag class is not used directly in RDF data; instead, its subclasses are used. A few subclasses are currently provided in an ontology which extends the Knora-base ontology called standoff-onto.ttl (prefix standoff ), and more will be added to support TEI semantics. Projects are able to define their own custom standoff tag classes which have to be either direct subclasses of kb:StandoffTag or one of the standoff data type classes or subclasses of one of the standoff classes defined in standoff-onto.ttl . For example, markup of a header of level 1 is defined in standoff-onto.ttl as follows: ### http://www.knora.org/ontology/standoff#StandoffStructuralTag standoff:StandoffStructuralTag rdf:type owl:Class ; rdfs:subClassOf kb:StandoffTag ; rdfs:comment \"Represents structural markup information in a TextValue\"@en . ### http://www.knora.org/ontology/standoff#StandoffHeader1Tag standoff:StandoffHeader1Tag rdf:type owl:Class ; rdfs:subClassOf standoff:StandoffStructuralTag ; rdfs:comment \"Represents a header of level 1 in a TextValue\"@en . Subclasses of StandoffTag STANDOFF DATA TYPE TAGS Standoff data type tags associate data in some Knora value type with a substring in a text. They are subclasses of kb:ValueBase classes. * kb:StandoffLinkTag : Indicates that a substring refers to another kb:Resource . * kb:StandoffInternalReferenceTag : Indicates that a substring refers to another standoff tag in the same text value. * kb:StandoffUriTag : Indicates that a substring is associated with a URI,which is stored in the same form that is used for kb:UriValue . * kb:StandoffDateTag : Indicates that a substring represents a date, which is stored in the same form that is used for kb:DateValue . * kb:StandoffColorTag : Indicates that a substring represents a color, which is stored in the same form that is used for kb:ColorValue . * kb:StandoffIntegerTag : Indicates that a substring represents an integer,which is stored in the same form that is used for kb:IntegerValue . * kb:StandoffDecimalTag : Indicates that a substring represents a number with fractions, which is stored in the same form that is used for kb:DecimalValue . * kb:StandoffIntervalTag : Indicates that a substring represents an interval, which is stored in the same form that is used for kb:IntervalValue . * kb:StandoffBooleanTag : Indicates that a substring represents a Boolean, which is stored in the same form that is used for kb:BooleanValue . kb:StandoffLinkTag A kb:StandoffLinkTag indicates that a substring is associated with a Knora resource. For example, if a repository contains resources representing persons, a text could be marked up so that each time a person\u2019s name is mentioned, a kb:StandoffLinkTag connects the name to the Knora resource describing that person. kb:StandoffLinkTag has the property kb:standoffTagHasLink (1) which gives the IRI of the resource that is referred to. Since direct links are easier and more efficient to query than indirect links, Knora automatically creates a direct link between the containing resource and the target resource, along with an RDF reification describing the link, as discussed in Links Between Resources when a text value contains a resource reference in its standoff nodes. In this case, the link property is always kb:hasStandoffLinkTo , and the link value property pointing to the kb:LinkValue is always kb:hasStandoffLinkToValue . Knora automatically updates direct links and reifications for standoff resource references when text values are updated. To do this, it keeps track of the number of text values in each resource that contain at least one standoff reference to a given target resource. It stores this number as the reference count of the kb:LinkValue describing the direct link. Each time this number changes, it makes a new version of the kb:LinkValue , with an updated reference count. When the reference count reaches zero, it removes the direct link and makes a new version of the kb:LinkValue , marked with kb:isDeleted . For example, if data:R1 is a resource with a text value in which the resource data:R2 is referenced,the repository could contain the following triples: data:R1 ex:hasComment data:V1 . data:V1 rdf:type kb:TextValue ; kb:valueHasString \"This link is internal.\" ; kb:valueHasStandoff data:SO1 . data:SO1 rdf:type kb:StandoffLinkTag ; kb:standoffTagHasStart: 5 ; kb:standoffTagHasEnd: 9 ; kb:standoffTagHasLink data:R2 . data:R1 kb:hasStandoffLinkTo data:R2 . data:R1 kb:hasStandoffLinkToValue data:LV1 . data:LV1 rdf:type kb:LinkValue ; rdf:subject data:R1 ; rdf:predicate kb:hasStandoffLinkTo ; rdf:object data:R2 ; kb:valueHasRefCount 1 . The result can be visualized like this: Link values created automatically for resource references in standoff are visible to all users, and the creator of these link values is always knora-admin:SystemUser (see Users and Groups ). The Knora API server allows a user to see a standoff link if the user has permission to see the source as well as the target resource. Internal Links in a TextValue Internal links in a kb:TextValue are used to point from one place in a document to another place in the same document. They are represented using the data type standoff class kb:StandoffInternalReferenceTag or a subclass of it. It has the property kb:standoffTagHasInternalReference (1) which points to a kb:StandoffTag that belongs to the same kb:TextValue . It has an kb:objectClassConstraint of kb:StandoffTag . For more information see here . Mapping to create Standoff from XML A mapping allows for the conversion of an XML document to RDF-standoff and back. A mapping defines one-to-one relations between XML elements and attributes and standoff classes and properties (see XML to Standoff Mapping ). A mapping is represented by a kb:XMLToStandoffMapping which contains one or more kb:MappingElement s. A kb:MappingElement maps an XML element including its attributes to a standoff class and standoff properties. It has the following properties: * kb:mappingHasXMLTagname (1): The name of the XML element that is mapped to a standoff class. * kb:mappingHasXMLNamespace (1): The XML namespace of the XML element that is mapped to a standoff class. If no namespace is given, noNamespace is used. * kb:mappingHasXMLClass (1): The name of the class of the XML element. If it has no class, noClass is used. * kb:mappingHasStandoffClass (1): The standoff class the XML element is mapped to. * kb:mappingHasXMLAttribute (0\u2013n): Maps XML attributes to standoff properties using kb:MappingXMLAttribute . * kb:mappingHasStandoffDataTypeClass (0\u20131): Indicates the standoff data type class of the standoff class the XML element is mapped to. * kb:mappingElementRequiresSeparator (0\u20131): Indicates if there should be an invisible word separator inserted after the XML element in the RDF-standoff representation. Once the markup is stripped, text segments that belonged to different elements may be concatenated. A kb:MappingXMLAttribute has the following properties: * kb:mappingHasXMLAttributename : The name of the XML attribute that is mapped to a standoff property. * kb:mappingHasXMLNamespace : The namespace of the XML attribute that is mapped to a standoff property. If no namespace is given, noNamespace is used. * kb:mappingHasStandoffProperty : The standoff property the XML attribute is mapped to. Knora includes a standard mapping used by the SALSAH GUI. It has the IRI http://rdfh.ch/standoff/mappings/StandardMapping and defines mappings for a few elements used to write texts with simple markup. Standoff in Digital Editions Knora\u2019s standoff is designed to make it possible to convert XML documents to standoff and back. One application for this feature is an editing workflow in which an editor works in an XML editor, and the resulting XML documents are converted to standoff and stored in Knora, where they can be searched and annotated. If an editor wants to correct text that has been imported from XML into standoff, the text can be exported as XML, edited, and imported again. To preserve annotations on standoff tags across edits, each tag can automatically be given a UUID. In a future version of the Knora-base ontology, it will be possible to create annotations that point to UUIDs rather than to IRIs. When a text is exported to XML, the UUIDs can be included in the XML. When the edited XML is imported again, it can be converted to new standoff tags with the same UUIDs. Annotations that applied to standoff tags in the previous version of the text will therefore also apply to equivalent tags in the new version. When text is converted from XML into standoff, tags are also given indexes, which are numbered from 0 within the context of a particular text. This makes it possible to order tags that share the same position, and to preserve the hierarchy of the original XML document. An ordinary, hierarchical XML tag is converted to a standoff tag that has one index, as well as the index of its parent tag, if any. The Knora base ontology also supports non-hierarchical markup such as CLIX , which enables overlapping markup to be represented in XML. When non-hierarchical markup is converted to standoff, both the start position and the end position of the standoff tag have indexes and parent indexes. To support these features, a standoff tag can have these additional properties: * kb:standoffTagHasStartIndex (0\u20131): The index of the start position. * kb:standoffTagHasEndIndex : The index of the end position, if this is a non-hierarchical tag. * kb:standoffTagHasStartParent (0\u20131): The IRI of the tag, if any, that contains the start position. * kb:standoffTagHasEndParent (0\u20131): The IRI of the tag, if any, that contains the end position, if this is a non-hierarchical tag. * kb:standoffTagHasUUID (0\u20131): A UUID that can be used to annotate a standoff tag that may be present in different versions of a text, or in different layers of a text (such as a diplomatic transcription and an edited critical text). Querying standoff in SPARQL A future version of Knora will provide an API for querying standoff markup. In the meantime, it is possible to query it directly in SPARQL. For example, here is a SPARQL query (using RDFS inference) that finds all the text values texts that have a standoff date tag referring to Christmas Eve 2016 (Julian Date Number 2457747), contained in a standoff:StandoffItalicTag : PREFIX kb: <http://www.knora.org/ontology/knora-base#> PREFIX standoff: <http://www.knora.org/ontology/standoff#> select * where { ?standoffTag a kb:StandoffDateTag . ?standoffTag kb:valueHasStartJDN ?dateStart . ?standoffTag kb:valueHasEndJDN ?dateEnd . FILTER (2457747 <= ?dateEnd && 2457747 >= ?dateStart) ?standoffTag kb:standoffTagHasStartParent ?parent . ?parent a standoff:StandoffItalicTag . ?textValue kb:valueHasStandoff ?standoffTag . ?textValue kb:valueHasString ?string . ?standoffTag kb:standoffTagHasStart ?startPos . ?standoffTag kb:standoffTagHasEnd ?endPos . } Consistency checking Knora tries to enforce repository consistency by checking constraints that are specified in the Knora-base ontology and in user-created ontologies. Three types of consistency rules are enforced: * Cardinalities in OWL class definitions must be satisfied. * Constraints on the types of the subjects and objects of OWL object properties must be satisfied. * A datatype property may not have an empty string as an object. The implementation of consistency checking is partly triplestore-dependent; Knora may be able to provide stricter checks with some triplestores than with others. OWL cardinalities As noted in Resources , each subclass of Resource must use OWL cardinality restrictions to specify the properties it can have. More specifically, a resource is allowed to have a property that is a subproperty of kb:hasValue or kb:hasLinkTo only if the resource\u2019s class has some cardinality for that property. Similarly, a value is allowed to have a subproperty of kb:valueHas only if the value\u2019s class has some cardinality for that property. Knora supports, and attempts to enforce, the following cardinality constraints: * owl:cardinality 1 : A resource of this class must have exactly one instance of the specified property. * owl:minCardinality 1 : A resource of this class must have at least one instance of the specified property. * owl:maxCardinality 1 : A resource of this class may have zero or one instance of the specified property. * owl:minCardinality 0 : A resource of this class may have zero or more instances of the specified property. Knora requires cardinalities to be defined using blank nodes, as in the following example from Knora-base: kb:Representation rdf:type owl:Class ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty kb:hasFileValue ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] . kb:StillImageRepresentation rdf:type owl:Class ; rdfs:subClassOf kb:Representation , [ rdf:type owl:Restriction ; owl:onProperty kb:hasStillImageFileValue ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] . The cardinality of a link property must be the same as the cardinality of the corresponding link value property. Each owl:Restriction may have the predicate salsah-gui:guiOrder to indicate the order in which properties should be displayed in a GUI. A resource class inherits cardinalities from its superclasses. This follows from the rules of RDFS inference. Also, in Knora, cardinalities in the subclass can override cardinalities that would otherwise be inherited from the superclass. Specifically, if a superclass has a cardinality on a property P, and a subclass has a cardinality on a subproperty of P, the subclass\u2019s cardinality overrides the superclass\u2019s cardinality. In the example above, kb:hasStillImageFileValue is a subproperty of kb:hasFileValue . Therefore, the cardinality on kb:hasStillImageFileValue overrides (i.e. replaces) the one on kb:hasFileValue . Note that, unlike cardinalities, predicates of properties are not inherited. If ex:foo rdfs:subPropertyOf ex:bar , this does not mean that ex:foo inherits anything from ex:bar . Any predicates of ex:foo that are also needed by ex:bar must be defined explicitly on ex:bar . This design decision was made because property predicate inheritance is not provided by RDFS inference, and would make it more difficult to check the correctness of ontologies, while providing little practical benefit. For more information about OWL cardinalities, see the OWL 2 Primer or RDF . Constraints on the types of property subjects and objects When a user-created ontology defines a property, it must indicate the types that are allowed as objects (and, if possible, as subjects) of the property. This is done using the following Knora-specific properties: * kb:subjectClassConstraint : Specifies the class that subjects of the property must belong to. This constraint is recommended but not required. Knora will attempt to enforce this constraint. * kb:objectClassConstraint : Specifies the class that objects of the property must belong to. Every subproperty of kb:hasValue or a kb:hasLinkTo - i.e. every property of a resource that points to a kb:Value or to another resource - is required to have this constraint, because Knora relies on it to know what type of object to expect for the property. Knora will attempt to enforce this constraint. * kb:objectDatatypeConstraint : If the property is a datatype property, specifies the type of literals that can be objects of the property. Knora will not attempt to enforce this constraint, but it is useful for documentation purposes. Note that it is possible for a subproperty to have a more restrictive contraint than its base property, by specifing a subject or object class that is a subclass of the one specified in the base property. However, it is not possible for the subproperty to make the base property\u2019s constraint less restrictive. Consistency constraint example A user-created ontology could define consistency constraints as in this simplified example: ex:book rdf:type owl:Class ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty ex:hasTitle ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty ex:hasAuthor ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ] . ex:hasTitle rdf:type owl:ObjectProperty ; kb:subjectClassConstraint ex:book ; kb:objectClassConstraint kb:TextValue . ex:hasAuthor rdf:type owl:ObjectProperty ; kb:subjectClassConstraint ex:book ; kb:objectClassConstraint kb:TextValue . Summary of restrictions on user-created ontologies An ontology can refer to a Knora ontology in another project only if the other ontology is built-in or shared. Restrictions on Classes Each class must be a subclass of either kb:Resource or kb:StandoffTag , but not both of them. Note that this forbids user-created subclasses of kb:Value ! All the cardinalities that a class defines directly (i.e. does not inherit from kb:Resource ) must be on properties that are defined in the triplestore. Within the cardinalities of a class, there must be a link value property for each link property and vice versa. The cardinality of a link property must be the same as the cardinality of the corresponding link value property. A cardinality on a property with a boolean value must be owl:cardinality 1 or owl:maxCardinality 1 . Each class must be a subclass of all the classes that are subject class constraints of the properties in its cardinalities. If it\u2019s a resource class, all its directly defined cardinalities must be on Knora resource properties (subproperties of kb:hasValue or kb:hasLinkTo ), and all its base classes with Knora IRIs must also be resource classes. A cardinality on kb:resourceProperty or kb:hasValue is forbidden. It must also have an rdfs:label . If it\u2019s a standoff class, none of its cardinalities may be on Knora resource properties, and all its base classes with Knora IRIs must also be standoff classes. A class cannot have a cardinality on property P as well as a cardinality on a subproperty of P. Restrictions on properties The property\u2019s subject class constraint, if provided, must be a subclass of kb:Resource or kb:StandoffTag , and must be a subclass of the subject class constraints of all its base properties. Its object class constraint, if provided, must be a subclass of the object class constraints of all its base properties. If the property is a Knora resource property, it must have an object class constraint and an rdfs:label . It can\u2019t be a subproperty of both kb:hasValue and kb:hasLinkTo . It can\u2019t be a subproperty of kb:hasFileValue . Each of its base properties that has a Knora IRI must also be a Knora resource property.","title":"Knora-base ontology"},{"location":"developers/knora/documentation/knora-base/#knora-base-ontology","text":"Knora has a base ontology, i.e. a data model, with pre-defined basic data types. In addition to this base ontology, each project can create its own data model which is capable to describe the types of items it wishes to store. Project specific ontologies must be extensions of the Knora base ontology. The Knora-base ontology is identified by the IRI http://www.knora.org/ontology/knora-base . In our documents it will be identified by the prefix kb . The examples in this document are expressed in Turtle format, and often simplified for the purposes of illustration. Knowledge of some basics of the R esource D escription F ramework (RDF) are presupposed in this document.","title":"Knora-base ontology"},{"location":"developers/knora/documentation/knora-base/#the-knora-data-model","text":"The Knora-base ontology describes structured value types that can store also metadata of values such as its creation date, viewing permissions etc. The following figure illustrates a possible scenario for a book which has a title and a certain publication date which both have some metadata attached. Our book ex:book2 ist the subject of a triple with the predicate ex:title and the object kb:TextValue . The metadata of kb:TextValue are the title of ex:book2 , namely King Lear which is attached to kb:TextValue by the predicate kb:valueHasString , as well as the creation date of the value 2015-08-12 13:00 attached by the predicate kb:valueCreationDate . Similarly, ex:book2 ist the subject of a triple with the predicate ex:pubdate and the object kb:DateValue . The metadata of kb:DateValue are a starting publication date with the value 2364669 attached by the predicate kb:valueHasStartJDN , an end publication date with the value 2364669 attached by the predicate kb:valueHasEndJDN as well as the creation date with the value 2015-08-12 13:03 attached by the predicate kb:valueCreationDate .","title":"The Knora Data Model"},{"location":"developers/knora/documentation/knora-base/#projects","text":"In Knora each item of data belongs to some particular project. The properties each project has to define are summarised in Knora-admin ontology . Ontologies, resources and values are attached to projects by means of the kb:attachedToProject property.","title":"Projects"},{"location":"developers/knora/documentation/knora-base/#ontologies","text":"Each user-created ontology must be defined as an owl:Ontology with the properties rdfs:label and kb:attachedToProject : <http://www.knora.org/ontology/example-project> rdf:type owl:Ontology ; rdfs:label \"Our example project ontology\"@en ; kb:attachedToProject knora-admin:ExampleProject .","title":"Ontologies"},{"location":"developers/knora/documentation/knora-base/#resources","text":"All the content produced by a project (e.g. digitised primary source materials or research data) must be stored in objects that belong to subclasses of kb:Resource , in order that Knora can query and update that content. Each project using the Knora base ontology must define its own OWL classes, derived from kb:Resource , to represent the types of data it deals with. A subclass of kb:Resource may additionally be a subclass of any other class, e.g. an industry-standard class such as foaf:Person - this can facilitate searches across projects. Here is an example how a class named Annotation could be defined for our example project (prefix ex ): ### http://www.knora.org/ontology/example-project#Annotation ex:Annotation rdf:type owl:Class ; rdfs:subClassOf kb:Resource ; rdfs:label \"Annotation\"@de , \"Annotation\"@en , \"Annotation\"@fr ; rdfs:comment \"A class for representing annotations\"@en . Resources have properties that point to different parts of the content they contain. For example, a resource representing a book could have a property called ex:hasAuthor , pointing to the author of the book. There are two possible kinds of content in a Knora resource: Knora values or links to other resources. Properties that point to Knora values must be subproperties of kb:hasValue , and properties that point to other resources must be subproperties of kb:hasLinkTo . Either of these two types of properties may also be a subproperty of any other property, e.g. an industry- standard property such as foaf:name ; as in the case of classes this can facilitate searches across projects. Each property definition must specify the types that its subjects and objects must belong to. A definition of the property ex:hasAuthor may look as follows: ### http://www.knora.org/ontology/example-project#hasAuthor ex:hasAuthor rdf:type owl:ObjectProperty ; rdfs:label \"Autor\"@de , \"author\"@en , \"auteur\"@fr ; rdfs:comment \"\"\"Specifies the author of a book.\"\"\"@en ; kb:objectClassConstraint kb:Resource ; kb:subjectClassConstraint kb:Value ; rdfs:subPropertyOf kb:hasValue . A definition of a property ex:hasLink in our example ontology may look as follows: ### http://www.knora.org/ontology/example-project#hasLink ex:hasLink rdf:type owl:ObjectProperty ; rdfs:label \"hat Link zu\"@de , \"has Link to\"@en , \"a lien vers\"@fr ; rdfs:comment \"Represents a direct connection between two resources\"@en ; kb:objectClassConstraint kb:LinkValue ; kb:subjectClassConstraint kb:Resource ; rdfs:subPropertyOf kb:hasLinkTo . Each user-created resource class definition must use OWL cardinality restrictions to specify the properties that resources of that class can have. Thus, a valid definition of our above mentioned class ex:Annotation for the example project looks as follows: ### http://www.knora.org/ontology/example-project#Annotation ex:Annotation rdf:type owl:Class ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty kb:hasComment ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:isAnnotationOf ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:isAnnotationOfValue ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] ; rdfs:label \"Annotation\"@de , \"Annotation\"@en , \"Annotation\"@fr ; kb:canBeInstantiated true ; rdfs:comment \"A class for representing annotations\"@en . Every resource is required to have an rdfs:label . The object of this property is an xsd:string , rather than a Knora value. This means that resources are not versioned, only their values are. A user who has modify permission on a resource can change the label of a resource. A resource can be marked as deleted. Currently, this means that the respective data are not removed, but Knora solves this by adding the predicate kb:isDeleted true to the resource. An optional kb:deleteComment may be added to explain why the resource has been marked as deleted. Deleted resources are normally hidden. They cannot be undeleted, because even though resources are not versioned, it is necessary to be able to find out when a resource was deleted. If desired, a new resource can be created by copying data from a deleted resource.","title":"Resources"},{"location":"developers/knora/documentation/knora-base/#properties-of-resources","text":"Properties of resources are summarised in the following list. The numbers given in parentheses after each property are the so-called cardinalities . For more information on cardinalities see here . * kb:creationDate (1): The time when the resource was created. * kb:attachedToUser (1): The user who owns the resource. * kb:attachedToProject (1): The project that the resource is part of. * kb:lastModificationDate (0\u20131): A timestamp indicating when the resource or one of its values was last modified. * kb:seqnum (0\u20131): The sequence number of the resource, if it is part of an ordered group of resources, such as the pages in a book. * kb:isDeleted (1): Indicates whether the resource has been deleted. * kb:deleteDate (0\u20131): If the resource has been deleted, indicates when it was deleted. * kb:deleteComment (0\u20131): If the resource has been deleted, indicates why it was deleted.","title":"Properties of resources"},{"location":"developers/knora/documentation/knora-base/#representations","text":"It is not practical to store all data in RDF. In particular, RDF is not a good storage medium for binary data such as images. Therefore, Knora stores such data outside the triplestore, in ordinary files. A resource can have metadata about a file attached to it. The technical term for such a resource in Knora is a Representation. For each file, there is a kb:FileValue in the triplestore containing metadata about the file. Knora uses Sipi to store files. The Knora API provides ways to create file values using Knora and Sipi. A resource that has a file value must belong to one of the subclasses of kb:Representation . Its subclasses include: * kb:StillImageRepresentation : A representation containing a still image file. * kb:MovingImageRepresentation : A representation containing a video file. * kb:AudioRepresentation : A representation containing an audio file. * kb:DDDrepresentation : A representation containing a 3D image file. * kb:TextRepresentation : A representation containing a formatted text file, such as an XML file. * kb:DocumentRepresentation : A representation containing a document such as a PDF file that is not a text file. These classes can be used directly, but it is often better to define subclasses of them. The latter enables to include metadata about the files being stored. The base class of all these classes is kb:Representation , which should not be used directly. It has the following property, which its subclasses override (see OWL cardinalities for more details): * kb:hasFileValue (1): Points to a file value. There are two ways for a project to define classes for representations. The simpler way is to create a resource class that represents something such as e.g. ex:Painting that belongs to a subclass of kb:Representation . This is adequate if the class can have only one type of file attached to it. For example, if paintings are represented only by still images, ex:Painting could be a subclass of kb:StillImageRepresentation : ### http://www.knora.org/ontology/example-project#Painting ex:Painting rdf:type owl:Class ; rdfs:subClassOf kb:StillImageRepresentation , [ rdf:type owl:Restriction ; owl:onProperty kb:hasStillImageFileValue ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ; ] rdfs:label \"Repr\u00e4sentation (Bild)\"@de , \"Representation (image)\"@en , \"R\u00e9presentation (image)\"@fr ; rdfs:comment \"Represents a file containing still image data\"@en . The more flexible approach is to link - by using kb:hasRepresentation or a subproperty - each ex:Painting to other resources which contain files that represent the painting. Each of these other resources can extend a different subclass of kb:Representation . For example, a painting could have a kb:StillImageRepresentation as well as a kb:DDDrepresentation . ### http://www.knora.org/ontology/example-project#Painting ex:Painting rdf:type owl:Class ; **WIE MUSS DAS AUSSEHEN???**","title":"Representations"},{"location":"developers/knora/documentation/knora-base/#standard-resource-classes","text":"The Knora-base ontology provides the following standard subclasses of kb:Resource which can be used by any project: * kb:Region : Represents a region of a Representation. * kb:Annotation : Represents an annotation of a resource. The kb:hasComment property points to the text of the annotation, represented as a kb:TextValue . ### http://www.knora.org/ontology/knora-base#Annotation :Annotation rdf:type owl:Class ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty kb:hasComment ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:isAnnotationOf ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:isAnnotationOfValue ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] ; rdfs:label \"Annotation\"@de , \"Annotation\"@en , \"Annotation\"@fr ; rdfs:comment \"A generic class for representing annotations\"@en . kb:LinkObj : Represents a link that connects two or more resources. A kb:LinkObj has a kb:hasLinkTo property pointing to each resource that it connects,as well as a kb:hasLinkToValue property pointing to a reification of each of these direct links. A kb:LinkObj is more complex - and hence less convenient and readable - than a simple direct link, but it has the advantage that it can be annotated using an kb:Annotation . For improved readability, a project can make its own subclasses of kb:LinkObj with specific meanings. ### http://www.knora.org/ontology/knora-base#LinkObj kb:LinkObj rdf:type owl:Class ; rdfs:label \"Verkn\u00fcpfungsobjekt\"@de , \"Link Object\"@en , \"Objet de lien\"@fr ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty kb:hasComment ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:hasLinkTo ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:hasLinkToValue ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] ; rdfs:comment \"Verkn\u00fcpfung mehrerer Resourcen\"@de , \"Represents a generic link object\"@en . Furthermore, each project using Knora can define its own subclasses of kb:Resource .","title":"Standard Resource Classes"},{"location":"developers/knora/documentation/knora-base/#values","text":"The Knora base ontology defines a set of OWL classes that are derived from kb:Value and represent different types of structured values found in humanities data. This set of classes may not be extended by user-created ontologies. A value is always part of one particular resource, which points to it using some property derived from kb:hasValue . For example, a user-created ontology could specify a Book class with a property ex:hasSummary (derived from kb:hasValue ), and that property could have a kb:objectClassConstraint of kb:TextValue : ### http://www.knora.org/ontology/example-project#Book ex:Book rdf:type owl:Class ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty ex:hasSummary ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ] ; rdfs:label \"Buch\"@de , \"Book\"@en , \"Livre\"@fr ; rdfs:comment \"\"\"This resource class describes a book\"\"\"@en . ## http://www.knora.org/ontology/example-project#hasSummary ex:hasSummary rdf:type owl:ObjectProperty ; rdfs:label \"Zusammenfassung\"@de , \"summary\"@en , \"resumee\"@fr ; rdfs:comment \"\"\"Represents a summary of a resource as a kb:TextValue\"\"\"@de ; kb:subjectClassConstraint kb:Resource ; kb:objectClassConstraint kb:TextValue ; rdfs:subPropertyOf kb:hasValue . This means that the summary of each book is represented as a kb:TextValue . Knora values are versioned. Existing values are not modified. Instead, a new version of an existing value is created. The new version is linked to the old version via the kb:previousValue property. Since each value version has a different IRI, there is no IRI that can be used to cite the latest version of a value. Therefore, the latest version of each value has a separate UUID ( U niversally U nique Id entifier), as the object of the property kb:valueHasUUID . When a new version of the value is created, this UUID is moved to the new version. This makes it possible to cite the latest version of a value by searching for the UUID. \u201cDeleting\u201d a value means marking it with kb:isDeleted . An optional kb:deleteComment may be added to explain why the value has been marked as deleted. Deleted values are normally hidden. Most types of values are marked as deleted without creating a new version of the value. However, link values must be treated as a special case. Before a kb:LinkValue can be marked as deleted,its reference count must be decremented to 0. Therefore, a new version of the kb:LinkValue is made, with a reference count of 0, and it is this new version that is marked as deleted. To simplify the enforcement of ontology constraints, and for consistency with resource updates, no new versions of a deleted value can be made; it is not possible to undelete. Instead, if desired, a new value can be created by copying data from a deleted value.","title":"Values"},{"location":"developers/knora/documentation/knora-base/#properties-of-value","text":"kb:valueCreationDate (1): The date and time when the value was created. kb:attachedToUser (1): The user who owns the value. kb:attachedToProject (0\u20131): The project that the value is part of. If not specified, defaults to the project of the containing resource. kb:valueHasString (1): A human-readable string representation of the value\u2019s contents, which is available to Knora\u2019s full-text search index. kb:valueHasOrder (0\u20131): A resource may have several properties of the same type with different values of the same class, and it may be necessary to indicate an order in which these values occur. For example, a book may have several authors which should appear in a defined order. Hence, kb:valueHasOrder , when present, points to an integer literal indicating the order of a given value relative to the other values of the same property. These integers will not necessarily start at any particular number, and will not necessarily be consecutive. kb:previousValue (0\u20131): The previous version of the value. kb:valueHasUUID (0\u20131): The UUID that refers to all versions of the value. Only the latest version of the value has this property. kb:isDeleted (1): Indicates whether the value has been deleted. kb:deleteDate (0\u20131): If the value has been deleted, indicates when it was deleted. kb:deleteComment (0\u20131): If the value has been deleted, indicates why it was deleted. Each Knora value can grant permissions.","title":"Properties of Value"},{"location":"developers/knora/documentation/knora-base/#subclasses-of-value","text":"kb:TextValue kb:TextValue represents text, possibly including markup. The text is the object of the kb:valueHasString property. A line break is represented as a Unicode line feed character ( U+000A ). The non-printing Unicode character INFORMATION SEPARATOR TWO (U+001E) can be used to separate words that are separated only by standoff markup, in order that they are recognised as separate in a full-text search index. Markup is stored using this property: * kb:valueHasStandoff (0\u2013n): Points to a standoff markup tag. * kb:valueHasMapping (0\u20131): Points to the mapping used to create the standoff markup and to convert it back to the original XML. A text value can have a specified language: * kb:valueHasLanguage (0\u20131): An ISO 639-1 code as string specifying the language of the text. kb:DateValue Humanities data include many different types of dates. In Knora, a date belongs to a specified calendar, and is always represented as a period with start and end points. If a date concerns a specific day, then the start and the end day coincide. Each of these points has a certain precision ( DAY , MONTH , or YEAR ). An optional era indicator term ( BCE / CE , or BC / AD ) can be added to the date. When no era is provided the default era AD will be considered. Internally, the start and end points are stored as two Julian Day Numbers. This calendar-independent representation makes it possible to compare and search for dates regardless of the calendar in which they were supplied. These are the properties of kb:DateValue s: * kb:valueHasCalendar (1): The name of the calendar in which the date should be displayed. Currently, the GREGORIAN , JULIAN and ISLAMIC calendars are supported. * kb:valueHasStartJDN (1): The Julian Day Number of the start of the period (an xsd:integer ). * kb:valueHasStartPrecision (1): The precision of the start of the period. * kb:valueHasEndJDN (1): The Julian Day Number of the end of the period (an xsd:integer ). * kb:valueHasEndPrecision (1): The precision of the end of the period. kb:IntValue An kb:IntValue represents an integer. It has a property kb:valueHasInteger (1) which is an xsd:integer . kb:ColorValue A kb:ColorValue is a string respresenting a color. It has a property kb:valueHasColor (1). The string encodes the color as hexadecimal RGB values: |Color|HexCode #RGB| |-----|----| |red|#FF0000| |blue|#0000FF| |cyan|#00FFFF| |lime|#00FF00| |magenta|#FF00FF| |yellow|#FFFF00| kb:DecimalValue A kb:DecimalVallue represents an arbitrary-precision decimal number. It has a property kb:valueHasDecimal (1) which is an xsd:decimal . kb:UriValue A kb:UriValue represents a non-Knora URI. It has a property kb:valueHasUri (1) which is an xsd:anyURI . kb:BooleanValue A kb:BooleanValue represents an boolean value. It has a property kb:valueHasBoolean (1) which is an xsd:boolean . kb:GeomValue A kb:GeomValue represents a geometrical object as a JSON string, using normalized coordinates. It has a property kb:valueHasGeometry (1) which is a JSON string. E.g., a rectangle can be defined by: kb:valueHasGeometry \"{\\\"status\\\":\\\"active\\\",\\\"lineColor\\\":\\\"#ff3333\\\",\\\"lineWidth\\\":2,\\\"points\\\":[{\\\"x\\\":0.08098591549295775,\\\"y\\\":0.16741071428571427},{\\\"x\\\":0.7394366197183099,\\\"y\\\":0.7299107142857143}],\\\"type\\\":\\\"rectangle\\\",\\\"original_index\\\":0}\"; kb:GeonameValue A kb:GeonameValue represents a geolocation by using the identifiers provided at GeoNames . It has a property kb:valueHasGeonameCode (1) which is an xsd:string . kb:IntervalValue A kb:IintervalValue represents a time interval, with precise start and end times, e.g. relative to the beginning of an audio or video file. It has the following properties: * kb:valueHasIntervalStart (1): This is an xsd:decimal representing the start of the interval in seconds. * kb:valueHasIntervalEnd (1): This is an xsd:decimal representing the end of the interval in seconds. kb:ListValue Projects often need to define lists or hierarchies of categories that can be assigned to many different resources. Then, for example, a user interface can provide a drop-down menu to allow the user to assign a category to a resource. The kb:ListValue class provides a way to represent these sorts of data structures. It can represent either a flat list or a tree. A kb:ListValue has the property kb:valueHasListNode (1) which points to a kb:ListNode . Each kb:ListNode can have the following properties: * kb:isRootNode (0\u20131): Set to true if this is the root node. * kb:hasSubListNode (0\u2013n): Points to the node\u2019s child nodes, if any. * kb:hasRootNode (0\u20131): Points to the root node of the list. This property is absent if it is the root node ( kb:isRootNode is true ). * kb:listNodePosition (0\u20131): An integer indicating the node\u2019s position in the list of its siblings. This property is absent if it is the root node ( kb:isRootNode is true ). * kb:listNodeName (0\u20131): The node\u2019s human-readable name. This property is absent if it is the root node ( kb:isRootNode is true ). kb:FileValue Knora stores certain kinds of data outside the triplestore, in files (see Representations ). Each digital object that is stored outside the triplestore has associated metadata, which are stored in the triplestore in a kb:FileValue . The base class kb:FileValue , which should not be used directly, has the following properties: * kb:internalFilename (1): The name of the file as stored by Knora. * kb:internalMimeType (1): The MIME type of the file as stored by Knora. * kb:originalFilename (0\u20131): The original name of the file when it was uploaded to the Knora API server. * kb:originalMimeType (0\u20131): The original MIME type of the file when it was uploaded to the Knora API server. * kb:isPreview (0\u20131): A boolean indicating whether the file is a preview, i.e. a small image representing the contents of the file. A preview is always a kb:StillImageFileValue , regardless of the type of the enclosing kb:Representation . The subclasses of kb:FileValue , which are intended to be used directly in data, include: * kb:StillImageFileValue : Contains metadata about a still image file. * kb:MovingImageFileValue : Contains metadata about a video file. * kb:AudioFileValue : Contains metadata about an audio file. * kb:DDDFileValue : Contains metadata about a 3D image file. * kb:TextFileValue : Contains metadata about a text file. * kb:DocumentFileValue : Contains metadata about a document (such as PDF) that is not a text file. Each of these classes contains properties that are specific to the type of file it describes. For example, still image files have dimensions, video files have frame rates, and so on. kb:FileValue objects are versioned like other values,and the actual files stored by Knora are also versioned. kb:LinkValue A kb:LinkValue is an RDF reification containing metadata about a link between two resources. It is therefore a subclass of rdf:Statement as well as of kb:Value . It has these properties: * rdf:subject (1): The subject is the resource that is the source of the link. * rdf:predicate (1): The predicate is the link property. * rdf:object (1): The object is the resource that is the target of the link. * kb:valueHasRefCount (1): The reference count of the link. This is meaningful when the kb:LinkValue describes resource references in Standoff text markup . Otherwise, the reference count will always be 1 if the link exists, or 0 if it has been deleted. For details about how links are created in Knora, see Links Between Resources . kb:ExternalResValue A kb:ExternalResValue represents a resource that is not stored in the RDF triplestore managed by Knora, but instead resides in an external repository managed by some other software. The kb:ExternalResValue contains the information that Knora needs in order to access the resource, assuming that a suitable gateway plugin is installed. * kb:extResAccessInfo (1): Names the location of the repository containing the external resource, e.g. its URL. * kb:extResId (1): The repository-specific ID of the external resource. * kb:extResProvider (1): The name of the external provider of the resource.","title":"Subclasses of Value"},{"location":"developers/knora/documentation/knora-base/#links-between-resources","text":"A link between two resources is expressed as a triple. The subject of this triple is the resource that is the source of the link, the predicate of the triple is a subproperty of kb:hasLinkTo , and the triple's object is the resource that is the target of the link. The following example shows how to link objects to a collection via a link property we call ex:isInCollection in our example project: ex:isInCollection rdf:type owl:ObjectProperty ; rdfs:subPropertyOf kb:hasLinkTo ; kb:subjectClassConstraint ex:Object ; kb:objectClassConstraint ex:Collection . It is useful to store metadata about links. For example, Knora needs to know who owns the link, who has permission to modify it, when it was created, and so on. Such metadata cannot simply describe the link property, because then it would refer to that property in general, not to any particular instance in which that property is used to connect two particular resources. To attach metadata to a specific link in RDF, it is necessary to create an RDF reification . In the case of links between resources, a reification makes statements about the triple that expresses the link between the resources. Knora uses reifications of type kb:LinkValue (described in kb:LinkValue to store metadata about links. For example, suppose our example project describes paintings that belong to collections. The project can define an ontology as follows: @prefix kb <http://www.knora.org/ontology/knora-base#> . @prefix ex: <http://www.knora.org/ontology/paintings#> . ex:Painting rdf:type owl:Class ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty ex:hasArtist ; owl:cardinality 1 ] , [ rdf:type owl:Restriction ; owl:onProperty ex:hasTitle ; owl:cardinality 1 ] ; [ rdf:type owl:Restriction ; owl:onProperty ex:isInCollection ; owl:minCardinality 1 ] ; [ rdf:type owl:Restriction ; owl:onProperty ex:isInCollectionValue ; owl:minCardinality 1 ] . ex:Collection rdf:type owl:Class ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty ex:hasCollectionName ; owl:cardinality 1 ] . ex:hasArtist rdf:type owl:ObjectProperty ; rdfs:label \"Name of artist\" ; kb:subjectClassConstraint ex:Painting ; kb:objectClassConstraint kb:TextValue . ex:hasTitle rdf:type owl:ObjectProperty ; rdfs:label \"Title of painting\" kb:subjectClassConstraint ex:Painting ; kb:objectClassConstraint kb:TextValue . ex:hasCollectionName rdf:type owl:ObjectProperty ; rdfs:label \"Name of collection\" ; kb:subjectClassConstraint ex:Collection ; kb:objectClassConstraint kb:TextValue . To link paintings to this collection it is necessary to add a property to the ontology, that points from a painting to the collection it belongs to. We call this link property ex:isInCollection which has to be a subproperty of kb:hasLinkTo : ex:isInCollection rdf:type owl:ObjectProperty ; rdfs:subPropertyOf kb:hasLinkTo ; kb:subjectClassConstraint ex:Painting ; kb:objectClassConstraint ex:Collection . We must then add a \u201clink value property\u201d, which will point from a painting to a kb:LinkValue . It will contain metadata about the link between the property and the collection. The link value specifies the creator of the link, the date when it was created, and the permissions that determine who can view or modify it. The name of the link value property is constructed using a simple naming convention: the word Value is appended to the name of the link property. In this case, since our link property is called ex:isInCollection , the link value property must be called ex:isInCollectionValue . Remember that every link value property must be a subproperty of kb:hasLinkToValue . Thus, we have: ex:isInCollectionValue rdf:type owl:ObjectProperty ; rdfs:subPropertyOf kb:hasLinkToValue ; kb:subjectClassConstraint ex:Painting ; kb:objectClassConstraint kb:LinkValue . Based on this ontology some RDF data describing a painting and a collection can be added: @prefix ex <http://www.knora.org/ontology/paintings#> . @prefix data <http://www.knora.org/ontology/paintings/data#> . data:dali_4587 rdf:type ex:Painting ; ex:hasTitle data:value_A ; ex:hasArtist data:value_B . data:value_A rdf:type kb:TextValue ; kb:valueHasString \"The Persistence of Memory\" . data:value_B rdf:type kb:TextValue ; kb:valueHasString \"Salvador Dali\" . data:pompidou rdf:type ex:Collection ; ex:hasCollectionName data:value_C . data:value_C rdf:type kb:TextValue ; kb:valueHasString \"Centre Pompidou, Paris\" . We can then state that the painting is in the collection: data:dali_4587 ex:isInCollection data:pompidou ; ex:isinCollectionValue data:value_D . data:value_D rdf:type kb:LinkValue ; rdf:subject data:dali_4587 ; rdf:predicate ex:isInCollection ; rdf:object data:pompidou ; kb:valueHasRefCount 1 . This creates a link ( ex:isInCollection ) between the painting and the collection, along with a reification containing metadata about the link. We can visualise the result as the following graph: Knora allows a user to see a link if the requesting user has permission to see the source and target resources as well as the kb:LinkValue .","title":"Links between Resources"},{"location":"developers/knora/documentation/knora-base/#text-with-standoff-markup","text":"Knora is designed to be able to store text with markup, which can indicate formatting and structure, as well as the complex observations involved in transcribing handwritten manuscripts. One popular way of representing text in the humanities is to encode it in XML using the Text Encoding Initiative TEI guidelines. In Knora, a TEI/XML document can be stored as a file with attached metadata, but this is not recommended, because it does not allow Knora to perform searches across multiple documents. The recommended way to store text with markup in Knora is to use Knora\u2019s built-in support for \u201cstandoff\u201d markup, which is stored separately from the text. This has some advantages over embedded markup such as XML. While XML requires markup to have a hierarchical structure, and does not allow overlapping tags, the use of so-called standoff nodes does not have these limitations. A standoff tag can be attached to any substring in the text by giving its start and end positions. Unlike in corpus linguistics, we do not use any tokenisation resulting in a form of predefined segmentation, which would limit the user\u2019s ability to freely annotate any ranges in the text. For example, suppose we have the following text: This sentence has overlapping visual attributes. This would require just two standoff tags: ( italic, start=5, end=29) and ( bold, start=14, end=36 ) . Moreover, standoff makes it possible to mark up the same text in different, possibly incompatible ways, allowing for different interpretations without making redundant copies of the text. In the Knora base ontology, any text value can have standoff tags. By representing standoff as RDF triples, Knora makes markup searchable across multiple text documents in a repository. For example, if a repository contains documents in which references to persons are indicated in standoff, it is straightforward to find all the documents mentioning a particular person. Knora\u2019s standoff support is intended to make it possible to convert documents with embedded, hierarchical markup, such as TEI/XML, into RDF standoff and back again, with no data loss, thus bringing the benefits of RDF to existing TEI-encoded documents. In the Knora base ontology, a kb:TextValue can have one or more standoff tags. Each standoff tag indicates the start and end positions of a substring in the text that has a particular attribute. The OWL class kb:StandoffTag , which is the base class of all standoff node classes, has these properties: * kb:standoffTagHasStart (1): The index of the first character in the text that has the attribute. * kb:standoffTagHasEnd (1): The index of the last character in the text that has the attribute, plus 1. * kb:standoffTagHasUUID (1): A UUID identifying this instance and those corresponding to it in later versions of the kb:TextValue it belongs to. The UUID is a means to maintain a reference to a particular range of a text also when new versions are made and standoff tag IRIs change. * kb:standoffTagHasOriginalXMLID (0\u20131): The original ID of the XML element that the standoff tag represents, if any. * kb:standoffTagHasStartIndex (1): The start index of the standoff tag. Start indexes are numbered from 0 within the context of a particular text. When several standoff tags share the same start position, they can be nested correctly with this information when transforming them to XML. * kb:standoffTagHasEndIndex (1): The end index of the standoff tag. Start indexes are numbered from 0 within the context of a particular text. When several standoff tags share the same end position, they can be nested correctly with this information when transforming them to XML. * kb:standoffTagHasStartParent (0\u20131): Points to the parent standoff tag. This corresponds to the original nesting of tags in XML. If a standoff tag has no parent, it represents the XML root element. If the original XML element is a CLIX tag, i.e. valid XML for overlapping markup, it represents the start of a virtual (non syntactical) hierarchy. * kb:standoffTagHasEndParent (0\u20131): Points to the parent standoff tag if the original XML element is a CLIX tag and represents the end of a virtual (non syntactical) hierarchy. Thus, the definition of kb:StandoffTag is as follows: ### http://www.knora.org/ontology/knora-base#StandoffTag kb:StandoffTag rdf:type owl:Class ; rdfs:subClassOf [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasStart ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasEnd ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasUUID ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ], [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasOriginalXMLID ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasStartIndex ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ], [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasEndIndex ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ], [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasStartParent ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:standoffTagHasEndParent ; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty kb:standoffParentClassConstraint; owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ] ; rdfs:comment \"Represents a standoff markup tag\"@en . The kb:StandoffTag class is not used directly in RDF data; instead, its subclasses are used. A few subclasses are currently provided in an ontology which extends the Knora-base ontology called standoff-onto.ttl (prefix standoff ), and more will be added to support TEI semantics. Projects are able to define their own custom standoff tag classes which have to be either direct subclasses of kb:StandoffTag or one of the standoff data type classes or subclasses of one of the standoff classes defined in standoff-onto.ttl . For example, markup of a header of level 1 is defined in standoff-onto.ttl as follows: ### http://www.knora.org/ontology/standoff#StandoffStructuralTag standoff:StandoffStructuralTag rdf:type owl:Class ; rdfs:subClassOf kb:StandoffTag ; rdfs:comment \"Represents structural markup information in a TextValue\"@en . ### http://www.knora.org/ontology/standoff#StandoffHeader1Tag standoff:StandoffHeader1Tag rdf:type owl:Class ; rdfs:subClassOf standoff:StandoffStructuralTag ; rdfs:comment \"Represents a header of level 1 in a TextValue\"@en .","title":"Text with Standoff Markup"},{"location":"developers/knora/documentation/knora-base/#subclasses-of-standofftag","text":"STANDOFF DATA TYPE TAGS Standoff data type tags associate data in some Knora value type with a substring in a text. They are subclasses of kb:ValueBase classes. * kb:StandoffLinkTag : Indicates that a substring refers to another kb:Resource . * kb:StandoffInternalReferenceTag : Indicates that a substring refers to another standoff tag in the same text value. * kb:StandoffUriTag : Indicates that a substring is associated with a URI,which is stored in the same form that is used for kb:UriValue . * kb:StandoffDateTag : Indicates that a substring represents a date, which is stored in the same form that is used for kb:DateValue . * kb:StandoffColorTag : Indicates that a substring represents a color, which is stored in the same form that is used for kb:ColorValue . * kb:StandoffIntegerTag : Indicates that a substring represents an integer,which is stored in the same form that is used for kb:IntegerValue . * kb:StandoffDecimalTag : Indicates that a substring represents a number with fractions, which is stored in the same form that is used for kb:DecimalValue . * kb:StandoffIntervalTag : Indicates that a substring represents an interval, which is stored in the same form that is used for kb:IntervalValue . * kb:StandoffBooleanTag : Indicates that a substring represents a Boolean, which is stored in the same form that is used for kb:BooleanValue . kb:StandoffLinkTag A kb:StandoffLinkTag indicates that a substring is associated with a Knora resource. For example, if a repository contains resources representing persons, a text could be marked up so that each time a person\u2019s name is mentioned, a kb:StandoffLinkTag connects the name to the Knora resource describing that person. kb:StandoffLinkTag has the property kb:standoffTagHasLink (1) which gives the IRI of the resource that is referred to. Since direct links are easier and more efficient to query than indirect links, Knora automatically creates a direct link between the containing resource and the target resource, along with an RDF reification describing the link, as discussed in Links Between Resources when a text value contains a resource reference in its standoff nodes. In this case, the link property is always kb:hasStandoffLinkTo , and the link value property pointing to the kb:LinkValue is always kb:hasStandoffLinkToValue . Knora automatically updates direct links and reifications for standoff resource references when text values are updated. To do this, it keeps track of the number of text values in each resource that contain at least one standoff reference to a given target resource. It stores this number as the reference count of the kb:LinkValue describing the direct link. Each time this number changes, it makes a new version of the kb:LinkValue , with an updated reference count. When the reference count reaches zero, it removes the direct link and makes a new version of the kb:LinkValue , marked with kb:isDeleted . For example, if data:R1 is a resource with a text value in which the resource data:R2 is referenced,the repository could contain the following triples: data:R1 ex:hasComment data:V1 . data:V1 rdf:type kb:TextValue ; kb:valueHasString \"This link is internal.\" ; kb:valueHasStandoff data:SO1 . data:SO1 rdf:type kb:StandoffLinkTag ; kb:standoffTagHasStart: 5 ; kb:standoffTagHasEnd: 9 ; kb:standoffTagHasLink data:R2 . data:R1 kb:hasStandoffLinkTo data:R2 . data:R1 kb:hasStandoffLinkToValue data:LV1 . data:LV1 rdf:type kb:LinkValue ; rdf:subject data:R1 ; rdf:predicate kb:hasStandoffLinkTo ; rdf:object data:R2 ; kb:valueHasRefCount 1 . The result can be visualized like this: Link values created automatically for resource references in standoff are visible to all users, and the creator of these link values is always knora-admin:SystemUser (see Users and Groups ). The Knora API server allows a user to see a standoff link if the user has permission to see the source as well as the target resource.","title":"Subclasses of StandoffTag"},{"location":"developers/knora/documentation/knora-base/#internal-links-in-a-textvalue","text":"Internal links in a kb:TextValue are used to point from one place in a document to another place in the same document. They are represented using the data type standoff class kb:StandoffInternalReferenceTag or a subclass of it. It has the property kb:standoffTagHasInternalReference (1) which points to a kb:StandoffTag that belongs to the same kb:TextValue . It has an kb:objectClassConstraint of kb:StandoffTag . For more information see here .","title":"Internal Links in a TextValue"},{"location":"developers/knora/documentation/knora-base/#mapping-to-create-standoff-from-xml","text":"A mapping allows for the conversion of an XML document to RDF-standoff and back. A mapping defines one-to-one relations between XML elements and attributes and standoff classes and properties (see XML to Standoff Mapping ). A mapping is represented by a kb:XMLToStandoffMapping which contains one or more kb:MappingElement s. A kb:MappingElement maps an XML element including its attributes to a standoff class and standoff properties. It has the following properties: * kb:mappingHasXMLTagname (1): The name of the XML element that is mapped to a standoff class. * kb:mappingHasXMLNamespace (1): The XML namespace of the XML element that is mapped to a standoff class. If no namespace is given, noNamespace is used. * kb:mappingHasXMLClass (1): The name of the class of the XML element. If it has no class, noClass is used. * kb:mappingHasStandoffClass (1): The standoff class the XML element is mapped to. * kb:mappingHasXMLAttribute (0\u2013n): Maps XML attributes to standoff properties using kb:MappingXMLAttribute . * kb:mappingHasStandoffDataTypeClass (0\u20131): Indicates the standoff data type class of the standoff class the XML element is mapped to. * kb:mappingElementRequiresSeparator (0\u20131): Indicates if there should be an invisible word separator inserted after the XML element in the RDF-standoff representation. Once the markup is stripped, text segments that belonged to different elements may be concatenated. A kb:MappingXMLAttribute has the following properties: * kb:mappingHasXMLAttributename : The name of the XML attribute that is mapped to a standoff property. * kb:mappingHasXMLNamespace : The namespace of the XML attribute that is mapped to a standoff property. If no namespace is given, noNamespace is used. * kb:mappingHasStandoffProperty : The standoff property the XML attribute is mapped to. Knora includes a standard mapping used by the SALSAH GUI. It has the IRI http://rdfh.ch/standoff/mappings/StandardMapping and defines mappings for a few elements used to write texts with simple markup.","title":"Mapping to create Standoff from XML"},{"location":"developers/knora/documentation/knora-base/#standoff-in-digital-editions","text":"Knora\u2019s standoff is designed to make it possible to convert XML documents to standoff and back. One application for this feature is an editing workflow in which an editor works in an XML editor, and the resulting XML documents are converted to standoff and stored in Knora, where they can be searched and annotated. If an editor wants to correct text that has been imported from XML into standoff, the text can be exported as XML, edited, and imported again. To preserve annotations on standoff tags across edits, each tag can automatically be given a UUID. In a future version of the Knora-base ontology, it will be possible to create annotations that point to UUIDs rather than to IRIs. When a text is exported to XML, the UUIDs can be included in the XML. When the edited XML is imported again, it can be converted to new standoff tags with the same UUIDs. Annotations that applied to standoff tags in the previous version of the text will therefore also apply to equivalent tags in the new version. When text is converted from XML into standoff, tags are also given indexes, which are numbered from 0 within the context of a particular text. This makes it possible to order tags that share the same position, and to preserve the hierarchy of the original XML document. An ordinary, hierarchical XML tag is converted to a standoff tag that has one index, as well as the index of its parent tag, if any. The Knora base ontology also supports non-hierarchical markup such as CLIX , which enables overlapping markup to be represented in XML. When non-hierarchical markup is converted to standoff, both the start position and the end position of the standoff tag have indexes and parent indexes. To support these features, a standoff tag can have these additional properties: * kb:standoffTagHasStartIndex (0\u20131): The index of the start position. * kb:standoffTagHasEndIndex : The index of the end position, if this is a non-hierarchical tag. * kb:standoffTagHasStartParent (0\u20131): The IRI of the tag, if any, that contains the start position. * kb:standoffTagHasEndParent (0\u20131): The IRI of the tag, if any, that contains the end position, if this is a non-hierarchical tag. * kb:standoffTagHasUUID (0\u20131): A UUID that can be used to annotate a standoff tag that may be present in different versions of a text, or in different layers of a text (such as a diplomatic transcription and an edited critical text).","title":"Standoff in Digital Editions"},{"location":"developers/knora/documentation/knora-base/#querying-standoff-in-sparql","text":"A future version of Knora will provide an API for querying standoff markup. In the meantime, it is possible to query it directly in SPARQL. For example, here is a SPARQL query (using RDFS inference) that finds all the text values texts that have a standoff date tag referring to Christmas Eve 2016 (Julian Date Number 2457747), contained in a standoff:StandoffItalicTag : PREFIX kb: <http://www.knora.org/ontology/knora-base#> PREFIX standoff: <http://www.knora.org/ontology/standoff#> select * where { ?standoffTag a kb:StandoffDateTag . ?standoffTag kb:valueHasStartJDN ?dateStart . ?standoffTag kb:valueHasEndJDN ?dateEnd . FILTER (2457747 <= ?dateEnd && 2457747 >= ?dateStart) ?standoffTag kb:standoffTagHasStartParent ?parent . ?parent a standoff:StandoffItalicTag . ?textValue kb:valueHasStandoff ?standoffTag . ?textValue kb:valueHasString ?string . ?standoffTag kb:standoffTagHasStart ?startPos . ?standoffTag kb:standoffTagHasEnd ?endPos . }","title":"Querying standoff in SPARQL"},{"location":"developers/knora/documentation/knora-base/#consistency-checking","text":"Knora tries to enforce repository consistency by checking constraints that are specified in the Knora-base ontology and in user-created ontologies. Three types of consistency rules are enforced: * Cardinalities in OWL class definitions must be satisfied. * Constraints on the types of the subjects and objects of OWL object properties must be satisfied. * A datatype property may not have an empty string as an object. The implementation of consistency checking is partly triplestore-dependent; Knora may be able to provide stricter checks with some triplestores than with others.","title":"Consistency checking"},{"location":"developers/knora/documentation/knora-base/#owl-cardinalities","text":"As noted in Resources , each subclass of Resource must use OWL cardinality restrictions to specify the properties it can have. More specifically, a resource is allowed to have a property that is a subproperty of kb:hasValue or kb:hasLinkTo only if the resource\u2019s class has some cardinality for that property. Similarly, a value is allowed to have a subproperty of kb:valueHas only if the value\u2019s class has some cardinality for that property. Knora supports, and attempts to enforce, the following cardinality constraints: * owl:cardinality 1 : A resource of this class must have exactly one instance of the specified property. * owl:minCardinality 1 : A resource of this class must have at least one instance of the specified property. * owl:maxCardinality 1 : A resource of this class may have zero or one instance of the specified property. * owl:minCardinality 0 : A resource of this class may have zero or more instances of the specified property. Knora requires cardinalities to be defined using blank nodes, as in the following example from Knora-base: kb:Representation rdf:type owl:Class ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty kb:hasFileValue ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] . kb:StillImageRepresentation rdf:type owl:Class ; rdfs:subClassOf kb:Representation , [ rdf:type owl:Restriction ; owl:onProperty kb:hasStillImageFileValue ; owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] . The cardinality of a link property must be the same as the cardinality of the corresponding link value property. Each owl:Restriction may have the predicate salsah-gui:guiOrder to indicate the order in which properties should be displayed in a GUI. A resource class inherits cardinalities from its superclasses. This follows from the rules of RDFS inference. Also, in Knora, cardinalities in the subclass can override cardinalities that would otherwise be inherited from the superclass. Specifically, if a superclass has a cardinality on a property P, and a subclass has a cardinality on a subproperty of P, the subclass\u2019s cardinality overrides the superclass\u2019s cardinality. In the example above, kb:hasStillImageFileValue is a subproperty of kb:hasFileValue . Therefore, the cardinality on kb:hasStillImageFileValue overrides (i.e. replaces) the one on kb:hasFileValue . Note that, unlike cardinalities, predicates of properties are not inherited. If ex:foo rdfs:subPropertyOf ex:bar , this does not mean that ex:foo inherits anything from ex:bar . Any predicates of ex:foo that are also needed by ex:bar must be defined explicitly on ex:bar . This design decision was made because property predicate inheritance is not provided by RDFS inference, and would make it more difficult to check the correctness of ontologies, while providing little practical benefit. For more information about OWL cardinalities, see the OWL 2 Primer or RDF .","title":"OWL cardinalities"},{"location":"developers/knora/documentation/knora-base/#constraints-on-the-types-of-property-subjects-and-objects","text":"When a user-created ontology defines a property, it must indicate the types that are allowed as objects (and, if possible, as subjects) of the property. This is done using the following Knora-specific properties: * kb:subjectClassConstraint : Specifies the class that subjects of the property must belong to. This constraint is recommended but not required. Knora will attempt to enforce this constraint. * kb:objectClassConstraint : Specifies the class that objects of the property must belong to. Every subproperty of kb:hasValue or a kb:hasLinkTo - i.e. every property of a resource that points to a kb:Value or to another resource - is required to have this constraint, because Knora relies on it to know what type of object to expect for the property. Knora will attempt to enforce this constraint. * kb:objectDatatypeConstraint : If the property is a datatype property, specifies the type of literals that can be objects of the property. Knora will not attempt to enforce this constraint, but it is useful for documentation purposes. Note that it is possible for a subproperty to have a more restrictive contraint than its base property, by specifing a subject or object class that is a subclass of the one specified in the base property. However, it is not possible for the subproperty to make the base property\u2019s constraint less restrictive.","title":"Constraints on the types of property subjects and objects"},{"location":"developers/knora/documentation/knora-base/#consistency-constraint-example","text":"A user-created ontology could define consistency constraints as in this simplified example: ex:book rdf:type owl:Class ; rdfs:subClassOf kb:Resource , [ rdf:type owl:Restriction ; owl:onProperty ex:hasTitle ; owl:cardinality \"1\"^^xsd:nonNegativeInteger ] , [ rdf:type owl:Restriction ; owl:onProperty ex:hasAuthor ; owl:minCardinality \"0\"^^xsd:nonNegativeInteger ] . ex:hasTitle rdf:type owl:ObjectProperty ; kb:subjectClassConstraint ex:book ; kb:objectClassConstraint kb:TextValue . ex:hasAuthor rdf:type owl:ObjectProperty ; kb:subjectClassConstraint ex:book ; kb:objectClassConstraint kb:TextValue .","title":"Consistency constraint example"},{"location":"developers/knora/documentation/knora-base/#summary-of-restrictions-on-user-created-ontologies","text":"An ontology can refer to a Knora ontology in another project only if the other ontology is built-in or shared.","title":"Summary of restrictions on user-created ontologies"},{"location":"developers/knora/documentation/knora-base/#restrictions-on-classes","text":"Each class must be a subclass of either kb:Resource or kb:StandoffTag , but not both of them. Note that this forbids user-created subclasses of kb:Value ! All the cardinalities that a class defines directly (i.e. does not inherit from kb:Resource ) must be on properties that are defined in the triplestore. Within the cardinalities of a class, there must be a link value property for each link property and vice versa. The cardinality of a link property must be the same as the cardinality of the corresponding link value property. A cardinality on a property with a boolean value must be owl:cardinality 1 or owl:maxCardinality 1 . Each class must be a subclass of all the classes that are subject class constraints of the properties in its cardinalities. If it\u2019s a resource class, all its directly defined cardinalities must be on Knora resource properties (subproperties of kb:hasValue or kb:hasLinkTo ), and all its base classes with Knora IRIs must also be resource classes. A cardinality on kb:resourceProperty or kb:hasValue is forbidden. It must also have an rdfs:label . If it\u2019s a standoff class, none of its cardinalities may be on Knora resource properties, and all its base classes with Knora IRIs must also be standoff classes. A class cannot have a cardinality on property P as well as a cardinality on a subproperty of P.","title":"Restrictions on Classes"},{"location":"developers/knora/documentation/knora-base/#restrictions-on-properties","text":"The property\u2019s subject class constraint, if provided, must be a subclass of kb:Resource or kb:StandoffTag , and must be a subclass of the subject class constraints of all its base properties. Its object class constraint, if provided, must be a subclass of the object class constraints of all its base properties. If the property is a Knora resource property, it must have an object class constraint and an rdfs:label . It can\u2019t be a subproperty of both kb:hasValue and kb:hasLinkTo . It can\u2019t be a subproperty of kb:hasFileValue . Each of its base properties that has a Knora IRI must also be a Knora resource property.","title":"Restrictions on properties"},{"location":"developers/knora/documentation/rdf/","text":"Resource Description Framework (RDF) basics The Resource Description Framework (RDF) is the basic representation language and foundation of the Semantic Web. It addresses the fundamental issue of managing distributed data. All things in the world are referred to as resources . Resources can be anything: documents, people, physical objects as well as abstract concepts. The Resource Description Framework (RDF) is the framework for expressing information about such resources. It is useful if information on the Web is not only displayed, but needs to be processed by applications. The following introduction to RDF draws heavily on the book of Dean Allemang & James Hendler, Semantic Web for the Working Ontologist. Effective Modeling in RDFS and OWL, Second Edition, 2011, 27\u201350 which we warmly recommend for reading. Further information can be found in the RDF 1.1 Primer . A note about the examples in this document It was aimed for to explain all following language features by using only one exemplary project. The setting of the chosen project is the following: It is about archaeological objects stemming from different findspots - known and unknown - and kept in different institutions around the world today. These objects show depictions of mythological scenes that illustrate episodes known from ancient literature, e.g. the Iliad or the Odyssey of Homer, or reflect thoughts of various ancient philosophers about the nature of our world and all creatures living therein. For some of these objects other data and documents exist on the Web, e.g. entries in museum databases, and we may possess low or high resolution images of them. Furthermore, the findspots - if known - can be identified unambigously by reference to geographical databases, e.g. GeoNames. If data are available in tabular form, the rows represent the items we intend to describe and each column represents some property of these items. The cells in the table then denote particular values for these properties. Table 1 shows a small excerpt of such a table from our exemplary project. ID Category City Institution InventoryNr. 1 Ceramics Boston Museum of Fine Arts 28.46 2 Glyptics London British Museum 2717 3 Relief New York Metropolitan Museum 24.97.11 In RDF, each of these cells has to be represented with three values which are called triples : a global reference for the row, a global reference for the column, and the value in the cell itself. The identifier for the row is the subject of the triple, the identifier for the column the predicate of the triple, and the value in the cell the object of the triple. There are three types of RDF data that can occur in triples: I nternational R esource I dentifiers ( IRI s) / U niversal R esource I dentifiers ( URI s), literals and blank nodes . A triple now describes the relationship between two resources which are the subject and the object of the triple. The predicate represents the nature of the relationship between subject and object. The relationship is directional - the predicate always points from the subject to the object - and is called a property . Table 2 shows all the triples of the data in Table 1. |Subject|Predicate|Object| |-----|:----:|---| |ID 1|belongsToCategory|Ceramics| |ID 1|todayIn|Boston| |ID 1|isKeptIn|Museum of Fine Arts| |ID 1|hasInventory|28.46| |ID 2|belongsToCategory|Glyptics| |ID 2|todayIn|London| |ID 2|isKeptIn|British Museum| |ID 2|hasInventory|2717| |ID 3|belongsToCategory|Relief| |ID 3|todayIn|New York| |ID 3|isKeptIn|Metropolitan Museum| |ID 3|hasInventory|24.97.11| Often, the same resource, e.g. a person, is referenced in multiple triples. When more than one triple refers to the same thing, it is more useful to view the triples in a directed graph where each triple is depicted by nodes and arcs: the subjects and objects of the triples are the nodes while the predicates denote the arcs with the predicate as label on the arc: Furthermore, if the subject or object is a URI/IRI or a blank node, it is depicted within an ellipse, if it is a literal value, however, within a rectangle. The graph display of the triples in Table 2 then looks as follows: Let's assume we possess the information in Table 3 from another source which we intend to merge with our data presented in Table 1. |Work|Author|Depiction| |-----|:----:|---| |Iliad|Homer|24.97.11| |Odyssey|Homer|24.97.11| This provides us with the following triples in Table 4: |Subject|Predicate|Object| |-----|:----:|---| |Iliad|hasAuthor|Homer| |Odyssey|hasAuthor|Homer| |Iliad|hasDepictionOn|24.97.11| |Odyssey|hasDepictionOn|24.97.11| The graph display of the triples in Table 2 concerning ID 3 and of the triples in Table 4 looks as follows: Since we now look at one specific example, namely \"ID 3\", all the values are literals and hence depicted in yellow rectangles. Namespaces, Uniform Resource Identifiers (URIs) and International Resource Identifiers (IRIs) If we intend to merge information from different sources, an essential question is whether a node in one graph is the same node as a node in another graph. RDF solves this issue through use of U niform R esource I dentifiers (URIs) or I nternational R esource I dentifiers (IRIs). Our well known web addresses, the URLs, are just a special case of URIs and IRIs. An International Resource Identifier is the internationalised form of a URI. IRIs extend the allowed characters in URIs from a subset of the ASCII character set to almost all characters of the Universal Code Character Set (Unicode / ISO 10646). The syntax of the URI/IRI allows to deference it, i.e. to use all the information in the URI/IRI such as server name, protocol, port number, file name etc. to locate a file or a location on the Web. The possibility of dereferencing enables participation in a global Web infrastructure. URIs and IRIs are painful to write out in detail when expressing models. Hence, it is common to use an abbreviation scheme. Then a URI/IRI has two parts: a namespace and an identifier with a colon in between. The representation for the identifier United Kingdom in the namespace geonames is geonames:UnitedKingdom . URIs/IRIs may not contain embedded spaces. Hence, the so-called InterCap convention is followed: names that consist of multiple words are transformed to identifiers without spaces by capitalizing each word: \"part of\" becomes partOf , \"Measure for Measure\" MeasureForMeasure , and so on. The selection of namespaces is unrestricted. However, it is common practice to refer to related identifiers in a single namespace. Following the above example all geographical information would be placed into the suggestive namespace geonames . These names correspond to fully qualified URIs - geonames stands for material in the geographical database GeoNames . Using URIs/IRIs as standard for global identifiers enables for a worldwide reference and thus, two peolpe anywhere in the world to refer to the same thing unequivocally. This property allows for specifying certain terms by a standard organization such as W3C. W3C standards provide definitions for terms such as e.g. type , Class , subClassOf which are intended to apply globally across the Semantic Web. W3C has defined a number of standard namespaces for use with Web technologies. The most important are: * xsd: Indicates identifiers for XML schema definition. The global IRI for the xsd namespace is http://www.w3.org/2001/XMLSchema# . * xslns: Indicates identifiers for XML namespaces. The global IRI for the xslns namespace is https://www.w3.org/XML/1998/namespace . * rdf: Indicates identifiers used in RDF. The global IRI for the rdf namespace is http://www.w3.org/1999/02/22-rdf-syntax-ns# . * rdfs: Indicates identifiers used for the RDF Schema language (RDFS). The global IRI for the rdfs namespace is http://www.w3.org/2000/01/rdf-schema# . * owl: Indicates identifiers used for the Web Ontology Language (OWL). The global IRI for the owl namespace is http://www.w3.org/2002/07/owl# . Any URI in one of these namespaces - e.g. rdfs:subClassOf which is short for http://www.w3.org/2000/01/rdf-schema#subClassOf - refers to a particular term defined in the RDFS standard by the W3C. The term can also be dereferenced: at the server www.w3.org there is a page at the location 2000/01/rdf-schema with an entry about rdfs:subClassOf which gives additional information about this resource. Literals Literals are values that are not URIs/IRIs. They may be simple strings such as \"Homer\", dates such as \"April 30th, 700 BCE\", numbers such as \"2.71828\". They are often associated with one of the following datatypes (list non-exhaustive): * boolean with value true or false * string with value character string * decimal with an arbitrary-precision decimal number as value * integer with an arbitrary-precision integer number as value * date with value in format yyyy-mm-dd Literals may only appear as object of a triple. Identifiers in the RDF namespace The RDF data model specifies the notion of triples and the merging of sets of triples. With the introduction of namespaces RDF provides agreements on how to refer to a particular entity. The RDF standard defines a small number of standard identifiers in the namespace rdf . rdf:type is a property that provides an elementary system in RDF to define types. rdf:type can be the predicate of a triple, the subject of the triple can be any identifier and the object of the triple is understood to be a type. rdf:type can be used to e.g. state, that Homers works belong to a group of literary works we call Poetry: Subject Predicate Object Iliad rdf:type Poetry Odyssey rdf:type Poetry rdf:Property is an identifier to indicate when another identifier is to be used as a predicate rather than as subject or object. Some triples from our examples in Table 2 and Table 4 can be expressed with rdf:Property in the following way: Subject Predicate Object wrote rdf:type rdf:Property isKeptIn rdf:type rdf:Property hasDepictionOn rdf:type rdf:Property Reification The strict subject - predicate - object form of RDF triples is limiting if one wants to qualify a statement further, if a statement about another statement seems desireable. We may wish to express that our object with ID 3 in Table 1 was bought by the Metropolitan Museum in 1924. Such a process of a statement about a statement is called reification . Reification can be achieved by different approaches. The easiest approach is to add just further triples expressing the desired relationship. myonto:ID3 myonto:todayIn \"New York\" . myonto:ID3 myonto:keptIn \"Metropolitan Museum\" . myonto:ID3 myonto:hasAccessionDate 1924 . The namespace myonto is used in the above example to express that the statements concern resources and properties which are defined in our own namespace. In contrast, otheronto will be used in following examples to express that an external not further defined namespace is referred to. The simple approach shown above works well if more information about some event or statement needs to be specified. However, it doesn't work well in cases when information about the statement itself shall be expressed: We may wish to express that the information that on our object with ID 3 in Table 1 scenes from the Iliad are depicted (information contained in Table 3) stems from the catalogue entry of this object in the online collection of the Metropolitan Museum. Such metadata about statements are often related with provenance indications, likelihood expressions, context information or time spans. In such cases it is necessary to explicitly make a statement about a statement. This process, called explicit reification is supported by the RDF standard with three resources called rdf:subject , rdf:predicate and rdf:object . With the following set of triples we can express that in the online collection of the Metropolitan Museum is written that ID 3 contains a depiction of scenes from the Iliad: myonto:n1 rdf:subject myonto:Iliad ; rdf:predicate myonto:hasDepictionOn ; rdf:object myonto:ID 3 . web:MetropolitanMuseum myonto:says myonto:n1 . Expressing RDF in textual form: Turtle When data are published in RDF on the Web the issue of representing RDF in text arises. There are multiple ways of achieving this. We are using a compact serialization of RDF which is called Turtle . It uses pre-defined shortcuts or namespaces. Since a binding between the local used namespaces and the global URIs/IRIs have to be achieved, Turtle begins with a preamble in which these bindings are defined: @prefix myonto: http://www.myontology @prefix rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# With these abbreviations the triples can be expressed in subject/predicate/object order followed by a period. myonto:HomerWorks rdf:type myonto:Poetry . This statement expresses that Homer's literary works belong to the category of poetry. If several triples share a common subject it need not be repeated each time. Instead of terminating the first triple with a period, a semicolon (;) is used to indicate that another triple with the same subject follows. myonto:Homer rdf:type myonto:Author ; myonto:wrote \"Iliad\" . This statement expresses that in my ontology named myonto Homer is part of my class Author and that he wrote the Iliad. If there are several triples that share both subject and predicate, a comma (,) is used to separate the objects. E.g. to express, that Homer wrote both the Iliad and the Odyssey, I can use the following statement: myonto:Homer myonto:wrote myonto:Iliad, myonto:Odyssey . To improve terseness and readability Turtle provides some abbreviations. The most widley used abbreviation is the word a to mean rdf:type . Thus, the following two triples are equivalent, both telling that the class Ceramics in my ontology is part of a larger class called Category: myonto:Ceramics rdf:type myonto:Category . myonto:Ceramics a myonto:Category . Blank nodes Sometimes we are aware of that something exists, that we know some things about it, but its identity is unknown. We want to express what we know about this resource without bothering to use a global identifier. Such a resource without a global identifier can be represented by a blank node. Blank nodes are comparable to the unknown variables x or y in an equation - they represent something without saying what their value is. Blank nodes can be the subject and/or the object of a triple. Within the framework of our example of archaeological objects showing depictions of Homeric poetry which are held by different institutions, the exact provenience of some objects may be unknown since they stem from illicit excavations and were bought on the antiquities market many years ago. Nevertheless, we know that each object possesses a provenience. A blank node is indicated by square brackets ([]). All triples of which it is a subject are placed within these brackets. The information that if an object was bought on the antiquities market no detail information about its find context is available can be put inside a blank node: [ rdf:type myonto:Market ; myonto:noInfo myonto:FindContext ] Such a blank node can then be referred to in other triples by including the entire bracketed sequence in place of the blank node. The following example expresses that all my objects which belong to the class UnprovenancedObj in my ontology myonto were bought on the antiquities market and for them I have no detail information about their find contexts available: myonto:UnprovenancedObj myonto:isPartOf [ rdf:type myonto:Market ; myonto:noInfo myonto:FindContext ] Ordered information in RDF Ordering of RDF triples has to be specified explicitly: elements can be ordered in a list format. In Turtle an ordered list can be expressed by putting a sequence of objects within brackets (()). If we want to express that the king of Mykene, Agamemnon, was the father of four children, Iphigeneia being the oldest and Orestes being the youngest, we can express that in the following way: Agamemnon myonto:isFatherOf (Iphigeneia, Elektra, Chrysothemis, Orestes) . RDF Schema (RDFS) RDF simply creates a graph structure to represent data. The RDF S chema (RDFS) is a semantic extension of RDF wich provides some guidelines about how to use this graph structure, i.e. it imposes special syntactic conditions or restrictions upon RDF graphs. The schema is informaton about the data. It should help to provide meaning to the data. Thus, it is a layer on top of the RDF layer to describe consistency constraints in the data. The key to these levels is inferencing . The statements of meaning are given in the form of an inference pattern: \"Given some initial information, the following new information can be derived.\" That's the way the RDF Schema language (RDFS) and also the Web Ontology Language (OWL) work. All schema information in RDFS is expressed by RDF triples. The meaning of asserted triples is defined with new inferred triples. The structures that describe the meaning of the data are also in triples. The following introduction to RDF Schema draws heavily on the book of Dean Allemang & James Hendler, Semantic Web for the Working Ontologist. Effective Modeling in RDFS and OWL, Second Edition, 2011, 113\u2013152 which we warmly recommend for reading. Further information can be found in the Recommendations of RDF Schema 1.1 . Asserted triples and inferred triples Asserted triples are triple data that were explicitly added in the original RDF store. Inferred triples are additional triples that are inferred by one of the inference rules. There is no logical distinction between inferred and asserted triples. Hence, one should be careful concerning inference rules and how to implement them. The RDFS and OWL standards define for certain patterns of triples which inferences are valid. The simplest approach is to store all triples in a single store and to ignore whether they are asserted or inferred. This approach is called cached inferencing since all inferences are stored with the data. It is simple, but the number of triples in the triple store increases and some inferred triples may later turn out to be incorrect und unwarranted. The other extreme is to never actually store any inferred triples in any persistent store. Then, inferencing is done in response to queries only. This approach can be called just in time inferencing , since the inferences are made just in time. The query responses are produced such that they respect all the appropriate inferences, but no inferred triple is retained. Both approaches have an important impact if data sources change, i.e. if a triple is deleted or a new triple added. If cached inferencing was chosen, originally inferred triples which are no longer valid must be identified and removed or new ones added. An important variant of just in time inferencing is where explicit inferencing is undesired. What kind of inferencing is needed depends on the required level of expressivity for a certain task. There are different inferencing levels. RDFS operates on a small number of inference rules that deal mostly with relating classes to subclasses and properties to classes. OWL includes constraints on properties and notions of equality and includes rules for describing classes based on allowed values for properties. All these standards use inferencing, but they differ in the inferencing that they support. Classes Resources can be grouped in classes which are themselves resources. The members of such a class are known as instances of the class. Classes are often identified by URIs/IRIs. All RDF datatypes are classes. The instances of a class that is a datatype are the members of the value space of the datatype. Thus, \"3.14\" is an instance of the class decimal, \"4\" is an instance of the class integer, \"2000-01-01\" is an instance of the class date, etc. The basic construct for specifying a group of related resources in RDFS is called an rdfs:Class . The way to express that something is a class is with a triple in which the predicate is rdf:type and the object is rdfs:Class as in the following examples: myonto:Ceramics rdf:type rdfs:Class . myonto:BlackFigured rdf:type rdfs:Class . These triples express that our resources Ceramics and BlackFigured are classes. One of the basic terms is rdfs:subClassOf . The meaning of \" B is a subClassOf C \" is \"every member of class B is also a member of class C\", expressed in the form of an inference. From a further information \" x is a member of B \" one can derive the new information \" x is a member of C \". Speaking more generally, if a class A is a subclass of another class B, then anything of type A is also of type B. This is called the type propagation rule . This feature of inference systems is particulary useful in a Semantic Web context in which new combinations of relationships likely occur as data from multiple sources are merged. In the framework of our example the class BlackFigured is a subclass of the class Ceramics . For any member of the class BlackFigured we can then derive that it is also a member of the class Ceramics due to the following statement : myonto:BlackFigured rdfs:subClassOf myonto:Ceramics . A class may be a member of its own class extension and an instance of itself, this applies e.g. for rdfs:Class . Properties An RDF property describes the relationship between a subject resource and an object resource. Properties with inferences One of the most fundemantal terms in RDFS is rdfs:subPropertyOf . It is a transitive property and allows a modeler to describe a hierarchy of related properties. If we want to express that some of the people who work for a museum are permanently employed while others possess only loose contracts we could express this fact with the following triples: myonto:isEmployedBy rdfs:subPropertyOf myonto:worksFor . myonto:contractsTo rdfs:subPropertyOf myonto:worksFor . Regardless whether a person is employed by the museum or is a contractor, the person works for the museum. Other basic properties are rdfs:range and rdfs:domain . They have meanings inspired by the mathematical use of the words range and domain : the domain of a function is the set of values for which it is defined, its range is the set of values it can take. Both give informaton about how a property P is to be used: domain refers to the subject of any triple that uses P as its predicate, range refers to the object of any such triple. rdfs:domain P rdfs:domain D . means that property P has domain D . From this we can infer that the subject of that triple is a member of the class D . rdfs:domain can be used to specify with which class the defined property can be used with. It is possible to specify multiple rdfs:domain properties when defining a property. We pick just two classes from our example - Ceramics and BlackFigured - which show a subclass relation: myonto:BlackFigured rdfs:subClassOf myonto:Ceramics . We now have a property called incised whose domain is BlackFigured . myonto:incised rdfs:domain myonto:BlackFigured . This means that all my objects with incised decoration belong to the class BlackFigured . rdfs:range P rdfs:range R . means that the property P has range R . From this we can infer that the object (the value of P ) of that triple is a member of class R . If the predicate of a triple has more than one rdfs:range property, the resources denoted by the objects of triples are instances of all the classes stated by the rdfs:range properties. If we want to specify that queens who gave birth to a son could theoretically become queen mothers, we could do that with the following combination of rdfs:domain and rdfs:range : myonto:hasSon rdfs:domain myonto:Queen . myonto:hasSon rdfs:range myonto:QueenMother . It is important to know that if P is used in an inconsistent way with this declaration, RDFS does not signal an error, but rather infers the necessary type information to bring P into accordance with its domain and range declarations! In RDFS, there is no notion of an incorrect or inconsistent inference, i.e. it will never proclaim an input as invalid but simply infer appropriate type information. Domains and ranges are not used to validate information, but to determine new information based on old information. In practice, there are often better and more appropriate options to use instead of rdfs:domain and rdfs:range alone. Properties without inferences RDFS provides some properties from which no inferences can be drawn, i.e. no inference semantics is defined for them. They are useful and important for documentation purposes. These are rdfs:label , rdfs:comment , rdfs:seeAlso and rdfs:isDefinedBy . Resources on the Semantic Web are specified by IRIs/URIs which are not meaningful to people. Thus, RDFS provides the property rdfs:label whose intended use is to provide a human-readable version for any resource's name. Multilingual labels are possible if the language tagging facility of RDF literals is used. myonto:BlackFigured rdfs:label \"black-figured vessels\"@en, \"schwarzfigurige Gef\u00e4sse\"@de . Frequently it is useful to add comments about a model, i.e. to document it properly. In RDFS, rdfs:comment is an instance of rdf:Property that can be used to provide a human-readable description of a resource. Multilingual documentation is possible if the language tagging facility of RDF literals is used. To make a comment a triple using the property rdfs:comment as a predicate has to be asserted. myonto:BlackFigured rdfs:comment \"The class BlackFigured contains ceramic vessels where the decoration is painted with black paint.\" . In the case where a resource is an URL, supplementary information about this resource may be useful. This additional information is often included in documents. rdfs:seeAlso provides a way to specify the web location of such supplementary information. The web location has to be given in the form of an IRI/URI! The precise behaviour of a processor is not specified, but most tools that encounter rdfs:seeAlso link them to those links in a browser or application interface. In our example we could link findspots of archaeological objects to a web resource with geodata, e.g. GeoNames, in the following way: myonto:latitude rdfs:seeAlso geonames:lat . rdfs:isDefinedby provides a link to the primary resource of information about a resource. Thus, the definitional description of a resource can be found, e.g. rdfs:isDefinedBy is defined in RDF to be a rdfs:subPropertyOf of rdfs:seeAlso . Combinations and patterns Intersection RDFS inference rules are few and rather simple. More specific patterns can be obtained by combining basic RDFS features. One such case is set intersection. If we intend to draw the inference that if a resource x is an instance of class C , then it should also be an instance of classes A and B , expressing the formal relationship C \u2286 A \u2229 B . Such an inference can be obtained by making C a subclass of A and B : :C rdfs:subClassOf :A . :C rdfs:subClassOf :B . Due to the inference rule defined for rdfs:subClassOf we can infer from the triple x rdf:type :C . the desired triples x rdf:type :A . x rdf:type :B . Thus, from a membership in C membership in A and B can be inferred. But from membership in A and B membership in C cannot be inferred! Inferences can only be drawn in one direction. In an analogous way to the treatment of classes, set intersection can be defined for properties using the construct rdfs:subPropertyOf . Union The union of two sets ( A \u222a B \u2286 C ) can be obtained by making C a superclass of A and B . :A rdfs:subClassOf :C . :B rdfs:subClassOf :C . Then, for any instance x that is either a member of class A or of B it will be inferred that it is also a member of class C . In an analogous way to the treatment of classes, set union can be defined for properties using rdfs:subPropertyOf . Collections A collection is represented as a list of items. rdf:List is an instance of rdfs:Class that can be used to build descriptions of lists and other list-like structures. Summary The following Figure 4 illustrates the concepts of resource, class, and sub-class based on our example project. Figure 5 shows the same in a more general way: resources are denoted by a large black dot and arrows are drawn from a resource to the class it defines. A sub-class is shown by a rectangle (the sub-class) completely enclosed by another (the super-class), i.e. class ConstraintProperty is a subclass of class Property. The notion rdf:type specifies that something is a member of a group, i.e. an instance of a class. By using rdfs:Class instead of rdf:type a description of the meaning of a membership in a group is gained. Meaning is expressed through the mechanisms of inference in RDFS that can be drawn when a resource is used in a certain way. The following Figure 6 expresses the same information about the class hierarchy, but does so using a graphic representation of the RDF data model. If a class is a subset of another, there is an arc labelled \"s\" from the node representing the first class to the node representing the second one (\"s\" stands for rdfs:subClassOf ). If a resource was an instance of a class, then there is an arc labelled \"t\" from the resource to the node representing the class (\"t\" stands for rdf:type ). Not all arcs are drawn, e.g. rdfs:ConstraintProperty is a subclass of rdfs:Resource because it is a subclass of rdf:Property which is a subclass of rdfs:Resource . Examples: - The class rdfs:Literal is an instance of rdfs:Class and an instance of rdfs:Resource . - The class rdf:Property is the class of RDF properties and an instance of rdfs:Class . Web Ontology Language (OWL) OWL is intended to be used when information contained in documents needs to be processed by applications, it explicitly represents the meaning of terms in vocabularies and the relationship between those terms. The representation of terms and their interrelationships are called an ontology . A concrete syntax is needed in order to store ontologies and to exchange them among tools and applications. The primary exchange syntax for OWL is the XML syntax for RDF (RDF/XML), but other syntaxes such as e.g. Turtle are also frequently used. The data described by an OWL ontology is interpreted as a set of \"individuals\" and a set of \"property assertions\" which relate these individuals to each other. An ontology consists of a set of axioms which place constraints on sets of individuals called \"classes\" and the types of relationships permitted between them. OWL ontologies can import other ontologies, adding information from the imported ontology to the current ontology. The main building blocks of the OWL language are an RDF graph and at least one concrete syntax - there may be more than one - that can be used to serialize and exchange ontologies. OWL has been designed to meet the needs for a Web Ontology Language. It is part of the W3C recommendations related to the Semantic Web: - XML provides a surface syntax for structured documents, but imposes no semantic constraints. - XML Schema is a language for restricting the structure of XML documents and extends XML with datatypes. - RDF is a datamodel for objects and relations between them. Furthermore, it provides a simple semantics for this datamodel and these datamodels can be represented in an XML syntax. - RDF Schema is a vocabulary for describing properties and classes of RDF resources, with a semantics for generalization-hierarchies of such properties and classes. - OWL then adds more vocabulary to RDF for describing properties and classes: e.g. relations between classes, cardinality, equality, characteristics of properties and enumerated classes. The following introduction to OWL draws heavily on the book of Dean Allemang & James Hendler, Semantic Web for the Working Ontologist. Effective Modeling in RDFS and OWL, Second Edition, 2011, 153\u2013305 which we warmly recommend for reading. Further information can be found in the Recommendations of the OWL 2 Web Ontology Language Document Overview (Second Edition) and the Wikipedia entry of OWL . owl:Class In OWL, a Class defines a group of individuals that belong together because they share some properties. An owl:Class differs from an rdfs:Class - an owl:Class is a special case of an rdfs:Class . Classes can be organised in a hierarchy using rdfs:subClassOf . Thus, owl:Class is defined as a subclass of rdfs:Class : owl:Class rdfs:subClassOf rdfs:Class . This means that every member of an owl:Class is also a member of rdfs:Class . There is a built-in most general class named owl:Thing which is the class of all individuals. It is a superclass of all OWL classes. There is also a built-in class named owl:Nothing which is the class that has no instances. It is a subclass of all OWL classes. owl:inverseOf Extra language features that are not directly provided by OWL, but that one may desire, such as e.g. superClassOf , are often supported by OWL as a combination of other features. The construct owl:inverseOf inverses a property, i.e. the direction of the property is reversed. This property can be used to define e.g. the superClassOf of a resource by combining it with rdfs:subClassOf in the following way: myonto:superClassOf owl:inverseOf rdfs:subClassOf . owl:SymmetricProperty For a symmetric property holds that if a pair (x,y) is an instance of the property P, then also the pair (y,x) is an instance of this property P. Such a property is provided by owl:SymmetricProperty and expressed in OWL as a Class. An example for such a property is to be married - if Agamemnon is married to Klytaimnestra, Klytaimnestra is also married to Agamemnon. Thus we can define a property married in our ontology with the following triples: myonto:married rdf:type owl:SymmetricProperty . Agamemnon myonto:married Klytaimnestra . Be aware - to make sure that owl:inverseOf works in both directions, one has to assert that owl:inverseOf rdf:type owl:SymmetricProperty . owl:TransitiveProperty Another important property is transitivity. Transitivity is a relation between three elements such that if it holds between the first and second and it also holds between the second and third, it must necessarily hold between the first and the third. In OWL, transitivity is provided by the construct owl:TransitiveProperty which is a class of properties. To model the property isLocatedIn in our ontology as a member of the transitive class we can state myonto:isLocatedIn rdf:type owl:TransitiveProperty . Together with the triples Rome myonto:isLocatedIn Italy . Italy myonto:isLocatedIn Europe . we can infer that Rome is located in Europe. owl:equivalentClass A frequent situation is that if information about the same entity from different sources is merged then the two providers of this information will not have used the same URI/IRI for refering to the same entity. When combining these data it may be useful to state that two URIs/IRIs actually refer to the same entity. When two classes are known to always have the same members, they are said to be equivalent . Such a situation can be expressed with one simple statement using owl:equivalentClass : owl:equivalentClass rdf:type owl:SymmetricProperty . myonto:GreekGods owl:equivalentClass otheronto:Deities . The second triple expresses that the class GreekGods in our ontology is equivalent to the class Deities in some other ontology we refer to. Note that when two classes are equivalent, it only means that they have the same members. But other properties of these classes aren't shared! owl:equivalentProperty If one intends to state that two properties are equivalent, owl:equivalentProperty can be used: myonto:isInvisible owl:equivalentClass otheronto:notSeen . This statement expresses that the property which is called isInvisible in our ontology, is named notSeen in some other ontology. owl:sameAs If it turns out that two individuals are actually one and the same, owl:sameAs can be used to state this fact: myonto:Puteoli owl:sameAs otheronto:Puzzeoli . This statement expresses that the site which is called Puteoli in our ontology, is the same as a site named Puzzeoli in some other ontology. owl:FunctionalProperty A functional property owl:FunctionalProperty is a property which can only have one single value. An everyday example for such a property is e.g. hasBirthplace since each person has only one birth place. Functional properties can be useful to infer sameness, e.g. if names with foreign characters are transliterated differently in two sources - a Greek \"B\" may be transliterated either as \"B\" or as \"V\", we can state: myonto:GreekB owl:FunctionalProperty otheronto:GreekV . owl:InverseFunctionalProperty However, it is more common to use the related notion of owl:InverseFunctionalProperty . One can think of this construct to be the inverse of owl:FunctionalProperty as its name suggests. Especially identifying numbers are inverse functional properties. myonto:hasInventoryNumber rdf:type owl:InverseFunctionalProperty . myonto:ID3 myonto:hasInventoryNumber \"24.97.11\" . otheronto:ID2435 myonto:hasInventoryNumber \"24.97.11\" . From the above example follows that ID 3 in my data set is the same object as ID 2435 in another data set. It is sometimes useful for a single property to be an owl:FunctionalProperty and an owl:InverseFunctionalProperty . This means that it is a one-to-one property: for each individual there is exactly one value for the property and the other way round. This feature is intended in the case of unique identifiers as in the following example: myonto:hasID rdfs:domain myonto:Monument . myonto:hasID rdfs:range xsd:Integer . myonto:hasID rfd:type owl:FunctionalProperty . myonto:hasID rfd:type owl:InverseFunctionalProperty . This means that each member of class Monument possesses a unique identifier that is an integer number. Any two monuments that share an ID must be the same (due to inverse functionality) and in addition, each monument can have at most one ID (due to functionality). owl:ObjectProperty and owl:DatatypeProperty The constructs owl:sameAs , owl:FunctionalProperty and owl:InverseFunctionalProperty especially help to describe how information from multiple sources can be merged. OWL can also provide useful information for editing tools if a value of some property may be either a link to another object or a widget for a particular data type. For this purpose OWL distinguishes between owl:DatatypeProperty and owl:ObjectProperty . owl:DatatypeProperty can have a data value as object, owl:ObjectProperty can have a resource as object. myonto:inSameMuseum rdf:type owl:ObjectProperty. myonto:shipVoyage rdf:type owl:DatatypeProperty. The first example may be used to express that one archaeological object is kept in the same museum as another archaeological object while the second example may select those individuals who participated in a ship voyage such as e.g. the Argonauts. Restrictions The construct owl:Restriction allows to describe individuals of classes in terms of existing properties and classes that have already been modeled. The class of all things in OWL called owl:Thing is unrestricted. A restriction provides some description that limits the kinds of things that can be said about a member of the class. A restriction class in OWL is defined by the keyword owl:onProperty . A description of how the new class is constrained can be provided e.g. by owl:allValuesFrom , owl:someValuesFrom and owl:hasValue . The membership in a restriction class must satisfy the specified conditions as well as the owl:onProperty specification. Property constraints owl:someValuesFrom selects all individuals from a class for which at least one value of the property P comes from class C . In our example we can formulate such a restriction as: [a owl:Restriction; owl:onProperty myonto:isLocatedIn; owl:someValuesFrom myonto:Museum] All archaeological objects kept in a museum today thus have been defined as all archaeological objects for which at least one value of the property isLocatedIn comes from the class Museum . The [ ] notation refers to a blank node which is described by the properties listed here. This restriction class has no specific name associated with it - it is defined by the properties of the restriction and is hence called an unnamed class . owl:allValuesFrom selects all individuals from a class for which all values of the property P come from class C . In our example we can formulate such a restriction as: [a owl:Restriction; owl:onProperty myonto:hasProvenience; owl:allValuesFrom myonto:Findspot] This restriction selects all our archaeological objects for which the findspot is known. A noteworthy difference between owl:someValuesFrom and owl:allValuesFrom is that the former implies that there must be such a member, while the latter technically means if there are any members, then they all must have this property which doesn't imply that there are any members. owl:hasValue is used to produce a restriction of the form \"all individuals that have the value A for the property P \". We can formulate such a restriction as: [ a owl:Restriction ; owl:onProperty myonto:P ; owl:hasValue myonto:A ] . Let's assume we defined a property myonto:hasImage which helps to select archaeological objects for which we possess images. We can now state a restriction for those with high resolution images: myonto:HighResolutionObject owl:equivalentClass [ a owl:Restriction ; owl:onProperty myonto:hasImage; owl:hasValue myonto:hasHighresImage ] . That we have such a high resolution image of a certain object we can formulate with the following triple: myonto:ID3 myonto:hasImage myonto:hasHighresImage . Then it is possible to deduce myonto:ID3 a myonto:HighResolutionObject . owl:hasValue is just a special case of the owl:someValuesFrom restriction. Nevertheless, it is very useful because it effectively turns specific instance descriptions into class descriptions. OWL provides a facility for defining new classes as unions ( owl:unionOf ) and intersections ( owl:intersectionOf ) of previously defined classes. The union of two or more classes includes the members of all those classes while the intersection includes only those that belong to every one of the classes. OWL allows to enumerate the members of a class using the construct owl:oneOf . If I have a class myonto:ObjectsSomeSmallMuseum with the members \"vase1\", \"vase2\" and \"relief1\", then: myonto:ObjectsSomeSmallMuseum rdf:type owl:Class; owl:oneOf (myonto:vase1 myonto:vase2 myonto:relief1). My class myonto:ObjectsSomeSmallMuseum is related via the property owl:oneOf to a list of the members of the class. However, owl:oneOf should be used only in situations in which the definition of the class is not likely to change at all or at least not frequently. One such case would e.g. be the number of planets in the solar system. In contrast, the above example may be appropriate for our own immediate needs, but not for a more general approach: although we include only three objects of this small museum in our data, the museum itself for sure owns many more. Sometimes it may be useful to state that one thing is different from another thing. OWL provides owl:differentFrom for this. An example is the following: myonto:Zenon owl:differentFrom otheronto:Zenon. Two different ancient Greek philosophers with the name Zenon are known. The above triple states that the Zenon in our ontology (e.g. Zenon of Elea) is not the same Zenon as in another ontology (e.g. Zenon of Kition). Cardinalities OWL also includes restrictions that refer to cardinalities , i.e. the number of values for a specific property. Cardinality restrictions can be used to define sets of particular interest. Cardinality refers to the number of distinct values a property has. The fact that we only know about two works attributed to Homer - the Iliad and the Odyssey - we may state by using owl:cardinality : [a owl:Restriction; owl:onProperty myonto:HomerWorks; owl:cardinality 2] Cardinality restrictions can also be used to specify upper and lower boundaries, the respective constructs are named owl:maxCardinality and owl:minCardinality . The restriction to cardinalities of 0 and 1 have special modeling utility: minCardinality 0 indicates a set of individuals for which some value for a specified property is optional minCardinality 1 indicates a set of individuals for which some value for a specified property is required maxCardinality 0 specifies that no value for the specified property is allowed maxCardinality 1 specifies that a value is unique (but need not exist) Reasoning with individuals and classes From an RDF perspective inferences about individuals and inferences about classes are very similar: in both cases new triples are added to the model based on the asserted triples. However, from a modeling perspective, these two kinds of reasoning are very different. The former draws specific conclusions about individuals while the latter draws general conclusions about classes of individuals. In the case of reasoning about individuals the information specified in one source is transformed according to a model for use in another context with the help of constructs such as rdfs:subClassOf , rdfs:subPropertyOf and various owl:Restriction . Class reasoning determines how data are related in general with constructs such as rdfs:subClassOf , rdfs:subPropertyOf , rdfs:domain or rdfs:range . Once these more general relationships have been inferred, the processing of the data can be done much easier. Composing files OWL provides a built-in class owl:Ontology . The URI/IRI of an ontology usually corresponds to the URL of the file on the Web where the ontology is stored. The corresponding URI/IRI can be eclosed in angle brackets as follows: <http://www.knora.org/ontology/knora-base> rdf:type owl:Ontology. This can be useful when modularity of semantic models is specified. The most frequent way to specify modularity is with the property owl:imports . This property connects two instances of the class owl:Ontology . Summary of constructs rdfs:subClassOf - the members of a subclass are also a member of a superclass rdfs:subPropertyOf - relations described by a subproperty also hold for the superproperty rdfs:domain - the subject of a triple is classified into the domain of the predicate rdfs:range - the object of a triple is classified into the range of the predicate rdfs:label - human-readable name of a resource, no semantics inferable rdfs:comment - human-readable information of the model, no semantics inferable owl:equivalentClass - the members of each class are also members of the other class owl:equivalentProperty - relations that hold for each property also hold for the other property owl:sameAs - all statements about one instance hold for the other instance owl:inverseOf - exchanges subject and object owl:TransitiveProperty - the chains of a relationship collapse into a single relationship owl:SymmetricProperty - the property is its own inverse owl:FunctionalProperty - only one value as object allowed owl:InverseFunctionalProperty - only one value as subject allowed owl:ObjectProperty - the property can have a resource as object owl:DatatypeProperty - the property can have a data value as object owl:Restriction - a building block in OWL that describes classes by restricting the values that are allowed for certain properties owl:hasValue - a type of restriction that refers to a single value for a property owl:someValuesFrom - a type of restriction that refers to a set from which some value for a property must come owl:allValuesFrom - a type of restriction that refers to a set from which all values for a property must come owl:onProperty - a link from a restriction to the property it restricts. owl:unionOf - unites classes and creates a new class owl:intersectionOf - determines the intersection of classes and creates a new class owl:complementOf - determines the compliment of a class and creates a new class owl:oneOf - specifies that a class consists just of the listed members owl:differentFrom - specifies that one individual is not identical to another one owl:disjointWith - specifies that two classes cannot share a member owl:cardinality - specifies information about the number of distict values for some property owl:minCardinality - specifies information about the minimum number of distinct values for a property owl:maxCardinality - specifies information about the maximum number of distinct values for a property owl:imports - allows one ontology to refer explicitly to another ontology.","title":"RDF"},{"location":"developers/knora/documentation/rdf/#resource-description-framework-rdf-basics","text":"The Resource Description Framework (RDF) is the basic representation language and foundation of the Semantic Web. It addresses the fundamental issue of managing distributed data. All things in the world are referred to as resources . Resources can be anything: documents, people, physical objects as well as abstract concepts. The Resource Description Framework (RDF) is the framework for expressing information about such resources. It is useful if information on the Web is not only displayed, but needs to be processed by applications. The following introduction to RDF draws heavily on the book of Dean Allemang & James Hendler, Semantic Web for the Working Ontologist. Effective Modeling in RDFS and OWL, Second Edition, 2011, 27\u201350 which we warmly recommend for reading. Further information can be found in the RDF 1.1 Primer .","title":"Resource Description Framework (RDF) basics"},{"location":"developers/knora/documentation/rdf/#a-note-about-the-examples-in-this-document","text":"It was aimed for to explain all following language features by using only one exemplary project. The setting of the chosen project is the following: It is about archaeological objects stemming from different findspots - known and unknown - and kept in different institutions around the world today. These objects show depictions of mythological scenes that illustrate episodes known from ancient literature, e.g. the Iliad or the Odyssey of Homer, or reflect thoughts of various ancient philosophers about the nature of our world and all creatures living therein. For some of these objects other data and documents exist on the Web, e.g. entries in museum databases, and we may possess low or high resolution images of them. Furthermore, the findspots - if known - can be identified unambigously by reference to geographical databases, e.g. GeoNames. If data are available in tabular form, the rows represent the items we intend to describe and each column represents some property of these items. The cells in the table then denote particular values for these properties. Table 1 shows a small excerpt of such a table from our exemplary project. ID Category City Institution InventoryNr. 1 Ceramics Boston Museum of Fine Arts 28.46 2 Glyptics London British Museum 2717 3 Relief New York Metropolitan Museum 24.97.11 In RDF, each of these cells has to be represented with three values which are called triples : a global reference for the row, a global reference for the column, and the value in the cell itself. The identifier for the row is the subject of the triple, the identifier for the column the predicate of the triple, and the value in the cell the object of the triple. There are three types of RDF data that can occur in triples: I nternational R esource I dentifiers ( IRI s) / U niversal R esource I dentifiers ( URI s), literals and blank nodes . A triple now describes the relationship between two resources which are the subject and the object of the triple. The predicate represents the nature of the relationship between subject and object. The relationship is directional - the predicate always points from the subject to the object - and is called a property . Table 2 shows all the triples of the data in Table 1. |Subject|Predicate|Object| |-----|:----:|---| |ID 1|belongsToCategory|Ceramics| |ID 1|todayIn|Boston| |ID 1|isKeptIn|Museum of Fine Arts| |ID 1|hasInventory|28.46| |ID 2|belongsToCategory|Glyptics| |ID 2|todayIn|London| |ID 2|isKeptIn|British Museum| |ID 2|hasInventory|2717| |ID 3|belongsToCategory|Relief| |ID 3|todayIn|New York| |ID 3|isKeptIn|Metropolitan Museum| |ID 3|hasInventory|24.97.11| Often, the same resource, e.g. a person, is referenced in multiple triples. When more than one triple refers to the same thing, it is more useful to view the triples in a directed graph where each triple is depicted by nodes and arcs: the subjects and objects of the triples are the nodes while the predicates denote the arcs with the predicate as label on the arc: Furthermore, if the subject or object is a URI/IRI or a blank node, it is depicted within an ellipse, if it is a literal value, however, within a rectangle. The graph display of the triples in Table 2 then looks as follows: Let's assume we possess the information in Table 3 from another source which we intend to merge with our data presented in Table 1. |Work|Author|Depiction| |-----|:----:|---| |Iliad|Homer|24.97.11| |Odyssey|Homer|24.97.11| This provides us with the following triples in Table 4: |Subject|Predicate|Object| |-----|:----:|---| |Iliad|hasAuthor|Homer| |Odyssey|hasAuthor|Homer| |Iliad|hasDepictionOn|24.97.11| |Odyssey|hasDepictionOn|24.97.11| The graph display of the triples in Table 2 concerning ID 3 and of the triples in Table 4 looks as follows: Since we now look at one specific example, namely \"ID 3\", all the values are literals and hence depicted in yellow rectangles.","title":"A note about the examples in this document"},{"location":"developers/knora/documentation/rdf/#namespaces-uniform-resource-identifiers-uris-and-international-resource-identifiers-iris","text":"If we intend to merge information from different sources, an essential question is whether a node in one graph is the same node as a node in another graph. RDF solves this issue through use of U niform R esource I dentifiers (URIs) or I nternational R esource I dentifiers (IRIs). Our well known web addresses, the URLs, are just a special case of URIs and IRIs. An International Resource Identifier is the internationalised form of a URI. IRIs extend the allowed characters in URIs from a subset of the ASCII character set to almost all characters of the Universal Code Character Set (Unicode / ISO 10646). The syntax of the URI/IRI allows to deference it, i.e. to use all the information in the URI/IRI such as server name, protocol, port number, file name etc. to locate a file or a location on the Web. The possibility of dereferencing enables participation in a global Web infrastructure. URIs and IRIs are painful to write out in detail when expressing models. Hence, it is common to use an abbreviation scheme. Then a URI/IRI has two parts: a namespace and an identifier with a colon in between. The representation for the identifier United Kingdom in the namespace geonames is geonames:UnitedKingdom . URIs/IRIs may not contain embedded spaces. Hence, the so-called InterCap convention is followed: names that consist of multiple words are transformed to identifiers without spaces by capitalizing each word: \"part of\" becomes partOf , \"Measure for Measure\" MeasureForMeasure , and so on. The selection of namespaces is unrestricted. However, it is common practice to refer to related identifiers in a single namespace. Following the above example all geographical information would be placed into the suggestive namespace geonames . These names correspond to fully qualified URIs - geonames stands for material in the geographical database GeoNames . Using URIs/IRIs as standard for global identifiers enables for a worldwide reference and thus, two peolpe anywhere in the world to refer to the same thing unequivocally. This property allows for specifying certain terms by a standard organization such as W3C. W3C standards provide definitions for terms such as e.g. type , Class , subClassOf which are intended to apply globally across the Semantic Web. W3C has defined a number of standard namespaces for use with Web technologies. The most important are: * xsd: Indicates identifiers for XML schema definition. The global IRI for the xsd namespace is http://www.w3.org/2001/XMLSchema# . * xslns: Indicates identifiers for XML namespaces. The global IRI for the xslns namespace is https://www.w3.org/XML/1998/namespace . * rdf: Indicates identifiers used in RDF. The global IRI for the rdf namespace is http://www.w3.org/1999/02/22-rdf-syntax-ns# . * rdfs: Indicates identifiers used for the RDF Schema language (RDFS). The global IRI for the rdfs namespace is http://www.w3.org/2000/01/rdf-schema# . * owl: Indicates identifiers used for the Web Ontology Language (OWL). The global IRI for the owl namespace is http://www.w3.org/2002/07/owl# . Any URI in one of these namespaces - e.g. rdfs:subClassOf which is short for http://www.w3.org/2000/01/rdf-schema#subClassOf - refers to a particular term defined in the RDFS standard by the W3C. The term can also be dereferenced: at the server www.w3.org there is a page at the location 2000/01/rdf-schema with an entry about rdfs:subClassOf which gives additional information about this resource.","title":"Namespaces, Uniform Resource Identifiers (URIs) and International Resource Identifiers (IRIs)"},{"location":"developers/knora/documentation/rdf/#literals","text":"Literals are values that are not URIs/IRIs. They may be simple strings such as \"Homer\", dates such as \"April 30th, 700 BCE\", numbers such as \"2.71828\". They are often associated with one of the following datatypes (list non-exhaustive): * boolean with value true or false * string with value character string * decimal with an arbitrary-precision decimal number as value * integer with an arbitrary-precision integer number as value * date with value in format yyyy-mm-dd Literals may only appear as object of a triple.","title":"Literals"},{"location":"developers/knora/documentation/rdf/#identifiers-in-the-rdf-namespace","text":"The RDF data model specifies the notion of triples and the merging of sets of triples. With the introduction of namespaces RDF provides agreements on how to refer to a particular entity. The RDF standard defines a small number of standard identifiers in the namespace rdf . rdf:type is a property that provides an elementary system in RDF to define types. rdf:type can be the predicate of a triple, the subject of the triple can be any identifier and the object of the triple is understood to be a type. rdf:type can be used to e.g. state, that Homers works belong to a group of literary works we call Poetry: Subject Predicate Object Iliad rdf:type Poetry Odyssey rdf:type Poetry rdf:Property is an identifier to indicate when another identifier is to be used as a predicate rather than as subject or object. Some triples from our examples in Table 2 and Table 4 can be expressed with rdf:Property in the following way: Subject Predicate Object wrote rdf:type rdf:Property isKeptIn rdf:type rdf:Property hasDepictionOn rdf:type rdf:Property","title":"Identifiers in the RDF namespace"},{"location":"developers/knora/documentation/rdf/#reification","text":"The strict subject - predicate - object form of RDF triples is limiting if one wants to qualify a statement further, if a statement about another statement seems desireable. We may wish to express that our object with ID 3 in Table 1 was bought by the Metropolitan Museum in 1924. Such a process of a statement about a statement is called reification . Reification can be achieved by different approaches. The easiest approach is to add just further triples expressing the desired relationship. myonto:ID3 myonto:todayIn \"New York\" . myonto:ID3 myonto:keptIn \"Metropolitan Museum\" . myonto:ID3 myonto:hasAccessionDate 1924 . The namespace myonto is used in the above example to express that the statements concern resources and properties which are defined in our own namespace. In contrast, otheronto will be used in following examples to express that an external not further defined namespace is referred to. The simple approach shown above works well if more information about some event or statement needs to be specified. However, it doesn't work well in cases when information about the statement itself shall be expressed: We may wish to express that the information that on our object with ID 3 in Table 1 scenes from the Iliad are depicted (information contained in Table 3) stems from the catalogue entry of this object in the online collection of the Metropolitan Museum. Such metadata about statements are often related with provenance indications, likelihood expressions, context information or time spans. In such cases it is necessary to explicitly make a statement about a statement. This process, called explicit reification is supported by the RDF standard with three resources called rdf:subject , rdf:predicate and rdf:object . With the following set of triples we can express that in the online collection of the Metropolitan Museum is written that ID 3 contains a depiction of scenes from the Iliad: myonto:n1 rdf:subject myonto:Iliad ; rdf:predicate myonto:hasDepictionOn ; rdf:object myonto:ID 3 . web:MetropolitanMuseum myonto:says myonto:n1 .","title":"Reification"},{"location":"developers/knora/documentation/rdf/#expressing-rdf-in-textual-form-turtle","text":"When data are published in RDF on the Web the issue of representing RDF in text arises. There are multiple ways of achieving this. We are using a compact serialization of RDF which is called Turtle . It uses pre-defined shortcuts or namespaces. Since a binding between the local used namespaces and the global URIs/IRIs have to be achieved, Turtle begins with a preamble in which these bindings are defined: @prefix myonto: http://www.myontology @prefix rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# With these abbreviations the triples can be expressed in subject/predicate/object order followed by a period. myonto:HomerWorks rdf:type myonto:Poetry . This statement expresses that Homer's literary works belong to the category of poetry. If several triples share a common subject it need not be repeated each time. Instead of terminating the first triple with a period, a semicolon (;) is used to indicate that another triple with the same subject follows. myonto:Homer rdf:type myonto:Author ; myonto:wrote \"Iliad\" . This statement expresses that in my ontology named myonto Homer is part of my class Author and that he wrote the Iliad. If there are several triples that share both subject and predicate, a comma (,) is used to separate the objects. E.g. to express, that Homer wrote both the Iliad and the Odyssey, I can use the following statement: myonto:Homer myonto:wrote myonto:Iliad, myonto:Odyssey . To improve terseness and readability Turtle provides some abbreviations. The most widley used abbreviation is the word a to mean rdf:type . Thus, the following two triples are equivalent, both telling that the class Ceramics in my ontology is part of a larger class called Category: myonto:Ceramics rdf:type myonto:Category . myonto:Ceramics a myonto:Category .","title":"Expressing RDF in textual form: Turtle"},{"location":"developers/knora/documentation/rdf/#blank-nodes","text":"Sometimes we are aware of that something exists, that we know some things about it, but its identity is unknown. We want to express what we know about this resource without bothering to use a global identifier. Such a resource without a global identifier can be represented by a blank node. Blank nodes are comparable to the unknown variables x or y in an equation - they represent something without saying what their value is. Blank nodes can be the subject and/or the object of a triple. Within the framework of our example of archaeological objects showing depictions of Homeric poetry which are held by different institutions, the exact provenience of some objects may be unknown since they stem from illicit excavations and were bought on the antiquities market many years ago. Nevertheless, we know that each object possesses a provenience. A blank node is indicated by square brackets ([]). All triples of which it is a subject are placed within these brackets. The information that if an object was bought on the antiquities market no detail information about its find context is available can be put inside a blank node: [ rdf:type myonto:Market ; myonto:noInfo myonto:FindContext ] Such a blank node can then be referred to in other triples by including the entire bracketed sequence in place of the blank node. The following example expresses that all my objects which belong to the class UnprovenancedObj in my ontology myonto were bought on the antiquities market and for them I have no detail information about their find contexts available: myonto:UnprovenancedObj myonto:isPartOf [ rdf:type myonto:Market ; myonto:noInfo myonto:FindContext ]","title":"Blank nodes"},{"location":"developers/knora/documentation/rdf/#ordered-information-in-rdf","text":"Ordering of RDF triples has to be specified explicitly: elements can be ordered in a list format. In Turtle an ordered list can be expressed by putting a sequence of objects within brackets (()). If we want to express that the king of Mykene, Agamemnon, was the father of four children, Iphigeneia being the oldest and Orestes being the youngest, we can express that in the following way: Agamemnon myonto:isFatherOf (Iphigeneia, Elektra, Chrysothemis, Orestes) .","title":"Ordered information in RDF"},{"location":"developers/knora/documentation/rdf/#rdf-schema-rdfs","text":"RDF simply creates a graph structure to represent data. The RDF S chema (RDFS) is a semantic extension of RDF wich provides some guidelines about how to use this graph structure, i.e. it imposes special syntactic conditions or restrictions upon RDF graphs. The schema is informaton about the data. It should help to provide meaning to the data. Thus, it is a layer on top of the RDF layer to describe consistency constraints in the data. The key to these levels is inferencing . The statements of meaning are given in the form of an inference pattern: \"Given some initial information, the following new information can be derived.\" That's the way the RDF Schema language (RDFS) and also the Web Ontology Language (OWL) work. All schema information in RDFS is expressed by RDF triples. The meaning of asserted triples is defined with new inferred triples. The structures that describe the meaning of the data are also in triples. The following introduction to RDF Schema draws heavily on the book of Dean Allemang & James Hendler, Semantic Web for the Working Ontologist. Effective Modeling in RDFS and OWL, Second Edition, 2011, 113\u2013152 which we warmly recommend for reading. Further information can be found in the Recommendations of RDF Schema 1.1 .","title":"RDF Schema (RDFS)"},{"location":"developers/knora/documentation/rdf/#asserted-triples-and-inferred-triples","text":"Asserted triples are triple data that were explicitly added in the original RDF store. Inferred triples are additional triples that are inferred by one of the inference rules. There is no logical distinction between inferred and asserted triples. Hence, one should be careful concerning inference rules and how to implement them. The RDFS and OWL standards define for certain patterns of triples which inferences are valid. The simplest approach is to store all triples in a single store and to ignore whether they are asserted or inferred. This approach is called cached inferencing since all inferences are stored with the data. It is simple, but the number of triples in the triple store increases and some inferred triples may later turn out to be incorrect und unwarranted. The other extreme is to never actually store any inferred triples in any persistent store. Then, inferencing is done in response to queries only. This approach can be called just in time inferencing , since the inferences are made just in time. The query responses are produced such that they respect all the appropriate inferences, but no inferred triple is retained. Both approaches have an important impact if data sources change, i.e. if a triple is deleted or a new triple added. If cached inferencing was chosen, originally inferred triples which are no longer valid must be identified and removed or new ones added. An important variant of just in time inferencing is where explicit inferencing is undesired. What kind of inferencing is needed depends on the required level of expressivity for a certain task. There are different inferencing levels. RDFS operates on a small number of inference rules that deal mostly with relating classes to subclasses and properties to classes. OWL includes constraints on properties and notions of equality and includes rules for describing classes based on allowed values for properties. All these standards use inferencing, but they differ in the inferencing that they support.","title":"Asserted triples and inferred triples"},{"location":"developers/knora/documentation/rdf/#classes","text":"Resources can be grouped in classes which are themselves resources. The members of such a class are known as instances of the class. Classes are often identified by URIs/IRIs. All RDF datatypes are classes. The instances of a class that is a datatype are the members of the value space of the datatype. Thus, \"3.14\" is an instance of the class decimal, \"4\" is an instance of the class integer, \"2000-01-01\" is an instance of the class date, etc. The basic construct for specifying a group of related resources in RDFS is called an rdfs:Class . The way to express that something is a class is with a triple in which the predicate is rdf:type and the object is rdfs:Class as in the following examples: myonto:Ceramics rdf:type rdfs:Class . myonto:BlackFigured rdf:type rdfs:Class . These triples express that our resources Ceramics and BlackFigured are classes. One of the basic terms is rdfs:subClassOf . The meaning of \" B is a subClassOf C \" is \"every member of class B is also a member of class C\", expressed in the form of an inference. From a further information \" x is a member of B \" one can derive the new information \" x is a member of C \". Speaking more generally, if a class A is a subclass of another class B, then anything of type A is also of type B. This is called the type propagation rule . This feature of inference systems is particulary useful in a Semantic Web context in which new combinations of relationships likely occur as data from multiple sources are merged. In the framework of our example the class BlackFigured is a subclass of the class Ceramics . For any member of the class BlackFigured we can then derive that it is also a member of the class Ceramics due to the following statement : myonto:BlackFigured rdfs:subClassOf myonto:Ceramics . A class may be a member of its own class extension and an instance of itself, this applies e.g. for rdfs:Class .","title":"Classes"},{"location":"developers/knora/documentation/rdf/#properties","text":"An RDF property describes the relationship between a subject resource and an object resource.","title":"Properties"},{"location":"developers/knora/documentation/rdf/#properties-with-inferences","text":"One of the most fundemantal terms in RDFS is rdfs:subPropertyOf . It is a transitive property and allows a modeler to describe a hierarchy of related properties. If we want to express that some of the people who work for a museum are permanently employed while others possess only loose contracts we could express this fact with the following triples: myonto:isEmployedBy rdfs:subPropertyOf myonto:worksFor . myonto:contractsTo rdfs:subPropertyOf myonto:worksFor . Regardless whether a person is employed by the museum or is a contractor, the person works for the museum. Other basic properties are rdfs:range and rdfs:domain . They have meanings inspired by the mathematical use of the words range and domain : the domain of a function is the set of values for which it is defined, its range is the set of values it can take. Both give informaton about how a property P is to be used: domain refers to the subject of any triple that uses P as its predicate, range refers to the object of any such triple.","title":"Properties with inferences"},{"location":"developers/knora/documentation/rdf/#rdfsdomain","text":"P rdfs:domain D . means that property P has domain D . From this we can infer that the subject of that triple is a member of the class D . rdfs:domain can be used to specify with which class the defined property can be used with. It is possible to specify multiple rdfs:domain properties when defining a property. We pick just two classes from our example - Ceramics and BlackFigured - which show a subclass relation: myonto:BlackFigured rdfs:subClassOf myonto:Ceramics . We now have a property called incised whose domain is BlackFigured . myonto:incised rdfs:domain myonto:BlackFigured . This means that all my objects with incised decoration belong to the class BlackFigured .","title":"rdfs:domain"},{"location":"developers/knora/documentation/rdf/#rdfsrange","text":"P rdfs:range R . means that the property P has range R . From this we can infer that the object (the value of P ) of that triple is a member of class R . If the predicate of a triple has more than one rdfs:range property, the resources denoted by the objects of triples are instances of all the classes stated by the rdfs:range properties. If we want to specify that queens who gave birth to a son could theoretically become queen mothers, we could do that with the following combination of rdfs:domain and rdfs:range : myonto:hasSon rdfs:domain myonto:Queen . myonto:hasSon rdfs:range myonto:QueenMother . It is important to know that if P is used in an inconsistent way with this declaration, RDFS does not signal an error, but rather infers the necessary type information to bring P into accordance with its domain and range declarations! In RDFS, there is no notion of an incorrect or inconsistent inference, i.e. it will never proclaim an input as invalid but simply infer appropriate type information. Domains and ranges are not used to validate information, but to determine new information based on old information. In practice, there are often better and more appropriate options to use instead of rdfs:domain and rdfs:range alone.","title":"rdfs:range"},{"location":"developers/knora/documentation/rdf/#properties-without-inferences","text":"RDFS provides some properties from which no inferences can be drawn, i.e. no inference semantics is defined for them. They are useful and important for documentation purposes. These are rdfs:label , rdfs:comment , rdfs:seeAlso and rdfs:isDefinedBy . Resources on the Semantic Web are specified by IRIs/URIs which are not meaningful to people. Thus, RDFS provides the property rdfs:label whose intended use is to provide a human-readable version for any resource's name. Multilingual labels are possible if the language tagging facility of RDF literals is used. myonto:BlackFigured rdfs:label \"black-figured vessels\"@en, \"schwarzfigurige Gef\u00e4sse\"@de . Frequently it is useful to add comments about a model, i.e. to document it properly. In RDFS, rdfs:comment is an instance of rdf:Property that can be used to provide a human-readable description of a resource. Multilingual documentation is possible if the language tagging facility of RDF literals is used. To make a comment a triple using the property rdfs:comment as a predicate has to be asserted. myonto:BlackFigured rdfs:comment \"The class BlackFigured contains ceramic vessels where the decoration is painted with black paint.\" . In the case where a resource is an URL, supplementary information about this resource may be useful. This additional information is often included in documents. rdfs:seeAlso provides a way to specify the web location of such supplementary information. The web location has to be given in the form of an IRI/URI! The precise behaviour of a processor is not specified, but most tools that encounter rdfs:seeAlso link them to those links in a browser or application interface. In our example we could link findspots of archaeological objects to a web resource with geodata, e.g. GeoNames, in the following way: myonto:latitude rdfs:seeAlso geonames:lat . rdfs:isDefinedby provides a link to the primary resource of information about a resource. Thus, the definitional description of a resource can be found, e.g. rdfs:isDefinedBy is defined in RDF to be a rdfs:subPropertyOf of rdfs:seeAlso .","title":"Properties without inferences"},{"location":"developers/knora/documentation/rdf/#combinations-and-patterns","text":"","title":"Combinations and patterns"},{"location":"developers/knora/documentation/rdf/#intersection","text":"RDFS inference rules are few and rather simple. More specific patterns can be obtained by combining basic RDFS features. One such case is set intersection. If we intend to draw the inference that if a resource x is an instance of class C , then it should also be an instance of classes A and B , expressing the formal relationship C \u2286 A \u2229 B . Such an inference can be obtained by making C a subclass of A and B : :C rdfs:subClassOf :A . :C rdfs:subClassOf :B . Due to the inference rule defined for rdfs:subClassOf we can infer from the triple x rdf:type :C . the desired triples x rdf:type :A . x rdf:type :B . Thus, from a membership in C membership in A and B can be inferred. But from membership in A and B membership in C cannot be inferred! Inferences can only be drawn in one direction. In an analogous way to the treatment of classes, set intersection can be defined for properties using the construct rdfs:subPropertyOf .","title":"Intersection"},{"location":"developers/knora/documentation/rdf/#union","text":"The union of two sets ( A \u222a B \u2286 C ) can be obtained by making C a superclass of A and B . :A rdfs:subClassOf :C . :B rdfs:subClassOf :C . Then, for any instance x that is either a member of class A or of B it will be inferred that it is also a member of class C . In an analogous way to the treatment of classes, set union can be defined for properties using rdfs:subPropertyOf .","title":"Union"},{"location":"developers/knora/documentation/rdf/#collections","text":"A collection is represented as a list of items. rdf:List is an instance of rdfs:Class that can be used to build descriptions of lists and other list-like structures.","title":"Collections"},{"location":"developers/knora/documentation/rdf/#summary","text":"The following Figure 4 illustrates the concepts of resource, class, and sub-class based on our example project. Figure 5 shows the same in a more general way: resources are denoted by a large black dot and arrows are drawn from a resource to the class it defines. A sub-class is shown by a rectangle (the sub-class) completely enclosed by another (the super-class), i.e. class ConstraintProperty is a subclass of class Property. The notion rdf:type specifies that something is a member of a group, i.e. an instance of a class. By using rdfs:Class instead of rdf:type a description of the meaning of a membership in a group is gained. Meaning is expressed through the mechanisms of inference in RDFS that can be drawn when a resource is used in a certain way. The following Figure 6 expresses the same information about the class hierarchy, but does so using a graphic representation of the RDF data model. If a class is a subset of another, there is an arc labelled \"s\" from the node representing the first class to the node representing the second one (\"s\" stands for rdfs:subClassOf ). If a resource was an instance of a class, then there is an arc labelled \"t\" from the resource to the node representing the class (\"t\" stands for rdf:type ). Not all arcs are drawn, e.g. rdfs:ConstraintProperty is a subclass of rdfs:Resource because it is a subclass of rdf:Property which is a subclass of rdfs:Resource . Examples: - The class rdfs:Literal is an instance of rdfs:Class and an instance of rdfs:Resource . - The class rdf:Property is the class of RDF properties and an instance of rdfs:Class .","title":"Summary"},{"location":"developers/knora/documentation/rdf/#web-ontology-language-owl","text":"OWL is intended to be used when information contained in documents needs to be processed by applications, it explicitly represents the meaning of terms in vocabularies and the relationship between those terms. The representation of terms and their interrelationships are called an ontology . A concrete syntax is needed in order to store ontologies and to exchange them among tools and applications. The primary exchange syntax for OWL is the XML syntax for RDF (RDF/XML), but other syntaxes such as e.g. Turtle are also frequently used. The data described by an OWL ontology is interpreted as a set of \"individuals\" and a set of \"property assertions\" which relate these individuals to each other. An ontology consists of a set of axioms which place constraints on sets of individuals called \"classes\" and the types of relationships permitted between them. OWL ontologies can import other ontologies, adding information from the imported ontology to the current ontology. The main building blocks of the OWL language are an RDF graph and at least one concrete syntax - there may be more than one - that can be used to serialize and exchange ontologies. OWL has been designed to meet the needs for a Web Ontology Language. It is part of the W3C recommendations related to the Semantic Web: - XML provides a surface syntax for structured documents, but imposes no semantic constraints. - XML Schema is a language for restricting the structure of XML documents and extends XML with datatypes. - RDF is a datamodel for objects and relations between them. Furthermore, it provides a simple semantics for this datamodel and these datamodels can be represented in an XML syntax. - RDF Schema is a vocabulary for describing properties and classes of RDF resources, with a semantics for generalization-hierarchies of such properties and classes. - OWL then adds more vocabulary to RDF for describing properties and classes: e.g. relations between classes, cardinality, equality, characteristics of properties and enumerated classes. The following introduction to OWL draws heavily on the book of Dean Allemang & James Hendler, Semantic Web for the Working Ontologist. Effective Modeling in RDFS and OWL, Second Edition, 2011, 153\u2013305 which we warmly recommend for reading. Further information can be found in the Recommendations of the OWL 2 Web Ontology Language Document Overview (Second Edition) and the Wikipedia entry of OWL .","title":"Web Ontology Language (OWL)"},{"location":"developers/knora/documentation/rdf/#owlclass","text":"In OWL, a Class defines a group of individuals that belong together because they share some properties. An owl:Class differs from an rdfs:Class - an owl:Class is a special case of an rdfs:Class . Classes can be organised in a hierarchy using rdfs:subClassOf . Thus, owl:Class is defined as a subclass of rdfs:Class : owl:Class rdfs:subClassOf rdfs:Class . This means that every member of an owl:Class is also a member of rdfs:Class . There is a built-in most general class named owl:Thing which is the class of all individuals. It is a superclass of all OWL classes. There is also a built-in class named owl:Nothing which is the class that has no instances. It is a subclass of all OWL classes.","title":"owl:Class"},{"location":"developers/knora/documentation/rdf/#owlinverseof","text":"Extra language features that are not directly provided by OWL, but that one may desire, such as e.g. superClassOf , are often supported by OWL as a combination of other features. The construct owl:inverseOf inverses a property, i.e. the direction of the property is reversed. This property can be used to define e.g. the superClassOf of a resource by combining it with rdfs:subClassOf in the following way: myonto:superClassOf owl:inverseOf rdfs:subClassOf .","title":"owl:inverseOf"},{"location":"developers/knora/documentation/rdf/#owlsymmetricproperty","text":"For a symmetric property holds that if a pair (x,y) is an instance of the property P, then also the pair (y,x) is an instance of this property P. Such a property is provided by owl:SymmetricProperty and expressed in OWL as a Class. An example for such a property is to be married - if Agamemnon is married to Klytaimnestra, Klytaimnestra is also married to Agamemnon. Thus we can define a property married in our ontology with the following triples: myonto:married rdf:type owl:SymmetricProperty . Agamemnon myonto:married Klytaimnestra . Be aware - to make sure that owl:inverseOf works in both directions, one has to assert that owl:inverseOf rdf:type owl:SymmetricProperty .","title":"owl:SymmetricProperty"},{"location":"developers/knora/documentation/rdf/#owltransitiveproperty","text":"Another important property is transitivity. Transitivity is a relation between three elements such that if it holds between the first and second and it also holds between the second and third, it must necessarily hold between the first and the third. In OWL, transitivity is provided by the construct owl:TransitiveProperty which is a class of properties. To model the property isLocatedIn in our ontology as a member of the transitive class we can state myonto:isLocatedIn rdf:type owl:TransitiveProperty . Together with the triples Rome myonto:isLocatedIn Italy . Italy myonto:isLocatedIn Europe . we can infer that Rome is located in Europe.","title":"owl:TransitiveProperty"},{"location":"developers/knora/documentation/rdf/#owlequivalentclass","text":"A frequent situation is that if information about the same entity from different sources is merged then the two providers of this information will not have used the same URI/IRI for refering to the same entity. When combining these data it may be useful to state that two URIs/IRIs actually refer to the same entity. When two classes are known to always have the same members, they are said to be equivalent . Such a situation can be expressed with one simple statement using owl:equivalentClass : owl:equivalentClass rdf:type owl:SymmetricProperty . myonto:GreekGods owl:equivalentClass otheronto:Deities . The second triple expresses that the class GreekGods in our ontology is equivalent to the class Deities in some other ontology we refer to. Note that when two classes are equivalent, it only means that they have the same members. But other properties of these classes aren't shared!","title":"owl:equivalentClass"},{"location":"developers/knora/documentation/rdf/#owlequivalentproperty","text":"If one intends to state that two properties are equivalent, owl:equivalentProperty can be used: myonto:isInvisible owl:equivalentClass otheronto:notSeen . This statement expresses that the property which is called isInvisible in our ontology, is named notSeen in some other ontology.","title":"owl:equivalentProperty"},{"location":"developers/knora/documentation/rdf/#owlsameas","text":"If it turns out that two individuals are actually one and the same, owl:sameAs can be used to state this fact: myonto:Puteoli owl:sameAs otheronto:Puzzeoli . This statement expresses that the site which is called Puteoli in our ontology, is the same as a site named Puzzeoli in some other ontology.","title":"owl:sameAs"},{"location":"developers/knora/documentation/rdf/#owlfunctionalproperty","text":"A functional property owl:FunctionalProperty is a property which can only have one single value. An everyday example for such a property is e.g. hasBirthplace since each person has only one birth place. Functional properties can be useful to infer sameness, e.g. if names with foreign characters are transliterated differently in two sources - a Greek \"B\" may be transliterated either as \"B\" or as \"V\", we can state: myonto:GreekB owl:FunctionalProperty otheronto:GreekV .","title":"owl:FunctionalProperty"},{"location":"developers/knora/documentation/rdf/#owlinversefunctionalproperty","text":"However, it is more common to use the related notion of owl:InverseFunctionalProperty . One can think of this construct to be the inverse of owl:FunctionalProperty as its name suggests. Especially identifying numbers are inverse functional properties. myonto:hasInventoryNumber rdf:type owl:InverseFunctionalProperty . myonto:ID3 myonto:hasInventoryNumber \"24.97.11\" . otheronto:ID2435 myonto:hasInventoryNumber \"24.97.11\" . From the above example follows that ID 3 in my data set is the same object as ID 2435 in another data set. It is sometimes useful for a single property to be an owl:FunctionalProperty and an owl:InverseFunctionalProperty . This means that it is a one-to-one property: for each individual there is exactly one value for the property and the other way round. This feature is intended in the case of unique identifiers as in the following example: myonto:hasID rdfs:domain myonto:Monument . myonto:hasID rdfs:range xsd:Integer . myonto:hasID rfd:type owl:FunctionalProperty . myonto:hasID rfd:type owl:InverseFunctionalProperty . This means that each member of class Monument possesses a unique identifier that is an integer number. Any two monuments that share an ID must be the same (due to inverse functionality) and in addition, each monument can have at most one ID (due to functionality).","title":"owl:InverseFunctionalProperty"},{"location":"developers/knora/documentation/rdf/#owlobjectproperty-and-owldatatypeproperty","text":"The constructs owl:sameAs , owl:FunctionalProperty and owl:InverseFunctionalProperty especially help to describe how information from multiple sources can be merged. OWL can also provide useful information for editing tools if a value of some property may be either a link to another object or a widget for a particular data type. For this purpose OWL distinguishes between owl:DatatypeProperty and owl:ObjectProperty . owl:DatatypeProperty can have a data value as object, owl:ObjectProperty can have a resource as object. myonto:inSameMuseum rdf:type owl:ObjectProperty. myonto:shipVoyage rdf:type owl:DatatypeProperty. The first example may be used to express that one archaeological object is kept in the same museum as another archaeological object while the second example may select those individuals who participated in a ship voyage such as e.g. the Argonauts.","title":"owl:ObjectProperty and owl:DatatypeProperty"},{"location":"developers/knora/documentation/rdf/#restrictions","text":"The construct owl:Restriction allows to describe individuals of classes in terms of existing properties and classes that have already been modeled. The class of all things in OWL called owl:Thing is unrestricted. A restriction provides some description that limits the kinds of things that can be said about a member of the class. A restriction class in OWL is defined by the keyword owl:onProperty . A description of how the new class is constrained can be provided e.g. by owl:allValuesFrom , owl:someValuesFrom and owl:hasValue . The membership in a restriction class must satisfy the specified conditions as well as the owl:onProperty specification.","title":"Restrictions"},{"location":"developers/knora/documentation/rdf/#property-constraints","text":"owl:someValuesFrom selects all individuals from a class for which at least one value of the property P comes from class C . In our example we can formulate such a restriction as: [a owl:Restriction; owl:onProperty myonto:isLocatedIn; owl:someValuesFrom myonto:Museum] All archaeological objects kept in a museum today thus have been defined as all archaeological objects for which at least one value of the property isLocatedIn comes from the class Museum . The [ ] notation refers to a blank node which is described by the properties listed here. This restriction class has no specific name associated with it - it is defined by the properties of the restriction and is hence called an unnamed class . owl:allValuesFrom selects all individuals from a class for which all values of the property P come from class C . In our example we can formulate such a restriction as: [a owl:Restriction; owl:onProperty myonto:hasProvenience; owl:allValuesFrom myonto:Findspot] This restriction selects all our archaeological objects for which the findspot is known. A noteworthy difference between owl:someValuesFrom and owl:allValuesFrom is that the former implies that there must be such a member, while the latter technically means if there are any members, then they all must have this property which doesn't imply that there are any members. owl:hasValue is used to produce a restriction of the form \"all individuals that have the value A for the property P \". We can formulate such a restriction as: [ a owl:Restriction ; owl:onProperty myonto:P ; owl:hasValue myonto:A ] . Let's assume we defined a property myonto:hasImage which helps to select archaeological objects for which we possess images. We can now state a restriction for those with high resolution images: myonto:HighResolutionObject owl:equivalentClass [ a owl:Restriction ; owl:onProperty myonto:hasImage; owl:hasValue myonto:hasHighresImage ] . That we have such a high resolution image of a certain object we can formulate with the following triple: myonto:ID3 myonto:hasImage myonto:hasHighresImage . Then it is possible to deduce myonto:ID3 a myonto:HighResolutionObject . owl:hasValue is just a special case of the owl:someValuesFrom restriction. Nevertheless, it is very useful because it effectively turns specific instance descriptions into class descriptions. OWL provides a facility for defining new classes as unions ( owl:unionOf ) and intersections ( owl:intersectionOf ) of previously defined classes. The union of two or more classes includes the members of all those classes while the intersection includes only those that belong to every one of the classes. OWL allows to enumerate the members of a class using the construct owl:oneOf . If I have a class myonto:ObjectsSomeSmallMuseum with the members \"vase1\", \"vase2\" and \"relief1\", then: myonto:ObjectsSomeSmallMuseum rdf:type owl:Class; owl:oneOf (myonto:vase1 myonto:vase2 myonto:relief1). My class myonto:ObjectsSomeSmallMuseum is related via the property owl:oneOf to a list of the members of the class. However, owl:oneOf should be used only in situations in which the definition of the class is not likely to change at all or at least not frequently. One such case would e.g. be the number of planets in the solar system. In contrast, the above example may be appropriate for our own immediate needs, but not for a more general approach: although we include only three objects of this small museum in our data, the museum itself for sure owns many more. Sometimes it may be useful to state that one thing is different from another thing. OWL provides owl:differentFrom for this. An example is the following: myonto:Zenon owl:differentFrom otheronto:Zenon. Two different ancient Greek philosophers with the name Zenon are known. The above triple states that the Zenon in our ontology (e.g. Zenon of Elea) is not the same Zenon as in another ontology (e.g. Zenon of Kition).","title":"Property constraints"},{"location":"developers/knora/documentation/rdf/#cardinalities","text":"OWL also includes restrictions that refer to cardinalities , i.e. the number of values for a specific property. Cardinality restrictions can be used to define sets of particular interest. Cardinality refers to the number of distinct values a property has. The fact that we only know about two works attributed to Homer - the Iliad and the Odyssey - we may state by using owl:cardinality : [a owl:Restriction; owl:onProperty myonto:HomerWorks; owl:cardinality 2] Cardinality restrictions can also be used to specify upper and lower boundaries, the respective constructs are named owl:maxCardinality and owl:minCardinality . The restriction to cardinalities of 0 and 1 have special modeling utility: minCardinality 0 indicates a set of individuals for which some value for a specified property is optional minCardinality 1 indicates a set of individuals for which some value for a specified property is required maxCardinality 0 specifies that no value for the specified property is allowed maxCardinality 1 specifies that a value is unique (but need not exist)","title":"Cardinalities"},{"location":"developers/knora/documentation/rdf/#reasoning-with-individuals-and-classes","text":"From an RDF perspective inferences about individuals and inferences about classes are very similar: in both cases new triples are added to the model based on the asserted triples. However, from a modeling perspective, these two kinds of reasoning are very different. The former draws specific conclusions about individuals while the latter draws general conclusions about classes of individuals. In the case of reasoning about individuals the information specified in one source is transformed according to a model for use in another context with the help of constructs such as rdfs:subClassOf , rdfs:subPropertyOf and various owl:Restriction . Class reasoning determines how data are related in general with constructs such as rdfs:subClassOf , rdfs:subPropertyOf , rdfs:domain or rdfs:range . Once these more general relationships have been inferred, the processing of the data can be done much easier.","title":"Reasoning with individuals and classes"},{"location":"developers/knora/documentation/rdf/#composing-files","text":"OWL provides a built-in class owl:Ontology . The URI/IRI of an ontology usually corresponds to the URL of the file on the Web where the ontology is stored. The corresponding URI/IRI can be eclosed in angle brackets as follows: <http://www.knora.org/ontology/knora-base> rdf:type owl:Ontology. This can be useful when modularity of semantic models is specified. The most frequent way to specify modularity is with the property owl:imports . This property connects two instances of the class owl:Ontology .","title":"Composing files"},{"location":"developers/knora/documentation/rdf/#summary-of-constructs","text":"rdfs:subClassOf - the members of a subclass are also a member of a superclass rdfs:subPropertyOf - relations described by a subproperty also hold for the superproperty rdfs:domain - the subject of a triple is classified into the domain of the predicate rdfs:range - the object of a triple is classified into the range of the predicate rdfs:label - human-readable name of a resource, no semantics inferable rdfs:comment - human-readable information of the model, no semantics inferable owl:equivalentClass - the members of each class are also members of the other class owl:equivalentProperty - relations that hold for each property also hold for the other property owl:sameAs - all statements about one instance hold for the other instance owl:inverseOf - exchanges subject and object owl:TransitiveProperty - the chains of a relationship collapse into a single relationship owl:SymmetricProperty - the property is its own inverse owl:FunctionalProperty - only one value as object allowed owl:InverseFunctionalProperty - only one value as subject allowed owl:ObjectProperty - the property can have a resource as object owl:DatatypeProperty - the property can have a data value as object owl:Restriction - a building block in OWL that describes classes by restricting the values that are allowed for certain properties owl:hasValue - a type of restriction that refers to a single value for a property owl:someValuesFrom - a type of restriction that refers to a set from which some value for a property must come owl:allValuesFrom - a type of restriction that refers to a set from which all values for a property must come owl:onProperty - a link from a restriction to the property it restricts. owl:unionOf - unites classes and creates a new class owl:intersectionOf - determines the intersection of classes and creates a new class owl:complementOf - determines the compliment of a class and creates a new class owl:oneOf - specifies that a class consists just of the listed members owl:differentFrom - specifies that one individual is not identical to another one owl:disjointWith - specifies that two classes cannot share a member owl:cardinality - specifies information about the number of distict values for some property owl:minCardinality - specifies information about the minimum number of distinct values for a property owl:maxCardinality - specifies information about the maximum number of distinct values for a property owl:imports - allows one ontology to refer explicitly to another ontology.","title":"Summary of constructs"},{"location":"developers/knora-api-js-lib/contribution/","text":"","title":"Knora API JS lib"},{"location":"developers/knora-api-js-lib/documentation/","text":"","title":"Knora API JS lib"},{"location":"developers/knora-web-app/contribution/","text":"Style guide Angular Material has been chosen to style the GUI elements and the typography of Knora-App. Typography classes","title":"Knora web app"},{"location":"developers/knora-web-app/contribution/#style-guide","text":"Angular Material has been chosen to style the GUI elements and the typography of Knora-App.","title":"Style guide"},{"location":"developers/knora-web-app/contribution/#typography-classes","text":"","title":"Typography classes"},{"location":"developers/knora-web-app/documentation/","text":"","title":"Knora web app"},{"location":"developers/sipi/contribution/","text":"","title":"Sipi"},{"location":"developers/sipi/documentation/","text":"SIPI basics The media server SIPI The S imple I mage P resentation I nterface (Sipi) takes care of storing, converting and serving image, audio and video files as well as other documents such as pdf files. It is designed to be used by all institutions that need to preserve high-quality images and to make them available online. SIPI implements the I nternational I mage I nteroperability F ramework ( IIIF ), which aims at supporting interoperability between different image repositories. SIPI efficiently converts lossless between image formats while preserving the metadata contained in the image files. If images are stored in JPEG 2000 format, SIPI can convert them on the fly to formats that are commonly used on the Internet. SIPI is written in C++ and runs on Linux and Mac OS X. It offers a flexible framework for specifying authentication and authorization logic which is obtained by scripts written in the scripting language Lua . SIPI supports restricted access to images, either by reducing the image dimensions or by adding watermarks to the images. Interaction of Knora and SIPI If a file is requested from SIPI by e.g. an image link served by Knora , a preflight function is called. This function needs three parameters: a prefix, the identifier (the name of the requested file) and a cookie. All file links created by Knora use the project number as prefix. An example link from our incunabula project may look as follows: 0.0.0.0:1024/0803/incunabula_0000003328.jp2/full/2613,3505/0/default.jpg . Based on the provided information, SIPI asks Knora about the permissions on the file in question of the current user. Therefore, the cookie is needed: it contains the current user's Knora session ID. Hence, Knora can match SIPI's request with a given user profile and tell SIPI the permissions this user has on the requested file. If the user has sufficient permissions, the file is served in full quality. If the user has only preview rights, SIPI serves a reduced quality of the file or integrates a watermark. If the user has no permissions, SIPI refuses to serve the file. However, all of this behaviour is defined in the preflight function in SIPI and not controlled by Knora. Knora only provides the permission code. Thus, Knora and SIPI stick to a clear division of responsibility regarding files: Knora knows about the names of files that are attached to resources as well as some metadata and is capable of creating the URLs for the client to request them from SIPI, but the whole handling of files (storing, naming, organization of the internal directory structure, format conversions, and serving) is taken care of by SIPI. When a user creates a resource with a digital representation attached to it in Knora either via the G raphical U ser I nterface (GUI) or directly via the A pplication P rogramming I nterface (API), the file is directly sent to SIPI to calculate a thumbnail hosted by SIPI which then gets displayed to the user in the browser. SIPI copies the original file into a temporary directory and keeps it there for later processing in another request. In its answer in JSON format, SIPI returns the path to the thumbnail, the name of the temporarily stored original file managed by SIPI, the mime type of the original file and the original name of the file submitted by the client. At the moment when the user wants to attach the file to a resource, the request is sent to Knora\u2019s API providing all the required parameters to create the resource along with additional information about the file to be attached. The file itself is not submitted to the Knora API, but its filename returned by SIPI.","title":"Sipi"},{"location":"developers/sipi/documentation/#sipi-basics","text":"","title":"SIPI basics"},{"location":"developers/sipi/documentation/#the-media-server-sipi","text":"The S imple I mage P resentation I nterface (Sipi) takes care of storing, converting and serving image, audio and video files as well as other documents such as pdf files. It is designed to be used by all institutions that need to preserve high-quality images and to make them available online. SIPI implements the I nternational I mage I nteroperability F ramework ( IIIF ), which aims at supporting interoperability between different image repositories. SIPI efficiently converts lossless between image formats while preserving the metadata contained in the image files. If images are stored in JPEG 2000 format, SIPI can convert them on the fly to formats that are commonly used on the Internet. SIPI is written in C++ and runs on Linux and Mac OS X. It offers a flexible framework for specifying authentication and authorization logic which is obtained by scripts written in the scripting language Lua . SIPI supports restricted access to images, either by reducing the image dimensions or by adding watermarks to the images.","title":"The media server SIPI"},{"location":"developers/sipi/documentation/#interaction-of-knora-and-sipi","text":"If a file is requested from SIPI by e.g. an image link served by Knora , a preflight function is called. This function needs three parameters: a prefix, the identifier (the name of the requested file) and a cookie. All file links created by Knora use the project number as prefix. An example link from our incunabula project may look as follows: 0.0.0.0:1024/0803/incunabula_0000003328.jp2/full/2613,3505/0/default.jpg . Based on the provided information, SIPI asks Knora about the permissions on the file in question of the current user. Therefore, the cookie is needed: it contains the current user's Knora session ID. Hence, Knora can match SIPI's request with a given user profile and tell SIPI the permissions this user has on the requested file. If the user has sufficient permissions, the file is served in full quality. If the user has only preview rights, SIPI serves a reduced quality of the file or integrates a watermark. If the user has no permissions, SIPI refuses to serve the file. However, all of this behaviour is defined in the preflight function in SIPI and not controlled by Knora. Knora only provides the permission code. Thus, Knora and SIPI stick to a clear division of responsibility regarding files: Knora knows about the names of files that are attached to resources as well as some metadata and is capable of creating the URLs for the client to request them from SIPI, but the whole handling of files (storing, naming, organization of the internal directory structure, format conversions, and serving) is taken care of by SIPI. When a user creates a resource with a digital representation attached to it in Knora either via the G raphical U ser I nterface (GUI) or directly via the A pplication P rogramming I nterface (API), the file is directly sent to SIPI to calculate a thumbnail hosted by SIPI which then gets displayed to the user in the browser. SIPI copies the original file into a temporary directory and keeps it there for later processing in another request. In its answer in JSON format, SIPI returns the path to the thumbnail, the name of the temporarily stored original file managed by SIPI, the mime type of the original file and the original name of the file submitted by the client. At the moment when the user wants to attach the file to a resource, the request is sent to Knora\u2019s API providing all the required parameters to create the resource along with additional information about the file to be attached. The file itself is not submitted to the Knora API, but its filename returned by SIPI.","title":"Interaction of Knora and SIPI"},{"location":"user-guide/","text":"User Guide This is the documentation for the generic Knora Web Application of the Data and Service Center for the Humanities DaSCH. You can reach the app on app2.dasch.swiss . Getting started Knora App is an intuitive, easy to use web-based application placed on top of Knora to directly use its powerful data management functionalities. With this modern web application, the researchers can create their data models, search, browse, and work with their qualitative data as easily as they could with a desktop data management tool. In addition, data models and data will automatically follow accepted standards, be interoperable, findable, and re-usable. Researchers and scholars with small to medium data sets (e.g. PhD research, pilot project, or proof of concept) have access to long-term accessibility to keep their research data alive, guaranteeing longevity of the data. Login To login, click on the LOGIN button of the header (right side), a login form will appear. Fill in the form with your credentials (user name or email and password). In case of a forgotten password, please contact the DaSCH Team . Registration You can use the Knora App with restricted access as guest. Otherwise, you'll need a login. At the moment, you have to contact the DaSCH Team to get your login credentials. In the future (end of 2020), we will support the SWITCH edu-ID . Help For any questions or help wanted, you can go to the help page, accessible from the Help button at the top right of the page (see login screen shot ). Here, you can find links to the user guide, get more information about the DaSCH softwares, and get more support through different platform according to your requests.","title":"Introduction"},{"location":"user-guide/#user-guide","text":"This is the documentation for the generic Knora Web Application of the Data and Service Center for the Humanities DaSCH. You can reach the app on app2.dasch.swiss .","title":"User Guide"},{"location":"user-guide/#getting-started","text":"Knora App is an intuitive, easy to use web-based application placed on top of Knora to directly use its powerful data management functionalities. With this modern web application, the researchers can create their data models, search, browse, and work with their qualitative data as easily as they could with a desktop data management tool. In addition, data models and data will automatically follow accepted standards, be interoperable, findable, and re-usable. Researchers and scholars with small to medium data sets (e.g. PhD research, pilot project, or proof of concept) have access to long-term accessibility to keep their research data alive, guaranteeing longevity of the data.","title":"Getting started"},{"location":"user-guide/#login","text":"To login, click on the LOGIN button of the header (right side), a login form will appear. Fill in the form with your credentials (user name or email and password). In case of a forgotten password, please contact the DaSCH Team .","title":"Login"},{"location":"user-guide/#registration","text":"You can use the Knora App with restricted access as guest. Otherwise, you'll need a login. At the moment, you have to contact the DaSCH Team to get your login credentials. In the future (end of 2020), we will support the SWITCH edu-ID .","title":"Registration"},{"location":"user-guide/#help","text":"For any questions or help wanted, you can go to the help page, accessible from the Help button at the top right of the page (see login screen shot ). Here, you can find links to the user guide, get more information about the DaSCH softwares, and get more support through different platform according to your requests.","title":"Help"},{"location":"user-guide/data/","text":"Data management Once your data model is ready, you're able to add data. The Knora App offers several possibilities to add data, whether you are starting from scratch or importing data from another program. Start from scratch \u26a0 NOT YET IMPLEMENTED (only mockups are presented) When a project starts from scratch, you will enter and generate new data directly in the Knora App itself. Generating new data can be done one by one with a form or with a table-based (Excel like) tool. Upload the files, e.g., the actual audio file of an interview or images of the photographs discussed in the interview Augment the metadata In case of interview transcriptions from audio or video files, Knora App will offer a simple transcription tool Create new source; e.g. upload audio file of an interview. Organize data and create additional sources \u26a0 NOT YET IMPLEMENTED The workspace of the Knora App includes tools to connect different sources, even if they're not in the same project (linkage), to comment on a source and on their metadata fields (annotate), and to transcribe audio-visual material. These actions will generate more data and will help to find specific sources and their relations easily. It's possible to collect different sources and to store them in an individual collection. You can define more than one collection. You can share collections and invite other users to collaborate. Search and browse Knora App offers the possibility to the user to search in 3 different ways: full text search, advanced search and expert search (Gravsearch query). The search bar is always available in the header of each page, whether logged in or out. Full text search Full text search performs queries including one or more terms or phrases, and returns data that matches search conditions. By default, the search is performed in all projects stored in Knora. However, it is possible to filter by project using the menu \"Filter by project\" on the left side of the search bar. https://app2.dasch.swiss - Search 1: Full text search When clicking on the search bar, the search history panel is displayed. The 10 last searches are registered. It is also possible to clear the search history list ( Clear list button at the bottom of the panel). Search history list is accessible for the full text search from any webpage. Special syntax: asterisk* can be used as a wildcard symbol \"quotation marks\" searches for the whole pattern Advanced search The advanced search allows you to filter by project, by source type, or by the metadata of source types. Each filter can be standalone or combined. The metadata field can be precisely filtered with criteria such as \"contains\", \"is like\", \"equals to\", \"exists\" or in case of a date value with \"before\" or \"after\". In addition, for a metadata field that is connected to another source type, it's possible to filter by this second source type. https://app2.dasch.swiss/search/advanced - Search 2: Advanced search offers many filter combinations and is a powerful search tool. Currently, it is possible to search for only one source. Expert search The expert search can be more powerful than the advanced search, but requires knowing how to use the query language Gravsearch (based on SparQL and developed by the DaSCH team). With Gravsearch, expert users can build searches by combining text-related criteria with any other criteria. For example : you could search for a page in a manuscript that contains a certain element and also mentions a person, who lived in the same country as another person, who is the author of another author. https://app2.dasch.swiss/search/expert - Search 3: Expert search is a text area in which you can create Gravsearch queries. Here is the default example you can find in the app. To learn Gravsearch, go to the Knora documentation \u2192 Gravsearch Search results Simple list The results of the search are displayed in an organised list with a small preview. You can select one result at a time to get more information. Search result 1: Simple list of results, similar to Google's list of results. \u26a0 NOT YET IMPLEMENTED It is not possible yet to sort or order by criteria when searching with the full text search, use the advanced search or the expert search instead to get back sorted results. Grid list: Lighttable The results of the search are displayed in a grid list with a big preview. You can select one result at a time to get more information. Search result 2: A preview list where the results are presented in tiles. Table: Excel-like view \u26a0 NOT YET IMPLEMENTED The search results are displayed in a table with the option to sort them. This layout is enabled when the search has been performed with only one source type . Each column of the table corresponds to one metadata. Search result 3: An Excel-like table view to edit multiple sources at once. Do research and work on your data Once you have found the desired sources, you can (re)view them and annotate the source itself, the media file, or single metadata values. If you select more than one source, you can compare them in a side-by-side view, link them, edit them all at once, or save them in a collection. A collection is similar to a playlist in a music app or shopping basket in an online store. Display a source \u26a0 WORK IN PROGRESS The Knora App offers different source views for different media types. There's a viewer for still images, moving images, audio and document files. You can open them from the list of search results. Depending on the media type, Knora App offers different tools to work on the source. In a still image source, you're able to draw regions on the image and to annotate or transcribe this region. Usually, a still image source is used for book pages, photographs, postcards, letters etc. In time-based sources like moving image or audio document, you can mark sequences on the timeline. A transcription tool helps to annotate and to transcribe the sequence. Single source view. The source type in this example is \"Page\". Knora App will offer a graph view to visualize the connection of a selected source. The graph view is a powerful tool because you will find more information about the source by clicking through the nodes. Graph view of a single source. Additionally, you can work on the source directly, e.g, transcribe a moving image or a taped interview or mark regions of interest on still images and on documents. Single source fullframe view with the transcription tool at the bottom. The source type in this example is \"Video\" with a table-based sequence protocol on the right hand-side. Select more than one source \u26a0 NOT YET IMPLEMENTED Three sources are selected; what do you want to do with them? By selecting more than one source, you will be able to edit them all at once, add them to a collection, share or connect them. Or you could compare the sources (see Compare the sources ). Compare the sources \u26a0 NOT YET IMPLEMENTED You will be able to compare from two to six source objects at the same time side by side. Compare 2 to 6 sources with each other, similar to the Mirador web app. Annotate and connect your data (sources and/or metadata) \u26a0 NOT YET IMPLEMENTED A main feature of the flexible data storage that Knora App uses is the possibility to annotate and link sources and their metadata. An annotation can be a small note about a date like \"Not sure about the birthdate of this person. There's another date mentioned in the source XYZ\". Inside the note, it will be possible to link to another source. Links in Knora App are always bi-directional. If you link source A with source B, then source B knows about this connection. If you find source B, you have the connection to source A as well. Export, save or share the data \u26a0 NOT YET IMPLEMENTED Data sets and metadata extracted through a search can be exported as CSV, XML, or other predefined file formats. It will be also possible to store full text, advanced, and expert search queries to reuse them later, collect source objects in a collection similar to a playlist of a music app or a shopping basket. The share menu offers many tools to export the data, to send it to someone or to store it in an individual source collection.","title":"Data Management"},{"location":"user-guide/data/#data-management","text":"Once your data model is ready, you're able to add data. The Knora App offers several possibilities to add data, whether you are starting from scratch or importing data from another program.","title":"Data management"},{"location":"user-guide/data/#start-from-scratch","text":"\u26a0 NOT YET IMPLEMENTED (only mockups are presented) When a project starts from scratch, you will enter and generate new data directly in the Knora App itself. Generating new data can be done one by one with a form or with a table-based (Excel like) tool. Upload the files, e.g., the actual audio file of an interview or images of the photographs discussed in the interview Augment the metadata In case of interview transcriptions from audio or video files, Knora App will offer a simple transcription tool Create new source; e.g. upload audio file of an interview.","title":"Start from scratch"},{"location":"user-guide/data/#organize-data-and-create-additional-sources","text":"\u26a0 NOT YET IMPLEMENTED The workspace of the Knora App includes tools to connect different sources, even if they're not in the same project (linkage), to comment on a source and on their metadata fields (annotate), and to transcribe audio-visual material. These actions will generate more data and will help to find specific sources and their relations easily. It's possible to collect different sources and to store them in an individual collection. You can define more than one collection. You can share collections and invite other users to collaborate.","title":"Organize data and create additional sources"},{"location":"user-guide/data/#search-and-browse","text":"Knora App offers the possibility to the user to search in 3 different ways: full text search, advanced search and expert search (Gravsearch query). The search bar is always available in the header of each page, whether logged in or out.","title":"Search and browse"},{"location":"user-guide/data/#full-text-search","text":"Full text search performs queries including one or more terms or phrases, and returns data that matches search conditions. By default, the search is performed in all projects stored in Knora. However, it is possible to filter by project using the menu \"Filter by project\" on the left side of the search bar. https://app2.dasch.swiss - Search 1: Full text search When clicking on the search bar, the search history panel is displayed. The 10 last searches are registered. It is also possible to clear the search history list ( Clear list button at the bottom of the panel). Search history list is accessible for the full text search from any webpage. Special syntax: asterisk* can be used as a wildcard symbol \"quotation marks\" searches for the whole pattern","title":"Full text search"},{"location":"user-guide/data/#advanced-search","text":"The advanced search allows you to filter by project, by source type, or by the metadata of source types. Each filter can be standalone or combined. The metadata field can be precisely filtered with criteria such as \"contains\", \"is like\", \"equals to\", \"exists\" or in case of a date value with \"before\" or \"after\". In addition, for a metadata field that is connected to another source type, it's possible to filter by this second source type. https://app2.dasch.swiss/search/advanced - Search 2: Advanced search offers many filter combinations and is a powerful search tool. Currently, it is possible to search for only one source.","title":"Advanced search"},{"location":"user-guide/data/#expert-search","text":"The expert search can be more powerful than the advanced search, but requires knowing how to use the query language Gravsearch (based on SparQL and developed by the DaSCH team). With Gravsearch, expert users can build searches by combining text-related criteria with any other criteria. For example : you could search for a page in a manuscript that contains a certain element and also mentions a person, who lived in the same country as another person, who is the author of another author. https://app2.dasch.swiss/search/expert - Search 3: Expert search is a text area in which you can create Gravsearch queries. Here is the default example you can find in the app. To learn Gravsearch, go to the Knora documentation \u2192 Gravsearch","title":"Expert search"},{"location":"user-guide/data/#search-results","text":"","title":"Search results"},{"location":"user-guide/data/#simple-list","text":"The results of the search are displayed in an organised list with a small preview. You can select one result at a time to get more information. Search result 1: Simple list of results, similar to Google's list of results. \u26a0 NOT YET IMPLEMENTED It is not possible yet to sort or order by criteria when searching with the full text search, use the advanced search or the expert search instead to get back sorted results.","title":"Simple list"},{"location":"user-guide/data/#grid-list-lighttable","text":"The results of the search are displayed in a grid list with a big preview. You can select one result at a time to get more information. Search result 2: A preview list where the results are presented in tiles.","title":"Grid list: Lighttable"},{"location":"user-guide/data/#table-excel-like-view","text":"\u26a0 NOT YET IMPLEMENTED The search results are displayed in a table with the option to sort them. This layout is enabled when the search has been performed with only one source type . Each column of the table corresponds to one metadata. Search result 3: An Excel-like table view to edit multiple sources at once.","title":"Table: Excel-like view"},{"location":"user-guide/data/#do-research-and-work-on-your-data","text":"Once you have found the desired sources, you can (re)view them and annotate the source itself, the media file, or single metadata values. If you select more than one source, you can compare them in a side-by-side view, link them, edit them all at once, or save them in a collection. A collection is similar to a playlist in a music app or shopping basket in an online store.","title":"Do research and work on your data"},{"location":"user-guide/data/#display-a-source","text":"\u26a0 WORK IN PROGRESS The Knora App offers different source views for different media types. There's a viewer for still images, moving images, audio and document files. You can open them from the list of search results. Depending on the media type, Knora App offers different tools to work on the source. In a still image source, you're able to draw regions on the image and to annotate or transcribe this region. Usually, a still image source is used for book pages, photographs, postcards, letters etc. In time-based sources like moving image or audio document, you can mark sequences on the timeline. A transcription tool helps to annotate and to transcribe the sequence. Single source view. The source type in this example is \"Page\". Knora App will offer a graph view to visualize the connection of a selected source. The graph view is a powerful tool because you will find more information about the source by clicking through the nodes. Graph view of a single source. Additionally, you can work on the source directly, e.g, transcribe a moving image or a taped interview or mark regions of interest on still images and on documents. Single source fullframe view with the transcription tool at the bottom. The source type in this example is \"Video\" with a table-based sequence protocol on the right hand-side.","title":"Display a source"},{"location":"user-guide/data/#select-more-than-one-source","text":"\u26a0 NOT YET IMPLEMENTED Three sources are selected; what do you want to do with them? By selecting more than one source, you will be able to edit them all at once, add them to a collection, share or connect them. Or you could compare the sources (see Compare the sources ).","title":"Select more than one source"},{"location":"user-guide/data/#compare-the-sources","text":"\u26a0 NOT YET IMPLEMENTED You will be able to compare from two to six source objects at the same time side by side. Compare 2 to 6 sources with each other, similar to the Mirador web app.","title":"Compare the sources"},{"location":"user-guide/data/#annotate-and-connect-your-data-sources-andor-metadata","text":"\u26a0 NOT YET IMPLEMENTED A main feature of the flexible data storage that Knora App uses is the possibility to annotate and link sources and their metadata. An annotation can be a small note about a date like \"Not sure about the birthdate of this person. There's another date mentioned in the source XYZ\". Inside the note, it will be possible to link to another source. Links in Knora App are always bi-directional. If you link source A with source B, then source B knows about this connection. If you find source B, you have the connection to source A as well.","title":"Annotate and connect your data (sources and/or metadata)"},{"location":"user-guide/data/#export-save-or-share-the-data","text":"\u26a0 NOT YET IMPLEMENTED Data sets and metadata extracted through a search can be exported as CSV, XML, or other predefined file formats. It will be also possible to store full text, advanced, and expert search queries to reuse them later, collect source objects in a collection similar to a playlist of a music app or a shopping basket. The share menu offers many tools to export the data, to send it to someone or to store it in an individual source collection.","title":"Export, save or share the data"},{"location":"user-guide/project/","text":"Project Management Project Once you are logged in , the dashboard displays the list of your project(s). If you are a project administrator or a system administrator, you can edit the project information or archive your project from the project menu. Archived projects are stored in a list on your dashboard and they can be \"reactivated\" at any time. https://app2.dasch.swiss/dashboard - By clicking on the project name, you get access to the full project information. System administrator can create your new research project. Essential information are required such as the project name, a short project description and institution information. Form to create a new project. As project administrator or system administrator, you can define your project, add your team members, create permission groups and as most important, define your data model (ontology) and the lists of your project. https://app2.dasch.swiss/project/0803/info - Project management functionalities; e.g. Incunabula project. Project information page is displayed without restricted content, the other functionalities are reserved for project admin and system admin. Collaboration \u26a0 WORK IN PROGRESS As system admin, you can add users as project member and define their permissions roles: Who is able to edit or to see data in the project? Data includes the research sources and their metadata. Permissions can be set for the entire project or for single metadata fields. A user menu with different actions is accessible for each member of the project (link to the right side of the user line). The admin can appoint another user as project admin (or remove this permission), edit user's information, change user's password if forgotten, and remove a user. https://app2.dasch.swiss/project/0803/collaboration - Collaboration page where project admin and system admin can add new user to the team. Permissions for project admins to add new users as project member will be implemented soon. Permission groups \u26a0 NOT YET IMPLEMENTED Project admin can create one or several permission groups in their project to set specific permissions on data to a user group. Data model \u26a0 NOT YET IMPLEMENTED (only mockups are presented) The most important step in the project is the definition of the data model. Knora App will offer a tool to create easily data models. First, you have to know which data and sources you want to work with. The data model can be flexible and customizable. With Knora App, you can comply with the FAIR data standard, but compliance is not required to analyze your data. The questions to answer in creating your data model: What kind of data do I have in my project? What are the sources and what are their metadata? For example: You interviewed 20 people. During these interviews, that you taped, you talked about photographs. Among all the data collected during the project, the most important are: audio-files of the interview transcribed text of conversations (or you can transcribe the files inside the web app) photographs data about the person you interviewed location where the photograph was taken Diagram 1 shows the relationships of the data by source type from these experiences. Relationship of the data by source type Select your SOURCE TYPES In the data model editor, you select your source types from a predefined list on the right-hand side. Later, you will be able to customize the source type or define an additional default source type, if the one you need doesn't exist by default. Data model editor 1: Select all your main source types by drag and drop; e.g. for an interview, select the source type \"Audio / Sound / Interview\". In our example with the interview and the photographs, you drag and drop the following main source types from the list on the right-hand side: Audio / Sound / Interview Transcript Image / Photograph / Postcard Person Location / Place Select the METADATA fields for each source type (optional) The predefined source types offer a suggested list of metadata fields. This list could help to create a data model simply and quickly. It's also possible to deselect the suggested metadata fields (e.g., no metadata), to adapt others and to customize them. Data model editor 2: Add additional metadata fields to your source type; e.g. add the missing field \"Person\". Customize the SOURCE TYPES and the METADATA fields (optional) It's possible to customize the predefined source type and the metadata field values by clicking on the edit button of the source type. You can rename the source type, rearrange the order of the metadata fields, and set permissions. Data model editor 3: Customize the source type AUDIO; e.g. rename it into Interview Connect SOURCE TYPES in the data model (optional) If you have reusable metadata value in a source type (A), you should create an additional source type (B) and drag-and-drop it over the metadata field of the first source type (A) to connect the two data types. E.g., For the metadata \"Photographer\" in source type \"Photograph\", you should create a source type \"Person\" and connect it in \"Photograph\". Data model editor 4: Manage connections between the source types. Lists \u26a0 WORK IN PROGRESS Projects often need to define lists or hierarchies of categories that can be assigned to many different sources. Lists can be created by project admin and system admin. https://app2.dasch.swiss/project/0803/lists - Project lists: create a new list, add items by selecting the language and enter the corresponding value, repeat for each translation and press the + sign to create another item to the same level. The edition of items and child items will be implemented in a later version.","title":"Project Management"},{"location":"user-guide/project/#project-management","text":"","title":"Project Management"},{"location":"user-guide/project/#project","text":"Once you are logged in , the dashboard displays the list of your project(s). If you are a project administrator or a system administrator, you can edit the project information or archive your project from the project menu. Archived projects are stored in a list on your dashboard and they can be \"reactivated\" at any time. https://app2.dasch.swiss/dashboard - By clicking on the project name, you get access to the full project information. System administrator can create your new research project. Essential information are required such as the project name, a short project description and institution information. Form to create a new project. As project administrator or system administrator, you can define your project, add your team members, create permission groups and as most important, define your data model (ontology) and the lists of your project. https://app2.dasch.swiss/project/0803/info - Project management functionalities; e.g. Incunabula project. Project information page is displayed without restricted content, the other functionalities are reserved for project admin and system admin.","title":"Project"},{"location":"user-guide/project/#collaboration","text":"\u26a0 WORK IN PROGRESS As system admin, you can add users as project member and define their permissions roles: Who is able to edit or to see data in the project? Data includes the research sources and their metadata. Permissions can be set for the entire project or for single metadata fields. A user menu with different actions is accessible for each member of the project (link to the right side of the user line). The admin can appoint another user as project admin (or remove this permission), edit user's information, change user's password if forgotten, and remove a user. https://app2.dasch.swiss/project/0803/collaboration - Collaboration page where project admin and system admin can add new user to the team. Permissions for project admins to add new users as project member will be implemented soon.","title":"Collaboration"},{"location":"user-guide/project/#permission-groups","text":"\u26a0 NOT YET IMPLEMENTED Project admin can create one or several permission groups in their project to set specific permissions on data to a user group.","title":"Permission groups"},{"location":"user-guide/project/#data-model","text":"\u26a0 NOT YET IMPLEMENTED (only mockups are presented) The most important step in the project is the definition of the data model. Knora App will offer a tool to create easily data models. First, you have to know which data and sources you want to work with. The data model can be flexible and customizable. With Knora App, you can comply with the FAIR data standard, but compliance is not required to analyze your data. The questions to answer in creating your data model: What kind of data do I have in my project? What are the sources and what are their metadata? For example: You interviewed 20 people. During these interviews, that you taped, you talked about photographs. Among all the data collected during the project, the most important are: audio-files of the interview transcribed text of conversations (or you can transcribe the files inside the web app) photographs data about the person you interviewed location where the photograph was taken Diagram 1 shows the relationships of the data by source type from these experiences. Relationship of the data by source type","title":"Data model"},{"location":"user-guide/project/#select-your-source-types","text":"In the data model editor, you select your source types from a predefined list on the right-hand side. Later, you will be able to customize the source type or define an additional default source type, if the one you need doesn't exist by default. Data model editor 1: Select all your main source types by drag and drop; e.g. for an interview, select the source type \"Audio / Sound / Interview\". In our example with the interview and the photographs, you drag and drop the following main source types from the list on the right-hand side: Audio / Sound / Interview Transcript Image / Photograph / Postcard Person Location / Place","title":"Select your SOURCE TYPES"},{"location":"user-guide/project/#select-the-metadata-fields-for-each-source-type-optional","text":"The predefined source types offer a suggested list of metadata fields. This list could help to create a data model simply and quickly. It's also possible to deselect the suggested metadata fields (e.g., no metadata), to adapt others and to customize them. Data model editor 2: Add additional metadata fields to your source type; e.g. add the missing field \"Person\".","title":"Select the METADATA fields for each source type (optional)"},{"location":"user-guide/project/#customize-the-source-types-and-the-metadata-fields-optional","text":"It's possible to customize the predefined source type and the metadata field values by clicking on the edit button of the source type. You can rename the source type, rearrange the order of the metadata fields, and set permissions. Data model editor 3: Customize the source type AUDIO; e.g. rename it into Interview","title":"Customize the SOURCE TYPES and the METADATA fields (optional)"},{"location":"user-guide/project/#connect-source-types-in-the-data-model-optional","text":"If you have reusable metadata value in a source type (A), you should create an additional source type (B) and drag-and-drop it over the metadata field of the first source type (A) to connect the two data types. E.g., For the metadata \"Photographer\" in source type \"Photograph\", you should create a source type \"Person\" and connect it in \"Photograph\". Data model editor 4: Manage connections between the source types.","title":"Connect SOURCE TYPES in the data model (optional)"},{"location":"user-guide/project/#lists","text":"\u26a0 WORK IN PROGRESS Projects often need to define lists or hierarchies of categories that can be assigned to many different sources. Lists can be created by project admin and system admin. https://app2.dasch.swiss/project/0803/lists - Project lists: create a new list, add items by selecting the language and enter the corresponding value, repeat for each translation and press the + sign to create another item to the same level. The edition of items and child items will be implemented in a later version.","title":"Lists"},{"location":"user-guide/publication/","text":"Publication \u26a0 NOT YET IMPLEMENTED","title":"Publication"},{"location":"user-guide/publication/#publication","text":"\u26a0 NOT YET IMPLEMENTED","title":"Publication"},{"location":"user-guide/system/","text":"System Management \u26a0 Only for System administrator System administrators can get an overview of all projects and all users stored in Knora. System administration part is accessible from the user menu in the header. All projects System admin gets the list of all activated projects as well as archived projects. It is possible to create a new research project, the required information must be filled in. For each project, the system admin has the possibility to edit the project information and archive the project. Overview of all activated projects, the list of archived projects is displayed below. All users System admin gets the list of all activated and suspended users registered in Knora. New users can be created from this page only (button \"Create new\"). Overview of all users where the system admin has access to several actions. For each user, the system admin has access to several actions: Add as system admin or Remove as system admin : add or remove the user role of system admin Edit user : edit the user information (e.g. first name, last name, default language) Change user's password : the system admin can update the user's password if the user has forgotten it, the system admin must enter his password first (\u26a0 a reset password functionality will be implemented in a later version on the login page) Manage project membership : the system admin can assign the selected user to one or several project, or remove the user from a specific project Suspend user : the user is deactivated and has no more access to Knora App. The system admin can reactivate it at any time.","title":"System Management"},{"location":"user-guide/system/#system-management","text":"\u26a0 Only for System administrator System administrators can get an overview of all projects and all users stored in Knora. System administration part is accessible from the user menu in the header.","title":"System Management"},{"location":"user-guide/system/#all-projects","text":"System admin gets the list of all activated projects as well as archived projects. It is possible to create a new research project, the required information must be filled in. For each project, the system admin has the possibility to edit the project information and archive the project. Overview of all activated projects, the list of archived projects is displayed below.","title":"All projects"},{"location":"user-guide/system/#all-users","text":"System admin gets the list of all activated and suspended users registered in Knora. New users can be created from this page only (button \"Create new\"). Overview of all users where the system admin has access to several actions. For each user, the system admin has access to several actions: Add as system admin or Remove as system admin : add or remove the user role of system admin Edit user : edit the user information (e.g. first name, last name, default language) Change user's password : the system admin can update the user's password if the user has forgotten it, the system admin must enter his password first (\u26a0 a reset password functionality will be implemented in a later version on the login page) Manage project membership : the system admin can assign the selected user to one or several project, or remove the user from a specific project Suspend user : the user is deactivated and has no more access to Knora App. The system admin can reactivate it at any time.","title":"All users"},{"location":"user-guide/user/","text":"User Management https://app2.dasch.swiss/dashboard - Get access to your user profile, collections and account from the main user menu. Your user profile and projects To change your personal information as well as your default language used by the interface, you can edit your profile clicking Edit . Currently, the avatar image comes from gravatar.com (go on their website to register if you want your customized user photo). https://app2.dasch.swiss/projects - Overview of your user profile and your projects. The list of your projects is accessible, click on one project to get more information about it. As project admin, you can also edit or archive your projects, and as system admin, you can additionally create new project on this page. Edit your user profile. The username, the email address and the admin rules are not editable. Your collections \u26a0 NOT YET IMPLEMENTED You will be able to store collections of sources or specific searches to work with them later or share them with collaborators. Your account As a matter of security, it is strongly recommended to update your password at least once a year. In your account page, you can update your password. https://app2.test.dasch.swiss/account - Update your password and deactivate your user account. \u26a0 You can delete (deactivate) your own user account. Only a system administrator will be able to reactivate it.","title":"User Management"},{"location":"user-guide/user/#user-management","text":"https://app2.dasch.swiss/dashboard - Get access to your user profile, collections and account from the main user menu.","title":"User Management"},{"location":"user-guide/user/#your-user-profile-and-projects","text":"To change your personal information as well as your default language used by the interface, you can edit your profile clicking Edit . Currently, the avatar image comes from gravatar.com (go on their website to register if you want your customized user photo). https://app2.dasch.swiss/projects - Overview of your user profile and your projects. The list of your projects is accessible, click on one project to get more information about it. As project admin, you can also edit or archive your projects, and as system admin, you can additionally create new project on this page. Edit your user profile. The username, the email address and the admin rules are not editable.","title":"Your user profile and projects"},{"location":"user-guide/user/#your-collections","text":"\u26a0 NOT YET IMPLEMENTED You will be able to store collections of sources or specific searches to work with them later or share them with collaborators.","title":"Your collections"},{"location":"user-guide/user/#your-account","text":"As a matter of security, it is strongly recommended to update your password at least once a year. In your account page, you can update your password. https://app2.test.dasch.swiss/account - Update your password and deactivate your user account. \u26a0 You can delete (deactivate) your own user account. Only a system administrator will be able to reactivate it.","title":"Your account"}]}